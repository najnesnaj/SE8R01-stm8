                                      1 ;--------------------------------------------------------
                                      2 ; File Created by SDCC : free open source ANSI-C Compiler
                                      3 ; Version 3.4.0 #8981 (Jul 11 2014) (Linux)
                                      4 ; This file was generated Wed May  3 10:49:15 2017
                                      5 ;--------------------------------------------------------
                                      6 	.module se8r01
                                      7 	.optsdcc -mstm8
                                      8 	
                                      9 ;--------------------------------------------------------
                                     10 ; Public variables in this module
                                     11 ;--------------------------------------------------------
                                     12 	.globl _main
                                     13 	.globl _SE8R01_Init
                                     14 	.globl _SE8R01_Analog_Init
                                     15 	.globl _SE8R01_Calibration
                                     16 	.globl _rf_switch_bank
                                     17 	.globl _init_io
                                     18 	.globl _InitializeUART
                                     19 	.globl _InitializeI2C
                                     20 	.globl _i2c_read_register
                                     21 	.globl _print_UCHAR_hex
                                     22 	.globl _UARTPrintF
                                     23 	.globl _i2c_set_start_ack
                                     24 	.globl _i2c_send_address
                                     25 	.globl _i2c_send_reg
                                     26 	.globl _i2c_set_stop
                                     27 	.globl _i2c_set_nak
                                     28 	.globl _i2c_read
                                     29 	.globl _delay
                                     30 	.globl _InitializeSystemClock
                                     31 	.globl _InitializeSPI
                                     32 	.globl _read_spi_buf
                                     33 	.globl _write_spi_buf
                                     34 	.globl _read_spi_reg
                                     35 	.globl _write_spi_reg
                                     36 	.globl _write_spi
                                     37 	.globl _delayTenMicro
                                     38 	.globl _memset
                                     39 	.globl _tx_buf
                                     40 	.globl _rx_buf
                                     41 	.globl _ADDRESS0
                                     42 	.globl _ADDRESS1
                                     43 	.globl _ADDRESS5
                                     44 	.globl _ADDRESS4
                                     45 	.globl _ADDRESS3
                                     46 	.globl _ADDRESS2
                                     47 	.globl _status
                                     48 	.globl _pip
                                     49 	.globl _signal_lv
                                     50 	.globl _newdata
                                     51 	.globl _pload_width_now
                                     52 	.globl _SE8R01_DR_500K
                                     53 	.globl _SE8R01_DR_1M
                                     54 	.globl _SE8R01_DR_2M
                                     55 	.globl _myData_pip4
                                     56 	.globl _myData_pip5
                                     57 	.globl _gtemp
                                     58 ;--------------------------------------------------------
                                     59 ; ram data
                                     60 ;--------------------------------------------------------
                                     61 	.area DATA
      000000                         62 _gtemp::
      000000                         63 	.ds 5
      000005                         64 _myData_pip5::
      000005                         65 	.ds 5
      00000A                         66 _myData_pip4::
      00000A                         67 	.ds 5
                                     68 ;--------------------------------------------------------
                                     69 ; ram data
                                     70 ;--------------------------------------------------------
                                     71 	.area INITIALIZED
      000000                         72 _SE8R01_DR_2M::
      000000                         73 	.ds 2
      000002                         74 _SE8R01_DR_1M::
      000002                         75 	.ds 2
      000004                         76 _SE8R01_DR_500K::
      000004                         77 	.ds 2
      000006                         78 _pload_width_now::
      000006                         79 	.ds 2
      000008                         80 _newdata::
      000008                         81 	.ds 2
      00000A                         82 _signal_lv::
      00000A                         83 	.ds 1
      00000B                         84 _pip::
      00000B                         85 	.ds 2
      00000D                         86 _status::
      00000D                         87 	.ds 1
      00000E                         88 _ADDRESS2::
      00000E                         89 	.ds 1
      00000F                         90 _ADDRESS3::
      00000F                         91 	.ds 1
      000010                         92 _ADDRESS4::
      000010                         93 	.ds 1
      000011                         94 _ADDRESS5::
      000011                         95 	.ds 1
      000012                         96 _ADDRESS1::
      000012                         97 	.ds 4
      000016                         98 _ADDRESS0::
      000016                         99 	.ds 4
      00001A                        100 _rx_buf::
      00001A                        101 	.ds 32
      00003A                        102 _tx_buf::
      00003A                        103 	.ds 32
                                    104 ;--------------------------------------------------------
                                    105 ; Stack segment in internal ram 
                                    106 ;--------------------------------------------------------
                                    107 	.area	SSEG
      000000                        108 __start__stack:
      000000                        109 	.ds	1
                                    110 
                                    111 ;--------------------------------------------------------
                                    112 ; absolute external ram data
                                    113 ;--------------------------------------------------------
                                    114 	.area DABS (ABS)
                                    115 ;--------------------------------------------------------
                                    116 ; interrupt vector 
                                    117 ;--------------------------------------------------------
                                    118 	.area HOME
      000000                        119 __interrupt_vect:
      000000 82v00u00u00            120 	int s_GSINIT ;reset
      000004 82 00 00 00            121 	int 0x0000 ;trap
      000008 82 00 00 00            122 	int 0x0000 ;int0
      00000C 82 00 00 00            123 	int 0x0000 ;int1
      000010 82 00 00 00            124 	int 0x0000 ;int2
      000014 82 00 00 00            125 	int 0x0000 ;int3
      000018 82 00 00 00            126 	int 0x0000 ;int4
      00001C 82 00 00 00            127 	int 0x0000 ;int5
      000020 82 00 00 00            128 	int 0x0000 ;int6
      000024 82 00 00 00            129 	int 0x0000 ;int7
      000028 82 00 00 00            130 	int 0x0000 ;int8
      00002C 82 00 00 00            131 	int 0x0000 ;int9
      000030 82 00 00 00            132 	int 0x0000 ;int10
      000034 82 00 00 00            133 	int 0x0000 ;int11
      000038 82 00 00 00            134 	int 0x0000 ;int12
      00003C 82 00 00 00            135 	int 0x0000 ;int13
      000040 82 00 00 00            136 	int 0x0000 ;int14
      000044 82 00 00 00            137 	int 0x0000 ;int15
      000048 82 00 00 00            138 	int 0x0000 ;int16
      00004C 82 00 00 00            139 	int 0x0000 ;int17
      000050 82 00 00 00            140 	int 0x0000 ;int18
      000054 82 00 00 00            141 	int 0x0000 ;int19
      000058 82 00 00 00            142 	int 0x0000 ;int20
      00005C 82 00 00 00            143 	int 0x0000 ;int21
      000060 82 00 00 00            144 	int 0x0000 ;int22
      000064 82 00 00 00            145 	int 0x0000 ;int23
      000068 82 00 00 00            146 	int 0x0000 ;int24
      00006C 82 00 00 00            147 	int 0x0000 ;int25
      000070 82 00 00 00            148 	int 0x0000 ;int26
      000074 82 00 00 00            149 	int 0x0000 ;int27
      000078 82 00 00 00            150 	int 0x0000 ;int28
      00007C 82 00 00 00            151 	int 0x0000 ;int29
                                    152 ;--------------------------------------------------------
                                    153 ; global & static initialisations
                                    154 ;--------------------------------------------------------
                                    155 	.area HOME
                                    156 	.area GSINIT
                                    157 	.area GSFINAL
                                    158 	.area GSINIT
      000000                        159 __sdcc_gs_init_startup:
      000000                        160 __sdcc_init_data:
                                    161 ; stm8_genXINIT() start
      000000 AEr00r00         [ 2]  162 	ldw x, #l_DATA
      000003 27 07            [ 1]  163 	jreq	00002$
      000005                        164 00001$:
      000005 72 4FuFFuFF      [ 1]  165 	clr (s_DATA - 1, x)
      000009 5A               [ 2]  166 	decw x
      00000A 26 F9            [ 1]  167 	jrne	00001$
      00000C                        168 00002$:
      00000C AEr00r00         [ 2]  169 	ldw	x, #l_INITIALIZER
      00000F 27 09            [ 1]  170 	jreq	00004$
      000011                        171 00003$:
      000011 D6uFFuFF         [ 1]  172 	ld	a, (s_INITIALIZER - 1, x)
      000014 D7uFFuFF         [ 1]  173 	ld	(s_INITIALIZED - 1, x), a
      000017 5A               [ 2]  174 	decw	x
      000018 26 F7            [ 1]  175 	jrne	00003$
      00001A                        176 00004$:
                                    177 ; stm8_genXINIT() end
                                    178 	.area GSFINAL
      000000 CCr00r80         [ 2]  179 	jp	__sdcc_program_startup
                                    180 ;--------------------------------------------------------
                                    181 ; Home
                                    182 ;--------------------------------------------------------
                                    183 	.area HOME
                                    184 	.area HOME
      000080                        185 __sdcc_program_startup:
      000080 CCr08r27         [ 2]  186 	jp	_main
                                    187 ;	return from main will return to caller
                                    188 ;--------------------------------------------------------
                                    189 ; code
                                    190 ;--------------------------------------------------------
                                    191 	.area CODE
                                    192 ;	se8r01.c: 46: void delayTenMicro (void) {
                                    193 ;	-----------------------------------------
                                    194 ;	 function delayTenMicro
                                    195 ;	-----------------------------------------
      000000                        196 _delayTenMicro:
                                    197 ;	se8r01.c: 48: for (a = 0; a < 50; ++a)
      000000 A6 32            [ 1]  198 	ld	a, #0x32
      000002                        199 00104$:
                                    200 ;	se8r01.c: 49: __asm__("nop");
      000002 9D               [ 1]  201 	nop
      000003 4A               [ 1]  202 	dec	a
                                    203 ;	se8r01.c: 48: for (a = 0; a < 50; ++a)
      000004 4D               [ 1]  204 	tnz	a
      000005 26 FB            [ 1]  205 	jrne	00104$
      000007 81               [ 4]  206 	ret
                                    207 ;	se8r01.c: 51: UCHAR write_spi (UCHAR value) {
                                    208 ;	-----------------------------------------
                                    209 ;	 function write_spi
                                    210 ;	-----------------------------------------
      000008                        211 _write_spi:
                                    212 ;	se8r01.c: 53: delayTenMicro ();
      000008 CDr00r00         [ 4]  213 	call	_delayTenMicro
                                    214 ;	se8r01.c: 54: SPI_DR = value;
      00000B AE 52 04         [ 2]  215 	ldw	x, #0x5204
      00000E 7B 03            [ 1]  216 	ld	a, (0x03, sp)
      000010 F7               [ 1]  217 	ld	(x), a
                                    218 ;	se8r01.c: 55: delayTenMicro ();
      000011 CDr00r00         [ 4]  219 	call	_delayTenMicro
                                    220 ;	se8r01.c: 56: while ((SPI_SR & TXE) == 0);
      000014                        221 00101$:
      000014 AE 52 03         [ 2]  222 	ldw	x, #0x5203
      000017 F6               [ 1]  223 	ld	a, (x)
      000018 A5 02            [ 1]  224 	bcp	a, #0x02
      00001A 27 F8            [ 1]  225 	jreq	00101$
                                    226 ;	se8r01.c: 57: delayTenMicro ();
      00001C CDr00r00         [ 4]  227 	call	_delayTenMicro
                                    228 ;	se8r01.c: 58: while ((SPI_SR & RXNE) == 0);
      00001F                        229 00104$:
      00001F AE 52 03         [ 2]  230 	ldw	x, #0x5203
      000022 F6               [ 1]  231 	ld	a, (x)
      000023 44               [ 1]  232 	srl	a
      000024 24 F9            [ 1]  233 	jrnc	00104$
                                    234 ;	se8r01.c: 59: delayTenMicro ();
      000026 CDr00r00         [ 4]  235 	call	_delayTenMicro
                                    236 ;	se8r01.c: 60: ret = SPI_DR;
      000029 AE 52 04         [ 2]  237 	ldw	x, #0x5204
      00002C F6               [ 1]  238 	ld	a, (x)
                                    239 ;	se8r01.c: 61: return (ret);
      00002D 81               [ 4]  240 	ret
                                    241 ;	se8r01.c: 63: UCHAR write_spi_reg (UCHAR reg, UCHAR value) {
                                    242 ;	-----------------------------------------
                                    243 ;	 function write_spi_reg
                                    244 ;	-----------------------------------------
      00002E                        245 _write_spi_reg:
      00002E 88               [ 1]  246 	push	a
                                    247 ;	se8r01.c: 65: PC_ODR &= ~(1 << CSN);
      00002F AE 50 0A         [ 2]  248 	ldw	x, #0x500a
      000032 F6               [ 1]  249 	ld	a, (x)
      000033 A4 F7            [ 1]  250 	and	a, #0xf7
      000035 F7               [ 1]  251 	ld	(x), a
                                    252 ;	se8r01.c: 66: ret = write_spi (reg);
      000036 7B 04            [ 1]  253 	ld	a, (0x04, sp)
      000038 88               [ 1]  254 	push	a
      000039 CDr00r08         [ 4]  255 	call	_write_spi
      00003C 5B 01            [ 2]  256 	addw	sp, #1
      00003E 6B 01            [ 1]  257 	ld	(0x01, sp), a
                                    258 ;	se8r01.c: 67: if (reg != NOP && reg != FLUSH_RX && reg != FLUSH_TX)
      000040 7B 04            [ 1]  259 	ld	a, (0x04, sp)
      000042 A1 FF            [ 1]  260 	cp	a, #0xff
      000044 27 15            [ 1]  261 	jreq	00102$
      000046 7B 04            [ 1]  262 	ld	a, (0x04, sp)
      000048 A1 E2            [ 1]  263 	cp	a, #0xe2
      00004A 27 0F            [ 1]  264 	jreq	00102$
      00004C 7B 04            [ 1]  265 	ld	a, (0x04, sp)
      00004E A1 E1            [ 1]  266 	cp	a, #0xe1
      000050 27 09            [ 1]  267 	jreq	00102$
                                    268 ;	se8r01.c: 68: write_spi (value);
      000052 7B 05            [ 1]  269 	ld	a, (0x05, sp)
      000054 88               [ 1]  270 	push	a
      000055 CDr00r08         [ 4]  271 	call	_write_spi
      000058 84               [ 1]  272 	pop	a
      000059 20 03            [ 2]  273 	jra	00103$
      00005B                        274 00102$:
                                    275 ;	se8r01.c: 70: delayTenMicro ();
      00005B CDr00r00         [ 4]  276 	call	_delayTenMicro
      00005E                        277 00103$:
                                    278 ;	se8r01.c: 71: PC_ODR |= (1 << CSN);
      00005E AE 50 0A         [ 2]  279 	ldw	x, #0x500a
      000061 F6               [ 1]  280 	ld	a, (x)
      000062 AA 08            [ 1]  281 	or	a, #0x08
      000064 F7               [ 1]  282 	ld	(x), a
                                    283 ;	se8r01.c: 72: return (ret);
      000065 7B 01            [ 1]  284 	ld	a, (0x01, sp)
      000067 5B 01            [ 2]  285 	addw	sp, #1
      000069 81               [ 4]  286 	ret
                                    287 ;	se8r01.c: 74: UCHAR read_spi_reg (UCHAR reg) {
                                    288 ;	-----------------------------------------
                                    289 ;	 function read_spi_reg
                                    290 ;	-----------------------------------------
      00006A                        291 _read_spi_reg:
      00006A 88               [ 1]  292 	push	a
                                    293 ;	se8r01.c: 76: PC_ODR &= ~(1 << CSN);
      00006B AE 50 0A         [ 2]  294 	ldw	x, #0x500a
      00006E F6               [ 1]  295 	ld	a, (x)
      00006F A4 F7            [ 1]  296 	and	a, #0xf7
      000071 F7               [ 1]  297 	ld	(x), a
                                    298 ;	se8r01.c: 77: ret = write_spi (reg);
      000072 7B 04            [ 1]  299 	ld	a, (0x04, sp)
      000074 88               [ 1]  300 	push	a
      000075 CDr00r08         [ 4]  301 	call	_write_spi
      000078 5B 01            [ 2]  302 	addw	sp, #1
      00007A 6B 01            [ 1]  303 	ld	(0x01, sp), a
                                    304 ;	se8r01.c: 78: if (reg != NOP && reg != FLUSH_RX && reg != FLUSH_TX)
      00007C 7B 04            [ 1]  305 	ld	a, (0x04, sp)
      00007E A1 FF            [ 1]  306 	cp	a, #0xff
      000080 27 17            [ 1]  307 	jreq	00102$
      000082 7B 04            [ 1]  308 	ld	a, (0x04, sp)
      000084 A1 E2            [ 1]  309 	cp	a, #0xe2
      000086 27 11            [ 1]  310 	jreq	00102$
      000088 7B 04            [ 1]  311 	ld	a, (0x04, sp)
      00008A A1 E1            [ 1]  312 	cp	a, #0xe1
      00008C 27 0B            [ 1]  313 	jreq	00102$
                                    314 ;	se8r01.c: 79: ret = write_spi (NOP);
      00008E 4B FF            [ 1]  315 	push	#0xff
      000090 CDr00r08         [ 4]  316 	call	_write_spi
      000093 5B 01            [ 2]  317 	addw	sp, #1
      000095 6B 01            [ 1]  318 	ld	(0x01, sp), a
      000097 20 03            [ 2]  319 	jra	00103$
      000099                        320 00102$:
                                    321 ;	se8r01.c: 81: delayTenMicro ();
      000099 CDr00r00         [ 4]  322 	call	_delayTenMicro
      00009C                        323 00103$:
                                    324 ;	se8r01.c: 82: PC_ODR |= (1 << CSN);
      00009C AE 50 0A         [ 2]  325 	ldw	x, #0x500a
      00009F F6               [ 1]  326 	ld	a, (x)
      0000A0 AA 08            [ 1]  327 	or	a, #0x08
      0000A2 F7               [ 1]  328 	ld	(x), a
                                    329 ;	se8r01.c: 83: return (ret);
      0000A3 7B 01            [ 1]  330 	ld	a, (0x01, sp)
      0000A5 5B 01            [ 2]  331 	addw	sp, #1
      0000A7 81               [ 4]  332 	ret
                                    333 ;	se8r01.c: 85: UCHAR write_spi_buf (UCHAR reg, UCHAR *array, UCHAR len) {
                                    334 ;	-----------------------------------------
                                    335 ;	 function write_spi_buf
                                    336 ;	-----------------------------------------
      0000A8                        337 _write_spi_buf:
      0000A8 52 02            [ 2]  338 	sub	sp, #2
                                    339 ;	se8r01.c: 87: PC_ODR &= ~(1 << CSN);
      0000AA AE 50 0A         [ 2]  340 	ldw	x, #0x500a
      0000AD F6               [ 1]  341 	ld	a, (x)
      0000AE A4 F7            [ 1]  342 	and	a, #0xf7
      0000B0 F7               [ 1]  343 	ld	(x), a
                                    344 ;	se8r01.c: 88: ret = write_spi (reg);
      0000B1 7B 05            [ 1]  345 	ld	a, (0x05, sp)
      0000B3 88               [ 1]  346 	push	a
      0000B4 CDr00r08         [ 4]  347 	call	_write_spi
      0000B7 5B 01            [ 2]  348 	addw	sp, #1
      0000B9 6B 02            [ 1]  349 	ld	(0x02, sp), a
                                    350 ;	se8r01.c: 89: for (n = 0; n < len; ++n)
      0000BB 0F 01            [ 1]  351 	clr	(0x01, sp)
      0000BD                        352 00103$:
      0000BD 7B 01            [ 1]  353 	ld	a, (0x01, sp)
      0000BF 11 08            [ 1]  354 	cp	a, (0x08, sp)
      0000C1 24 11            [ 1]  355 	jrnc	00101$
                                    356 ;	se8r01.c: 90: write_spi (array[n]);
      0000C3 5F               [ 1]  357 	clrw	x
      0000C4 7B 01            [ 1]  358 	ld	a, (0x01, sp)
      0000C6 97               [ 1]  359 	ld	xl, a
      0000C7 72 FB 06         [ 2]  360 	addw	x, (0x06, sp)
      0000CA F6               [ 1]  361 	ld	a, (x)
      0000CB 88               [ 1]  362 	push	a
      0000CC CDr00r08         [ 4]  363 	call	_write_spi
      0000CF 84               [ 1]  364 	pop	a
                                    365 ;	se8r01.c: 89: for (n = 0; n < len; ++n)
      0000D0 0C 01            [ 1]  366 	inc	(0x01, sp)
      0000D2 20 E9            [ 2]  367 	jra	00103$
      0000D4                        368 00101$:
                                    369 ;	se8r01.c: 91: PC_ODR |= (1 << CSN);
      0000D4 AE 50 0A         [ 2]  370 	ldw	x, #0x500a
      0000D7 F6               [ 1]  371 	ld	a, (x)
      0000D8 AA 08            [ 1]  372 	or	a, #0x08
      0000DA F7               [ 1]  373 	ld	(x), a
                                    374 ;	se8r01.c: 92: return (ret);
      0000DB 7B 02            [ 1]  375 	ld	a, (0x02, sp)
      0000DD 5B 02            [ 2]  376 	addw	sp, #2
      0000DF 81               [ 4]  377 	ret
                                    378 ;	se8r01.c: 94: UCHAR read_spi_buf (UCHAR reg, UCHAR *array, UCHAR len) {
                                    379 ;	-----------------------------------------
                                    380 ;	 function read_spi_buf
                                    381 ;	-----------------------------------------
      0000E0                        382 _read_spi_buf:
      0000E0 52 02            [ 2]  383 	sub	sp, #2
                                    384 ;	se8r01.c: 96: PC_ODR &= ~(1 << CSN);
      0000E2 AE 50 0A         [ 2]  385 	ldw	x, #0x500a
      0000E5 F6               [ 1]  386 	ld	a, (x)
      0000E6 A4 F7            [ 1]  387 	and	a, #0xf7
      0000E8 F7               [ 1]  388 	ld	(x), a
                                    389 ;	se8r01.c: 97: ret = write_spi (reg);
      0000E9 7B 05            [ 1]  390 	ld	a, (0x05, sp)
      0000EB 88               [ 1]  391 	push	a
      0000EC CDr00r08         [ 4]  392 	call	_write_spi
      0000EF 5B 01            [ 2]  393 	addw	sp, #1
      0000F1 6B 01            [ 1]  394 	ld	(0x01, sp), a
                                    395 ;	se8r01.c: 98: for (n = 0; n < len; ++n)
      0000F3 0F 02            [ 1]  396 	clr	(0x02, sp)
      0000F5                        397 00103$:
      0000F5 7B 02            [ 1]  398 	ld	a, (0x02, sp)
      0000F7 11 08            [ 1]  399 	cp	a, (0x08, sp)
      0000F9 24 15            [ 1]  400 	jrnc	00101$
                                    401 ;	se8r01.c: 99: array[n] = write_spi (NOP);
      0000FB 5F               [ 1]  402 	clrw	x
      0000FC 7B 02            [ 1]  403 	ld	a, (0x02, sp)
      0000FE 97               [ 1]  404 	ld	xl, a
      0000FF 72 FB 06         [ 2]  405 	addw	x, (0x06, sp)
      000102 89               [ 2]  406 	pushw	x
      000103 4B FF            [ 1]  407 	push	#0xff
      000105 CDr00r08         [ 4]  408 	call	_write_spi
      000108 5B 01            [ 2]  409 	addw	sp, #1
      00010A 85               [ 2]  410 	popw	x
      00010B F7               [ 1]  411 	ld	(x), a
                                    412 ;	se8r01.c: 98: for (n = 0; n < len; ++n)
      00010C 0C 02            [ 1]  413 	inc	(0x02, sp)
      00010E 20 E5            [ 2]  414 	jra	00103$
      000110                        415 00101$:
                                    416 ;	se8r01.c: 100: PC_ODR |= (1 << CSN);
      000110 AE 50 0A         [ 2]  417 	ldw	x, #0x500a
      000113 F6               [ 1]  418 	ld	a, (x)
      000114 AA 08            [ 1]  419 	or	a, #0x08
      000116 F7               [ 1]  420 	ld	(x), a
                                    421 ;	se8r01.c: 101: return (ret);
      000117 7B 01            [ 1]  422 	ld	a, (0x01, sp)
      000119 5B 02            [ 2]  423 	addw	sp, #2
      00011B 81               [ 4]  424 	ret
                                    425 ;	se8r01.c: 103: void InitializeSPI () {
                                    426 ;	-----------------------------------------
                                    427 ;	 function InitializeSPI
                                    428 ;	-----------------------------------------
      00011C                        429 _InitializeSPI:
                                    430 ;	se8r01.c: 104: SPI_CR1 = MSBFIRST | SPI_ENABLE | BR_DIV256 | MASTER | CPOL0 | CPHA0;
      00011C AE 52 00         [ 2]  431 	ldw	x, #0x5200
      00011F A6 7C            [ 1]  432 	ld	a, #0x7c
      000121 F7               [ 1]  433 	ld	(x), a
                                    434 ;	se8r01.c: 105: SPI_CR2 = BDM_2LINE | CRCEN_OFF | CRCNEXT_TXBUF | FULL_DUPLEX | SSM_DISABLE;
      000122 AE 52 01         [ 2]  435 	ldw	x, #0x5201
      000125 7F               [ 1]  436 	clr	(x)
                                    437 ;	se8r01.c: 106: SPI_ICR = TXIE_MASKED | RXIE_MASKED | ERRIE_MASKED | WKIE_MASKED;
      000126 AE 52 02         [ 2]  438 	ldw	x, #0x5202
      000129 7F               [ 1]  439 	clr	(x)
                                    440 ;	se8r01.c: 107: PC_DDR = (1 << PC3) | (1 << PC4); // output mode
      00012A AE 50 0C         [ 2]  441 	ldw	x, #0x500c
      00012D A6 18            [ 1]  442 	ld	a, #0x18
      00012F F7               [ 1]  443 	ld	(x), a
                                    444 ;	se8r01.c: 108: PC_CR1 = (1 << PC3) | (1 << PC4); // push-pull
      000130 AE 50 0D         [ 2]  445 	ldw	x, #0x500d
      000133 A6 18            [ 1]  446 	ld	a, #0x18
      000135 F7               [ 1]  447 	ld	(x), a
                                    448 ;	se8r01.c: 109: PC_CR2 = (1 << PC3) | (1 << PC4); // up to 10MHz speed
      000136 AE 50 0E         [ 2]  449 	ldw	x, #0x500e
      000139 A6 18            [ 1]  450 	ld	a, #0x18
      00013B F7               [ 1]  451 	ld	(x), a
                                    452 ;	se8r01.c: 111: PC_ODR &= ~(1 << CE);
      00013C AE 50 0A         [ 2]  453 	ldw	x, #0x500a
      00013F F6               [ 1]  454 	ld	a, (x)
      000140 A4 EF            [ 1]  455 	and	a, #0xef
      000142 F7               [ 1]  456 	ld	(x), a
      000143 81               [ 4]  457 	ret
                                    458 ;	se8r01.c: 113: void InitializeSystemClock() {
                                    459 ;	-----------------------------------------
                                    460 ;	 function InitializeSystemClock
                                    461 ;	-----------------------------------------
      000144                        462 _InitializeSystemClock:
                                    463 ;	se8r01.c: 114: CLK_ICKR = 0;                       //  Reset the Internal Clock Register.
      000144 AE 50 C0         [ 2]  464 	ldw	x, #0x50c0
      000147 7F               [ 1]  465 	clr	(x)
                                    466 ;	se8r01.c: 115: CLK_ICKR = CLK_HSIEN;               //  Enable the HSI.
      000148 AE 50 C0         [ 2]  467 	ldw	x, #0x50c0
      00014B A6 01            [ 1]  468 	ld	a, #0x01
      00014D F7               [ 1]  469 	ld	(x), a
                                    470 ;	se8r01.c: 116: CLK_ECKR = 0;                       //  Disable the external clock.
      00014E AE 50 C1         [ 2]  471 	ldw	x, #0x50c1
      000151 7F               [ 1]  472 	clr	(x)
                                    473 ;	se8r01.c: 117: while ((CLK_ICKR & CLK_HSIRDY) == 0);       //  Wait for the HSI to be ready for use.
      000152                        474 00101$:
      000152 AE 50 C0         [ 2]  475 	ldw	x, #0x50c0
      000155 F6               [ 1]  476 	ld	a, (x)
      000156 A5 02            [ 1]  477 	bcp	a, #0x02
      000158 27 F8            [ 1]  478 	jreq	00101$
                                    479 ;	se8r01.c: 118: CLK_CKDIVR = 0;                     //  Ensure the clocks are running at full speed.
      00015A AE 50 C6         [ 2]  480 	ldw	x, #0x50c6
      00015D 7F               [ 1]  481 	clr	(x)
                                    482 ;	se8r01.c: 119: CLK_PCKENR1 = 0xff;                 //  Enable all peripheral clocks.
      00015E AE 50 C7         [ 2]  483 	ldw	x, #0x50c7
      000161 A6 FF            [ 1]  484 	ld	a, #0xff
      000163 F7               [ 1]  485 	ld	(x), a
                                    486 ;	se8r01.c: 120: CLK_PCKENR2 = 0xff;                 //  Ditto.
      000164 AE 50 CA         [ 2]  487 	ldw	x, #0x50ca
      000167 A6 FF            [ 1]  488 	ld	a, #0xff
      000169 F7               [ 1]  489 	ld	(x), a
                                    490 ;	se8r01.c: 121: CLK_CCOR = 0;                       //  Turn off CCO.
      00016A AE 50 C9         [ 2]  491 	ldw	x, #0x50c9
      00016D 7F               [ 1]  492 	clr	(x)
                                    493 ;	se8r01.c: 122: CLK_HSITRIMR = 0;                   //  Turn off any HSIU trimming.
      00016E AE 50 CC         [ 2]  494 	ldw	x, #0x50cc
      000171 7F               [ 1]  495 	clr	(x)
                                    496 ;	se8r01.c: 123: CLK_SWIMCCR = 0;                    //  Set SWIM to run at clock / 2.
      000172 AE 50 CD         [ 2]  497 	ldw	x, #0x50cd
      000175 7F               [ 1]  498 	clr	(x)
                                    499 ;	se8r01.c: 124: CLK_SWR = 0xe1;                     //  Use HSI as the clock source.
      000176 AE 50 C4         [ 2]  500 	ldw	x, #0x50c4
      000179 A6 E1            [ 1]  501 	ld	a, #0xe1
      00017B F7               [ 1]  502 	ld	(x), a
                                    503 ;	se8r01.c: 125: CLK_SWCR = 0;                       //  Reset the clock switch control register.
      00017C AE 50 C5         [ 2]  504 	ldw	x, #0x50c5
      00017F 7F               [ 1]  505 	clr	(x)
                                    506 ;	se8r01.c: 126: CLK_SWCR = CLK_SWEN;                //  Enable switching.
      000180 AE 50 C5         [ 2]  507 	ldw	x, #0x50c5
      000183 A6 02            [ 1]  508 	ld	a, #0x02
      000185 F7               [ 1]  509 	ld	(x), a
                                    510 ;	se8r01.c: 127: while ((CLK_SWCR & CLK_SWBSY) != 0);        //  Pause while the clock switch is busy.
      000186                        511 00104$:
      000186 AE 50 C5         [ 2]  512 	ldw	x, #0x50c5
      000189 F6               [ 1]  513 	ld	a, (x)
      00018A 44               [ 1]  514 	srl	a
      00018B 25 F9            [ 1]  515 	jrc	00104$
      00018D 81               [ 4]  516 	ret
                                    517 ;	se8r01.c: 129: void delay (int time_ms) {
                                    518 ;	-----------------------------------------
                                    519 ;	 function delay
                                    520 ;	-----------------------------------------
      00018E                        521 _delay:
      00018E 52 0A            [ 2]  522 	sub	sp, #10
                                    523 ;	se8r01.c: 131: for (x = 0; x < 1036*time_ms; ++x)
      000190 5F               [ 1]  524 	clrw	x
      000191 1F 03            [ 2]  525 	ldw	(0x03, sp), x
      000193 1F 01            [ 2]  526 	ldw	(0x01, sp), x
      000195 1E 0D            [ 2]  527 	ldw	x, (0x0d, sp)
      000197 89               [ 2]  528 	pushw	x
      000198 4B 0C            [ 1]  529 	push	#0x0c
      00019A 4B 04            [ 1]  530 	push	#0x04
      00019C CDr00r00         [ 4]  531 	call	__mulint
      00019F 5B 04            [ 2]  532 	addw	sp, #4
      0001A1 1F 05            [ 2]  533 	ldw	(0x05, sp), x
      0001A3                        534 00103$:
      0001A3 16 05            [ 2]  535 	ldw	y, (0x05, sp)
      0001A5 17 09            [ 2]  536 	ldw	(0x09, sp), y
      0001A7 7B 09            [ 1]  537 	ld	a, (0x09, sp)
      0001A9 49               [ 1]  538 	rlc	a
      0001AA 4F               [ 1]  539 	clr	a
      0001AB A2 00            [ 1]  540 	sbc	a, #0x00
      0001AD 6B 08            [ 1]  541 	ld	(0x08, sp), a
      0001AF 6B 07            [ 1]  542 	ld	(0x07, sp), a
      0001B1 1E 03            [ 2]  543 	ldw	x, (0x03, sp)
      0001B3 13 09            [ 2]  544 	cpw	x, (0x09, sp)
      0001B5 7B 02            [ 1]  545 	ld	a, (0x02, sp)
      0001B7 12 08            [ 1]  546 	sbc	a, (0x08, sp)
      0001B9 7B 01            [ 1]  547 	ld	a, (0x01, sp)
      0001BB 12 07            [ 1]  548 	sbc	a, (0x07, sp)
      0001BD 2E 17            [ 1]  549 	jrsge	00105$
                                    550 ;	se8r01.c: 132: __asm__("nop");
      0001BF 9D               [ 1]  551 	nop
                                    552 ;	se8r01.c: 131: for (x = 0; x < 1036*time_ms; ++x)
      0001C0 16 03            [ 2]  553 	ldw	y, (0x03, sp)
      0001C2 72 A9 00 01      [ 2]  554 	addw	y, #0x0001
      0001C6 7B 02            [ 1]  555 	ld	a, (0x02, sp)
      0001C8 A9 00            [ 1]  556 	adc	a, #0x00
      0001CA 97               [ 1]  557 	ld	xl, a
      0001CB 7B 01            [ 1]  558 	ld	a, (0x01, sp)
      0001CD A9 00            [ 1]  559 	adc	a, #0x00
      0001CF 95               [ 1]  560 	ld	xh, a
      0001D0 17 03            [ 2]  561 	ldw	(0x03, sp), y
      0001D2 1F 01            [ 2]  562 	ldw	(0x01, sp), x
      0001D4 20 CD            [ 2]  563 	jra	00103$
      0001D6                        564 00105$:
      0001D6 5B 0A            [ 2]  565 	addw	sp, #10
      0001D8 81               [ 4]  566 	ret
                                    567 ;	se8r01.c: 134: void i2c_read (unsigned char *x) {
                                    568 ;	-----------------------------------------
                                    569 ;	 function i2c_read
                                    570 ;	-----------------------------------------
      0001D9                        571 _i2c_read:
                                    572 ;	se8r01.c: 135: while ((I2C_SR1 & I2C_RXNE) == 0);
      0001D9                        573 00101$:
      0001D9 AE 52 17         [ 2]  574 	ldw	x, #0x5217
      0001DC F6               [ 1]  575 	ld	a, (x)
      0001DD A5 40            [ 1]  576 	bcp	a, #0x40
      0001DF 27 F8            [ 1]  577 	jreq	00101$
                                    578 ;	se8r01.c: 136: *x = I2C_DR;
      0001E1 16 03            [ 2]  579 	ldw	y, (0x03, sp)
      0001E3 AE 52 16         [ 2]  580 	ldw	x, #0x5216
      0001E6 F6               [ 1]  581 	ld	a, (x)
      0001E7 90 F7            [ 1]  582 	ld	(y), a
      0001E9 81               [ 4]  583 	ret
                                    584 ;	se8r01.c: 138: void i2c_set_nak (void) {
                                    585 ;	-----------------------------------------
                                    586 ;	 function i2c_set_nak
                                    587 ;	-----------------------------------------
      0001EA                        588 _i2c_set_nak:
                                    589 ;	se8r01.c: 139: I2C_CR2 &= ~I2C_ACK;
      0001EA AE 52 11         [ 2]  590 	ldw	x, #0x5211
      0001ED F6               [ 1]  591 	ld	a, (x)
      0001EE A4 FB            [ 1]  592 	and	a, #0xfb
      0001F0 F7               [ 1]  593 	ld	(x), a
      0001F1 81               [ 4]  594 	ret
                                    595 ;	se8r01.c: 141: void i2c_set_stop (void) {
                                    596 ;	-----------------------------------------
                                    597 ;	 function i2c_set_stop
                                    598 ;	-----------------------------------------
      0001F2                        599 _i2c_set_stop:
                                    600 ;	se8r01.c: 142: I2C_CR2 |= I2C_STOP;
      0001F2 AE 52 11         [ 2]  601 	ldw	x, #0x5211
      0001F5 F6               [ 1]  602 	ld	a, (x)
      0001F6 AA 02            [ 1]  603 	or	a, #0x02
      0001F8 F7               [ 1]  604 	ld	(x), a
      0001F9 81               [ 4]  605 	ret
                                    606 ;	se8r01.c: 144: void i2c_send_reg (UCHAR addr) {
                                    607 ;	-----------------------------------------
                                    608 ;	 function i2c_send_reg
                                    609 ;	-----------------------------------------
      0001FA                        610 _i2c_send_reg:
      0001FA 52 02            [ 2]  611 	sub	sp, #2
                                    612 ;	se8r01.c: 146: reg = I2C_SR1;
      0001FC AE 52 17         [ 2]  613 	ldw	x, #0x5217
      0001FF F6               [ 1]  614 	ld	a, (x)
      000200 5F               [ 1]  615 	clrw	x
      000201 97               [ 1]  616 	ld	xl, a
      000202 1F 01            [ 2]  617 	ldw	(0x01, sp), x
                                    618 ;	se8r01.c: 147: reg = I2C_SR3;
      000204 AE 52 19         [ 2]  619 	ldw	x, #0x5219
      000207 F6               [ 1]  620 	ld	a, (x)
      000208 5F               [ 1]  621 	clrw	x
      000209 97               [ 1]  622 	ld	xl, a
      00020A 1F 01            [ 2]  623 	ldw	(0x01, sp), x
                                    624 ;	se8r01.c: 148: I2C_DR = addr;
      00020C AE 52 16         [ 2]  625 	ldw	x, #0x5216
      00020F 7B 05            [ 1]  626 	ld	a, (0x05, sp)
      000211 F7               [ 1]  627 	ld	(x), a
                                    628 ;	se8r01.c: 149: while ((I2C_SR1 & I2C_TXE) == 0);
      000212                        629 00101$:
      000212 AE 52 17         [ 2]  630 	ldw	x, #0x5217
      000215 F6               [ 1]  631 	ld	a, (x)
      000216 48               [ 1]  632 	sll	a
      000217 24 F9            [ 1]  633 	jrnc	00101$
      000219 5B 02            [ 2]  634 	addw	sp, #2
      00021B 81               [ 4]  635 	ret
                                    636 ;	se8r01.c: 151: void i2c_send_address (UCHAR addr, UCHAR mode) {
                                    637 ;	-----------------------------------------
                                    638 ;	 function i2c_send_address
                                    639 ;	-----------------------------------------
      00021C                        640 _i2c_send_address:
      00021C 52 03            [ 2]  641 	sub	sp, #3
                                    642 ;	se8r01.c: 153: reg = I2C_SR1;
      00021E AE 52 17         [ 2]  643 	ldw	x, #0x5217
      000221 F6               [ 1]  644 	ld	a, (x)
      000222 5F               [ 1]  645 	clrw	x
      000223 97               [ 1]  646 	ld	xl, a
      000224 1F 01            [ 2]  647 	ldw	(0x01, sp), x
                                    648 ;	se8r01.c: 154: I2C_DR = (addr << 1) | mode;
      000226 7B 06            [ 1]  649 	ld	a, (0x06, sp)
      000228 48               [ 1]  650 	sll	a
      000229 1A 07            [ 1]  651 	or	a, (0x07, sp)
      00022B AE 52 16         [ 2]  652 	ldw	x, #0x5216
      00022E F7               [ 1]  653 	ld	(x), a
                                    654 ;	se8r01.c: 155: if (mode == I2C_READ) {
      00022F 7B 07            [ 1]  655 	ld	a, (0x07, sp)
      000231 A1 01            [ 1]  656 	cp	a, #0x01
      000233 26 06            [ 1]  657 	jrne	00127$
      000235 A6 01            [ 1]  658 	ld	a, #0x01
      000237 6B 03            [ 1]  659 	ld	(0x03, sp), a
      000239 20 02            [ 2]  660 	jra	00128$
      00023B                        661 00127$:
      00023B 0F 03            [ 1]  662 	clr	(0x03, sp)
      00023D                        663 00128$:
      00023D 0D 03            [ 1]  664 	tnz	(0x03, sp)
      00023F 27 08            [ 1]  665 	jreq	00103$
                                    666 ;	se8r01.c: 156: I2C_OARL = 0;
      000241 AE 52 13         [ 2]  667 	ldw	x, #0x5213
      000244 7F               [ 1]  668 	clr	(x)
                                    669 ;	se8r01.c: 157: I2C_OARH = 0;
      000245 AE 52 14         [ 2]  670 	ldw	x, #0x5214
      000248 7F               [ 1]  671 	clr	(x)
                                    672 ;	se8r01.c: 159: while ((I2C_SR1 & I2C_ADDR) == 0);
      000249                        673 00103$:
                                    674 ;	se8r01.c: 153: reg = I2C_SR1;
      000249 AE 52 17         [ 2]  675 	ldw	x, #0x5217
      00024C F6               [ 1]  676 	ld	a, (x)
                                    677 ;	se8r01.c: 159: while ((I2C_SR1 & I2C_ADDR) == 0);
      00024D A5 02            [ 1]  678 	bcp	a, #0x02
      00024F 27 F8            [ 1]  679 	jreq	00103$
                                    680 ;	se8r01.c: 160: if (mode == I2C_READ)
      000251 0D 03            [ 1]  681 	tnz	(0x03, sp)
      000253 27 06            [ 1]  682 	jreq	00108$
                                    683 ;	se8r01.c: 161: UNSET (I2C_SR1, I2C_ADDR);
      000255 A4 FD            [ 1]  684 	and	a, #0xfd
      000257 AE 52 17         [ 2]  685 	ldw	x, #0x5217
      00025A F7               [ 1]  686 	ld	(x), a
      00025B                        687 00108$:
      00025B 5B 03            [ 2]  688 	addw	sp, #3
      00025D 81               [ 4]  689 	ret
                                    690 ;	se8r01.c: 163: void i2c_set_start_ack (void) {
                                    691 ;	-----------------------------------------
                                    692 ;	 function i2c_set_start_ack
                                    693 ;	-----------------------------------------
      00025E                        694 _i2c_set_start_ack:
                                    695 ;	se8r01.c: 164: I2C_CR2 = I2C_ACK | I2C_START;
      00025E AE 52 11         [ 2]  696 	ldw	x, #0x5211
      000261 A6 05            [ 1]  697 	ld	a, #0x05
      000263 F7               [ 1]  698 	ld	(x), a
                                    699 ;	se8r01.c: 165: while ((I2C_SR1 & I2C_SB) == 0);
      000264                        700 00101$:
      000264 AE 52 17         [ 2]  701 	ldw	x, #0x5217
      000267 F6               [ 1]  702 	ld	a, (x)
      000268 44               [ 1]  703 	srl	a
      000269 24 F9            [ 1]  704 	jrnc	00101$
      00026B 81               [ 4]  705 	ret
                                    706 ;	se8r01.c: 170: void UARTPrintF (char *message) {
                                    707 ;	-----------------------------------------
                                    708 ;	 function UARTPrintF
                                    709 ;	-----------------------------------------
      00026C                        710 _UARTPrintF:
                                    711 ;	se8r01.c: 171: char *ch = message;
      00026C 16 03            [ 2]  712 	ldw	y, (0x03, sp)
                                    713 ;	se8r01.c: 172: while (*ch) {
      00026E                        714 00104$:
      00026E 90 F6            [ 1]  715 	ld	a, (y)
      000270 4D               [ 1]  716 	tnz	a
      000271 27 0F            [ 1]  717 	jreq	00107$
                                    718 ;	se8r01.c: 173: UART1_DR = (unsigned char) *ch;     //  Put the next character into the data transmission register.
      000273 AE 52 31         [ 2]  719 	ldw	x, #0x5231
      000276 F7               [ 1]  720 	ld	(x), a
                                    721 ;	se8r01.c: 174: while ((UART1_SR & SR_TXE) == 0);   //  Wait for transmission to complete.
      000277                        722 00101$:
      000277 AE 52 30         [ 2]  723 	ldw	x, #0x5230
      00027A F6               [ 1]  724 	ld	a, (x)
      00027B 48               [ 1]  725 	sll	a
      00027C 24 F9            [ 1]  726 	jrnc	00101$
                                    727 ;	se8r01.c: 175: ch++;                               //  Grab the next character.
      00027E 90 5C            [ 2]  728 	incw	y
      000280 20 EC            [ 2]  729 	jra	00104$
      000282                        730 00107$:
      000282 81               [ 4]  731 	ret
                                    732 ;	se8r01.c: 178: void print_UCHAR_hex (unsigned char buffer) {
                                    733 ;	-----------------------------------------
                                    734 ;	 function print_UCHAR_hex
                                    735 ;	-----------------------------------------
      000283                        736 _print_UCHAR_hex:
      000283 52 0C            [ 2]  737 	sub	sp, #12
                                    738 ;	se8r01.c: 181: a = (buffer >> 4);
      000285 7B 0F            [ 1]  739 	ld	a, (0x0f, sp)
      000287 4E               [ 1]  740 	swap	a
      000288 A4 0F            [ 1]  741 	and	a, #0x0f
      00028A 5F               [ 1]  742 	clrw	x
      00028B 97               [ 1]  743 	ld	xl, a
                                    744 ;	se8r01.c: 182: if (a > 9)
      00028C A3 00 09         [ 2]  745 	cpw	x, #0x0009
      00028F 2D 07            [ 1]  746 	jrsle	00102$
                                    747 ;	se8r01.c: 183: a = a + 'a' - 10;
      000291 1C 00 57         [ 2]  748 	addw	x, #0x0057
      000294 1F 0B            [ 2]  749 	ldw	(0x0b, sp), x
      000296 20 05            [ 2]  750 	jra	00103$
      000298                        751 00102$:
                                    752 ;	se8r01.c: 185: a += '0'; 
      000298 1C 00 30         [ 2]  753 	addw	x, #0x0030
      00029B 1F 0B            [ 2]  754 	ldw	(0x0b, sp), x
      00029D                        755 00103$:
                                    756 ;	se8r01.c: 186: b = buffer & 0x0f;
      00029D 7B 0F            [ 1]  757 	ld	a, (0x0f, sp)
      00029F A4 0F            [ 1]  758 	and	a, #0x0f
      0002A1 5F               [ 1]  759 	clrw	x
      0002A2 97               [ 1]  760 	ld	xl, a
                                    761 ;	se8r01.c: 187: if (b > 9)
      0002A3 A3 00 09         [ 2]  762 	cpw	x, #0x0009
      0002A6 2D 07            [ 1]  763 	jrsle	00105$
                                    764 ;	se8r01.c: 188: b = b + 'a' - 10;
      0002A8 1C 00 57         [ 2]  765 	addw	x, #0x0057
      0002AB 1F 09            [ 2]  766 	ldw	(0x09, sp), x
      0002AD 20 05            [ 2]  767 	jra	00106$
      0002AF                        768 00105$:
                                    769 ;	se8r01.c: 190: b += '0'; 
      0002AF 1C 00 30         [ 2]  770 	addw	x, #0x0030
      0002B2 1F 09            [ 2]  771 	ldw	(0x09, sp), x
      0002B4                        772 00106$:
                                    773 ;	se8r01.c: 191: message[0] = a;
      0002B4 90 96            [ 1]  774 	ldw	y, sp
      0002B6 90 5C            [ 2]  775 	incw	y
      0002B8 7B 0C            [ 1]  776 	ld	a, (0x0c, sp)
      0002BA 90 F7            [ 1]  777 	ld	(y), a
                                    778 ;	se8r01.c: 192: message[1] = b;
      0002BC 93               [ 1]  779 	ldw	x, y
      0002BD 5C               [ 2]  780 	incw	x
      0002BE 7B 0A            [ 1]  781 	ld	a, (0x0a, sp)
      0002C0 F7               [ 1]  782 	ld	(x), a
                                    783 ;	se8r01.c: 193: message[2] = 0;
      0002C1 93               [ 1]  784 	ldw	x, y
      0002C2 5C               [ 2]  785 	incw	x
      0002C3 5C               [ 2]  786 	incw	x
      0002C4 7F               [ 1]  787 	clr	(x)
                                    788 ;	se8r01.c: 194: UARTPrintF (message);
      0002C5 90 89            [ 2]  789 	pushw	y
      0002C7 CDr02r6C         [ 4]  790 	call	_UARTPrintF
      0002CA 5B 02            [ 2]  791 	addw	sp, #2
      0002CC 5B 0C            [ 2]  792 	addw	sp, #12
      0002CE 81               [ 4]  793 	ret
                                    794 ;	se8r01.c: 196: unsigned char i2c_read_register (UCHAR addr, UCHAR rg) {
                                    795 ;	-----------------------------------------
                                    796 ;	 function i2c_read_register
                                    797 ;	-----------------------------------------
      0002CF                        798 _i2c_read_register:
      0002CF 52 02            [ 2]  799 	sub	sp, #2
                                    800 ;	se8r01.c: 199: i2c_set_start_ack ();
      0002D1 CDr02r5E         [ 4]  801 	call	_i2c_set_start_ack
                                    802 ;	se8r01.c: 200: i2c_send_address (addr, I2C_WRITE);
      0002D4 4B 00            [ 1]  803 	push	#0x00
      0002D6 7B 06            [ 1]  804 	ld	a, (0x06, sp)
      0002D8 88               [ 1]  805 	push	a
      0002D9 CDr02r1C         [ 4]  806 	call	_i2c_send_address
      0002DC 5B 02            [ 2]  807 	addw	sp, #2
                                    808 ;	se8r01.c: 201: i2c_send_reg (rg);
      0002DE 7B 06            [ 1]  809 	ld	a, (0x06, sp)
      0002E0 88               [ 1]  810 	push	a
      0002E1 CDr01rFA         [ 4]  811 	call	_i2c_send_reg
      0002E4 84               [ 1]  812 	pop	a
                                    813 ;	se8r01.c: 202: i2c_set_start_ack ();
      0002E5 CDr02r5E         [ 4]  814 	call	_i2c_set_start_ack
                                    815 ;	se8r01.c: 203: i2c_send_address (addr, I2C_READ);
      0002E8 4B 01            [ 1]  816 	push	#0x01
      0002EA 7B 06            [ 1]  817 	ld	a, (0x06, sp)
      0002EC 88               [ 1]  818 	push	a
      0002ED CDr02r1C         [ 4]  819 	call	_i2c_send_address
      0002F0 5B 02            [ 2]  820 	addw	sp, #2
                                    821 ;	se8r01.c: 204: reg = I2C_SR1;
      0002F2 AE 52 17         [ 2]  822 	ldw	x, #0x5217
      0002F5 F6               [ 1]  823 	ld	a, (x)
      0002F6 6B 02            [ 1]  824 	ld	(0x02, sp), a
                                    825 ;	se8r01.c: 205: reg = I2C_SR3;
      0002F8 AE 52 19         [ 2]  826 	ldw	x, #0x5219
      0002FB F6               [ 1]  827 	ld	a, (x)
      0002FC 6B 02            [ 1]  828 	ld	(0x02, sp), a
                                    829 ;	se8r01.c: 206: i2c_set_nak ();
      0002FE CDr01rEA         [ 4]  830 	call	_i2c_set_nak
                                    831 ;	se8r01.c: 207: i2c_set_stop ();
      000301 CDr01rF2         [ 4]  832 	call	_i2c_set_stop
                                    833 ;	se8r01.c: 208: i2c_read (&x);
      000304 96               [ 1]  834 	ldw	x, sp
      000305 5C               [ 2]  835 	incw	x
      000306 89               [ 2]  836 	pushw	x
      000307 CDr01rD9         [ 4]  837 	call	_i2c_read
      00030A 5B 02            [ 2]  838 	addw	sp, #2
                                    839 ;	se8r01.c: 209: return (x);
      00030C 7B 01            [ 1]  840 	ld	a, (0x01, sp)
      00030E 5B 02            [ 2]  841 	addw	sp, #2
      000310 81               [ 4]  842 	ret
                                    843 ;	se8r01.c: 212: void InitializeI2C (void) {
                                    844 ;	-----------------------------------------
                                    845 ;	 function InitializeI2C
                                    846 ;	-----------------------------------------
      000311                        847 _InitializeI2C:
                                    848 ;	se8r01.c: 213: I2C_CR1 = 0;   //  Disable I2C before configuration starts. PE bit is bit 0
      000311 AE 52 10         [ 2]  849 	ldw	x, #0x5210
      000314 7F               [ 1]  850 	clr	(x)
                                    851 ;	se8r01.c: 217: I2C_FREQR = 16;                     //  Set the internal clock frequency (MHz).
      000315 AE 52 12         [ 2]  852 	ldw	x, #0x5212
      000318 A6 10            [ 1]  853 	ld	a, #0x10
      00031A F7               [ 1]  854 	ld	(x), a
                                    855 ;	se8r01.c: 218: UNSET (I2C_CCRH, I2C_FS);           //  I2C running is standard mode.
      00031B 72 17 52 1C      [ 1]  856 	bres	0x521c, #7
                                    857 ;	se8r01.c: 219: I2C_CCRL = 0x10;                    //  SCL clock speed is 500 kHz.
      00031F AE 52 1B         [ 2]  858 	ldw	x, #0x521b
      000322 A6 10            [ 1]  859 	ld	a, #0x10
      000324 F7               [ 1]  860 	ld	(x), a
                                    861 ;	se8r01.c: 220: I2C_CCRH &= 0xf0;	// Clears lower 4 bits "CCR"
      000325 AE 52 1C         [ 2]  862 	ldw	x, #0x521c
      000328 F6               [ 1]  863 	ld	a, (x)
      000329 A4 F0            [ 1]  864 	and	a, #0xf0
      00032B F7               [ 1]  865 	ld	(x), a
                                    866 ;	se8r01.c: 224: UNSET (I2C_OARH, I2C_ADDMODE);      //  7 bit address mode.
      00032C 72 17 52 14      [ 1]  867 	bres	0x5214, #7
                                    868 ;	se8r01.c: 225: SET (I2C_OARH, I2C_ADDCONF);        //  Docs say this must always be 1.
      000330 AE 52 14         [ 2]  869 	ldw	x, #0x5214
      000333 F6               [ 1]  870 	ld	a, (x)
      000334 AA 40            [ 1]  871 	or	a, #0x40
      000336 F7               [ 1]  872 	ld	(x), a
                                    873 ;	se8r01.c: 229: I2C_TRISER = 17;
      000337 AE 52 1D         [ 2]  874 	ldw	x, #0x521d
      00033A A6 11            [ 1]  875 	ld	a, #0x11
      00033C F7               [ 1]  876 	ld	(x), a
                                    877 ;	se8r01.c: 237: I2C_CR1 = I2C_PE;	// Enables port
      00033D AE 52 10         [ 2]  878 	ldw	x, #0x5210
      000340 A6 01            [ 1]  879 	ld	a, #0x01
      000342 F7               [ 1]  880 	ld	(x), a
      000343 81               [ 4]  881 	ret
                                    882 ;	se8r01.c: 243: void InitializeUART() {
                                    883 ;	-----------------------------------------
                                    884 ;	 function InitializeUART
                                    885 ;	-----------------------------------------
      000344                        886 _InitializeUART:
                                    887 ;	se8r01.c: 253: UART1_CR1 = 0;
      000344 AE 52 34         [ 2]  888 	ldw	x, #0x5234
      000347 7F               [ 1]  889 	clr	(x)
                                    890 ;	se8r01.c: 254: UART1_CR2 = 0;
      000348 AE 52 35         [ 2]  891 	ldw	x, #0x5235
      00034B 7F               [ 1]  892 	clr	(x)
                                    893 ;	se8r01.c: 255: UART1_CR4 = 0;
      00034C AE 52 37         [ 2]  894 	ldw	x, #0x5237
      00034F 7F               [ 1]  895 	clr	(x)
                                    896 ;	se8r01.c: 256: UART1_CR3 = 0;
      000350 AE 52 36         [ 2]  897 	ldw	x, #0x5236
      000353 7F               [ 1]  898 	clr	(x)
                                    899 ;	se8r01.c: 257: UART1_CR5 = 0;
      000354 AE 52 38         [ 2]  900 	ldw	x, #0x5238
      000357 7F               [ 1]  901 	clr	(x)
                                    902 ;	se8r01.c: 258: UART1_GTR = 0;
      000358 AE 52 39         [ 2]  903 	ldw	x, #0x5239
      00035B 7F               [ 1]  904 	clr	(x)
                                    905 ;	se8r01.c: 259: UART1_PSCR = 0;
      00035C AE 52 3A         [ 2]  906 	ldw	x, #0x523a
      00035F 7F               [ 1]  907 	clr	(x)
                                    908 ;	se8r01.c: 263: UNSET (UART1_CR1, CR1_M);        //  8 Data bits.
      000360 AE 52 34         [ 2]  909 	ldw	x, #0x5234
      000363 F6               [ 1]  910 	ld	a, (x)
      000364 A4 EF            [ 1]  911 	and	a, #0xef
      000366 F7               [ 1]  912 	ld	(x), a
                                    913 ;	se8r01.c: 264: UNSET (UART1_CR1, CR1_PCEN);     //  Disable parity.
      000367 AE 52 34         [ 2]  914 	ldw	x, #0x5234
      00036A F6               [ 1]  915 	ld	a, (x)
      00036B A4 FB            [ 1]  916 	and	a, #0xfb
      00036D F7               [ 1]  917 	ld	(x), a
                                    918 ;	se8r01.c: 265: UNSET (UART1_CR3, CR3_STOPH);    //  1 stop bit.
      00036E AE 52 36         [ 2]  919 	ldw	x, #0x5236
      000371 F6               [ 1]  920 	ld	a, (x)
      000372 A4 DF            [ 1]  921 	and	a, #0xdf
      000374 F7               [ 1]  922 	ld	(x), a
                                    923 ;	se8r01.c: 266: UNSET (UART1_CR3, CR3_STOPL);    //  1 stop bit.
      000375 AE 52 36         [ 2]  924 	ldw	x, #0x5236
      000378 F6               [ 1]  925 	ld	a, (x)
      000379 A4 EF            [ 1]  926 	and	a, #0xef
      00037B F7               [ 1]  927 	ld	(x), a
                                    928 ;	se8r01.c: 267: UART1_BRR2 = 0x0a;      //  Set the baud rate registers to 115200 baud
      00037C AE 52 33         [ 2]  929 	ldw	x, #0x5233
      00037F A6 0A            [ 1]  930 	ld	a, #0x0a
      000381 F7               [ 1]  931 	ld	(x), a
                                    932 ;	se8r01.c: 268: UART1_BRR1 = 0x08;      //  based upon a 16 MHz system clock.
      000382 AE 52 32         [ 2]  933 	ldw	x, #0x5232
      000385 A6 08            [ 1]  934 	ld	a, #0x08
      000387 F7               [ 1]  935 	ld	(x), a
                                    936 ;	se8r01.c: 272: UNSET (UART1_CR2, CR2_TEN);      //  Disable transmit.
      000388 AE 52 35         [ 2]  937 	ldw	x, #0x5235
      00038B F6               [ 1]  938 	ld	a, (x)
      00038C A4 F7            [ 1]  939 	and	a, #0xf7
      00038E F7               [ 1]  940 	ld	(x), a
                                    941 ;	se8r01.c: 273: UNSET (UART1_CR2, CR2_REN);      //  Disable receive.
      00038F AE 52 35         [ 2]  942 	ldw	x, #0x5235
      000392 F6               [ 1]  943 	ld	a, (x)
      000393 A4 FB            [ 1]  944 	and	a, #0xfb
      000395 F7               [ 1]  945 	ld	(x), a
                                    946 ;	se8r01.c: 277: SET (UART1_CR3, CR3_CPOL);
      000396 AE 52 36         [ 2]  947 	ldw	x, #0x5236
      000399 F6               [ 1]  948 	ld	a, (x)
      00039A AA 04            [ 1]  949 	or	a, #0x04
      00039C F7               [ 1]  950 	ld	(x), a
                                    951 ;	se8r01.c: 278: SET (UART1_CR3, CR3_CPHA);
      00039D AE 52 36         [ 2]  952 	ldw	x, #0x5236
      0003A0 F6               [ 1]  953 	ld	a, (x)
      0003A1 AA 02            [ 1]  954 	or	a, #0x02
      0003A3 F7               [ 1]  955 	ld	(x), a
                                    956 ;	se8r01.c: 279: SET (UART1_CR3, CR3_LBCL);
      0003A4 72 10 52 36      [ 1]  957 	bset	0x5236, #0
                                    958 ;	se8r01.c: 283: SET (UART1_CR2, CR2_TEN);
      0003A8 AE 52 35         [ 2]  959 	ldw	x, #0x5235
      0003AB F6               [ 1]  960 	ld	a, (x)
      0003AC AA 08            [ 1]  961 	or	a, #0x08
      0003AE F7               [ 1]  962 	ld	(x), a
                                    963 ;	se8r01.c: 284: SET (UART1_CR2, CR2_REN);
      0003AF AE 52 35         [ 2]  964 	ldw	x, #0x5235
      0003B2 F6               [ 1]  965 	ld	a, (x)
      0003B3 AA 04            [ 1]  966 	or	a, #0x04
      0003B5 F7               [ 1]  967 	ld	(x), a
                                    968 ;	se8r01.c: 285: UART1_CR3 = CR3_CLKEN;
      0003B6 AE 52 36         [ 2]  969 	ldw	x, #0x5236
      0003B9 A6 08            [ 1]  970 	ld	a, #0x08
      0003BB F7               [ 1]  971 	ld	(x), a
      0003BC 81               [ 4]  972 	ret
                                    973 ;	se8r01.c: 353: void init_io(void)
                                    974 ;	-----------------------------------------
                                    975 ;	 function init_io
                                    976 ;	-----------------------------------------
      0003BD                        977 _init_io:
                                    978 ;	se8r01.c: 355: PD_DDR &= ~(1 << 3); // input mode
      0003BD AE 50 11         [ 2]  979 	ldw	x, #0x5011
      0003C0 F6               [ 1]  980 	ld	a, (x)
      0003C1 A4 F7            [ 1]  981 	and	a, #0xf7
      0003C3 F7               [ 1]  982 	ld	(x), a
                                    983 ;	se8r01.c: 356: PD_CR1 |= (1 << 3); // input with pull up 
      0003C4 AE 50 12         [ 2]  984 	ldw	x, #0x5012
      0003C7 F6               [ 1]  985 	ld	a, (x)
      0003C8 AA 08            [ 1]  986 	or	a, #0x08
      0003CA F7               [ 1]  987 	ld	(x), a
                                    988 ;	se8r01.c: 357: PD_CR2 |= (1 << 3); // interrupt enabled 
      0003CB AE 50 13         [ 2]  989 	ldw	x, #0x5013
      0003CE F6               [ 1]  990 	ld	a, (x)
      0003CF AA 08            [ 1]  991 	or	a, #0x08
      0003D1 F7               [ 1]  992 	ld	(x), a
                                    993 ;	se8r01.c: 358: PD_ODR &= ~(1 << 3);
      0003D2 AE 50 0F         [ 2]  994 	ldw	x, #0x500f
      0003D5 F6               [ 1]  995 	ld	a, (x)
      0003D6 A4 F7            [ 1]  996 	and	a, #0xf7
      0003D8 F7               [ 1]  997 	ld	(x), a
                                    998 ;	se8r01.c: 361: PC_ODR &= ~(1 << CE);
      0003D9 AE 50 0A         [ 2]  999 	ldw	x, #0x500a
      0003DC F6               [ 1] 1000 	ld	a, (x)
      0003DD A4 EF            [ 1] 1001 	and	a, #0xef
      0003DF F7               [ 1] 1002 	ld	(x), a
                                   1003 ;	se8r01.c: 363: PC_ODR |= (1 << CSN);
      0003E0 AE 50 0A         [ 2] 1004 	ldw	x, #0x500a
      0003E3 F6               [ 1] 1005 	ld	a, (x)
      0003E4 AA 08            [ 1] 1006 	or	a, #0x08
      0003E6 F7               [ 1] 1007 	ld	(x), a
      0003E7 81               [ 4] 1008 	ret
                                   1009 ;	se8r01.c: 369: void rf_switch_bank(unsigned char bankindex)
                                   1010 ;	-----------------------------------------
                                   1011 ;	 function rf_switch_bank
                                   1012 ;	-----------------------------------------
      0003E8                       1013 _rf_switch_bank:
      0003E8 88               [ 1] 1014 	push	a
                                   1015 ;	se8r01.c: 372: temp1 = bankindex;
      0003E9 7B 04            [ 1] 1016 	ld	a, (0x04, sp)
      0003EB 6B 01            [ 1] 1017 	ld	(0x01, sp), a
                                   1018 ;	se8r01.c: 374: temp0 = write_spi(iRF_BANK0_STATUS);
      0003ED 4B 07            [ 1] 1019 	push	#0x07
      0003EF CDr00r08         [ 4] 1020 	call	_write_spi
      0003F2 5B 01            [ 2] 1021 	addw	sp, #1
                                   1022 ;	se8r01.c: 376: if((temp0&0x80)!=temp1)
      0003F4 A4 80            [ 1] 1023 	and	a, #0x80
      0003F6 11 01            [ 1] 1024 	cp	a, (0x01, sp)
      0003F8 27 09            [ 1] 1025 	jreq	00103$
                                   1026 ;	se8r01.c: 378: write_spi_reg(iRF_CMD_ACTIVATE,0x53);
      0003FA 4B 53            [ 1] 1027 	push	#0x53
      0003FC 4B 50            [ 1] 1028 	push	#0x50
      0003FE CDr00r2E         [ 4] 1029 	call	_write_spi_reg
      000401 5B 02            [ 2] 1030 	addw	sp, #2
      000403                       1031 00103$:
      000403 84               [ 1] 1032 	pop	a
      000404 81               [ 4] 1033 	ret
                                   1034 ;	se8r01.c: 385: void SE8R01_Calibration()
                                   1035 ;	-----------------------------------------
                                   1036 ;	 function SE8R01_Calibration
                                   1037 ;	-----------------------------------------
      000405                       1038 _SE8R01_Calibration:
      000405 52 0D            [ 2] 1039 	sub	sp, #13
                                   1040 ;	se8r01.c: 388: rf_switch_bank(iBANK0);
      000407 4B 00            [ 1] 1041 	push	#0x00
      000409 CDr03rE8         [ 4] 1042 	call	_rf_switch_bank
      00040C 84               [ 1] 1043 	pop	a
                                   1044 ;	se8r01.c: 389: temp[0]=0x03;
      00040D 96               [ 1] 1045 	ldw	x, sp
      00040E 5C               [ 2] 1046 	incw	x
      00040F 1F 06            [ 2] 1047 	ldw	(0x06, sp), x
      000411 1E 06            [ 2] 1048 	ldw	x, (0x06, sp)
      000413 A6 03            [ 1] 1049 	ld	a, #0x03
      000415 F7               [ 1] 1050 	ld	(x), a
                                   1051 ;	se8r01.c: 390: write_spi_buf(iRF_CMD_WRITE_REG|iRF_BANK0_CONFIG,temp, 1);
      000416 1E 06            [ 2] 1052 	ldw	x, (0x06, sp)
      000418 4B 01            [ 1] 1053 	push	#0x01
      00041A 89               [ 2] 1054 	pushw	x
      00041B 4B 20            [ 1] 1055 	push	#0x20
      00041D CDr00rA8         [ 4] 1056 	call	_write_spi_buf
      000420 5B 04            [ 2] 1057 	addw	sp, #4
                                   1058 ;	se8r01.c: 392: temp[0]=0x32;
      000422 1E 06            [ 2] 1059 	ldw	x, (0x06, sp)
      000424 A6 32            [ 1] 1060 	ld	a, #0x32
      000426 F7               [ 1] 1061 	ld	(x), a
                                   1062 ;	se8r01.c: 394: write_spi_buf(iRF_CMD_WRITE_REG|iRF_BANK0_RF_CH, temp,1);
      000427 1E 06            [ 2] 1063 	ldw	x, (0x06, sp)
      000429 4B 01            [ 1] 1064 	push	#0x01
      00042B 89               [ 2] 1065 	pushw	x
      00042C 4B 25            [ 1] 1066 	push	#0x25
      00042E CDr00rA8         [ 4] 1067 	call	_write_spi_buf
      000431 5B 04            [ 2] 1068 	addw	sp, #4
                                   1069 ;	se8r01.c: 398: if (SE8R01_DR_2M==1)
      000433 CEu00u00         [ 2] 1070 	ldw	x, _SE8R01_DR_2M+0
      000436 A3 00 01         [ 2] 1071 	cpw	x, #0x0001
      000439 26 07            [ 1] 1072 	jrne	00105$
                                   1073 ;	se8r01.c: 399: {temp[0]=0x48;}
      00043B 1E 06            [ 2] 1074 	ldw	x, (0x06, sp)
      00043D A6 48            [ 1] 1075 	ld	a, #0x48
      00043F F7               [ 1] 1076 	ld	(x), a
      000440 20 14            [ 2] 1077 	jra	00106$
      000442                       1078 00105$:
                                   1079 ;	se8r01.c: 400: else if (SE8R01_DR_1M==1)
      000442 CEu00u02         [ 2] 1080 	ldw	x, _SE8R01_DR_1M+0
      000445 A3 00 01         [ 2] 1081 	cpw	x, #0x0001
      000448 26 07            [ 1] 1082 	jrne	00102$
                                   1083 ;	se8r01.c: 401: {temp[0]=0x40;}
      00044A 1E 06            [ 2] 1084 	ldw	x, (0x06, sp)
      00044C A6 40            [ 1] 1085 	ld	a, #0x40
      00044E F7               [ 1] 1086 	ld	(x), a
      00044F 20 05            [ 2] 1087 	jra	00106$
      000451                       1088 00102$:
                                   1089 ;	se8r01.c: 403: {temp[0]=0x68;}   
      000451 1E 06            [ 2] 1090 	ldw	x, (0x06, sp)
      000453 A6 68            [ 1] 1091 	ld	a, #0x68
      000455 F7               [ 1] 1092 	ld	(x), a
      000456                       1093 00106$:
                                   1094 ;	se8r01.c: 405: write_spi_buf(iRF_CMD_WRITE_REG|iRF_BANK0_RF_SETUP,temp,1);
      000456 1E 06            [ 2] 1095 	ldw	x, (0x06, sp)
      000458 4B 01            [ 1] 1096 	push	#0x01
      00045A 89               [ 2] 1097 	pushw	x
      00045B 4B 26            [ 1] 1098 	push	#0x26
      00045D CDr00rA8         [ 4] 1099 	call	_write_spi_buf
      000460 5B 04            [ 2] 1100 	addw	sp, #4
                                   1101 ;	se8r01.c: 406: temp[0]=0x77;
      000462 1E 06            [ 2] 1102 	ldw	x, (0x06, sp)
      000464 A6 77            [ 1] 1103 	ld	a, #0x77
      000466 F7               [ 1] 1104 	ld	(x), a
                                   1105 ;	se8r01.c: 407: write_spi_buf(iRF_CMD_WRITE_REG|iRF_BANK0_PRE_GURD, temp,1);
      000467 1E 06            [ 2] 1106 	ldw	x, (0x06, sp)
      000469 4B 01            [ 1] 1107 	push	#0x01
      00046B 89               [ 2] 1108 	pushw	x
      00046C 4B 3F            [ 1] 1109 	push	#0x3f
      00046E CDr00rA8         [ 4] 1110 	call	_write_spi_buf
      000471 5B 04            [ 2] 1111 	addw	sp, #4
                                   1112 ;	se8r01.c: 409: rf_switch_bank(iBANK1);
      000473 4B 80            [ 1] 1113 	push	#0x80
      000475 CDr03rE8         [ 4] 1114 	call	_rf_switch_bank
      000478 84               [ 1] 1115 	pop	a
                                   1116 ;	se8r01.c: 410: temp[0]=0x40;
      000479 1E 06            [ 2] 1117 	ldw	x, (0x06, sp)
      00047B A6 40            [ 1] 1118 	ld	a, #0x40
      00047D F7               [ 1] 1119 	ld	(x), a
                                   1120 ;	se8r01.c: 411: temp[1]=0x00;
      00047E 1E 06            [ 2] 1121 	ldw	x, (0x06, sp)
      000480 5C               [ 2] 1122 	incw	x
      000481 1F 0A            [ 2] 1123 	ldw	(0x0a, sp), x
      000483 1E 0A            [ 2] 1124 	ldw	x, (0x0a, sp)
      000485 7F               [ 1] 1125 	clr	(x)
                                   1126 ;	se8r01.c: 412: temp[2]=0x10;
      000486 1E 06            [ 2] 1127 	ldw	x, (0x06, sp)
      000488 5C               [ 2] 1128 	incw	x
      000489 5C               [ 2] 1129 	incw	x
      00048A 1F 08            [ 2] 1130 	ldw	(0x08, sp), x
      00048C 1E 08            [ 2] 1131 	ldw	x, (0x08, sp)
      00048E A6 10            [ 1] 1132 	ld	a, #0x10
      000490 F7               [ 1] 1133 	ld	(x), a
                                   1134 ;	se8r01.c: 414: {temp[3]=0xE6;}
      000491 1E 06            [ 2] 1135 	ldw	x, (0x06, sp)
      000493 1C 00 03         [ 2] 1136 	addw	x, #0x0003
      000496 1F 0C            [ 2] 1137 	ldw	(0x0c, sp), x
                                   1138 ;	se8r01.c: 413: if (SE8R01_DR_2M==1)
      000498 CEu00u00         [ 2] 1139 	ldw	x, _SE8R01_DR_2M+0
      00049B A3 00 01         [ 2] 1140 	cpw	x, #0x0001
      00049E 26 07            [ 1] 1141 	jrne	00108$
                                   1142 ;	se8r01.c: 414: {temp[3]=0xE6;}
      0004A0 1E 0C            [ 2] 1143 	ldw	x, (0x0c, sp)
      0004A2 A6 E6            [ 1] 1144 	ld	a, #0xe6
      0004A4 F7               [ 1] 1145 	ld	(x), a
      0004A5 20 05            [ 2] 1146 	jra	00109$
      0004A7                       1147 00108$:
                                   1148 ;	se8r01.c: 416: {temp[3]=0xE4;}
      0004A7 1E 0C            [ 2] 1149 	ldw	x, (0x0c, sp)
      0004A9 A6 E4            [ 1] 1150 	ld	a, #0xe4
      0004AB F7               [ 1] 1151 	ld	(x), a
      0004AC                       1152 00109$:
                                   1153 ;	se8r01.c: 418: write_spi_buf(iRF_CMD_WRITE_REG|iRF_BANK1_PLL_CTL0, temp, 4);
      0004AC 1E 06            [ 2] 1154 	ldw	x, (0x06, sp)
      0004AE 4B 04            [ 1] 1155 	push	#0x04
      0004B0 89               [ 2] 1156 	pushw	x
      0004B1 4B 21            [ 1] 1157 	push	#0x21
      0004B3 CDr00rA8         [ 4] 1158 	call	_write_spi_buf
      0004B6 5B 04            [ 2] 1159 	addw	sp, #4
                                   1160 ;	se8r01.c: 420: temp[0]=0x20;
      0004B8 1E 06            [ 2] 1161 	ldw	x, (0x06, sp)
      0004BA A6 20            [ 1] 1162 	ld	a, #0x20
      0004BC F7               [ 1] 1163 	ld	(x), a
                                   1164 ;	se8r01.c: 421: temp[1]=0x08;
      0004BD 1E 0A            [ 2] 1165 	ldw	x, (0x0a, sp)
      0004BF A6 08            [ 1] 1166 	ld	a, #0x08
      0004C1 F7               [ 1] 1167 	ld	(x), a
                                   1168 ;	se8r01.c: 422: temp[2]=0x50;
      0004C2 1E 08            [ 2] 1169 	ldw	x, (0x08, sp)
      0004C4 A6 50            [ 1] 1170 	ld	a, #0x50
      0004C6 F7               [ 1] 1171 	ld	(x), a
                                   1172 ;	se8r01.c: 423: temp[3]=0x40;
      0004C7 1E 0C            [ 2] 1173 	ldw	x, (0x0c, sp)
      0004C9 A6 40            [ 1] 1174 	ld	a, #0x40
      0004CB F7               [ 1] 1175 	ld	(x), a
                                   1176 ;	se8r01.c: 424: temp[4]=0x50;
      0004CC 1E 06            [ 2] 1177 	ldw	x, (0x06, sp)
      0004CE A6 50            [ 1] 1178 	ld	a, #0x50
      0004D0 E7 04            [ 1] 1179 	ld	(0x0004, x), a
                                   1180 ;	se8r01.c: 425: write_spi_buf(iRF_CMD_WRITE_REG|iRF_BANK1_CAL_CTL, temp, 5);
      0004D2 1E 06            [ 2] 1181 	ldw	x, (0x06, sp)
      0004D4 4B 05            [ 1] 1182 	push	#0x05
      0004D6 89               [ 2] 1183 	pushw	x
      0004D7 4B 23            [ 1] 1184 	push	#0x23
      0004D9 CDr00rA8         [ 4] 1185 	call	_write_spi_buf
      0004DC 5B 04            [ 2] 1186 	addw	sp, #4
                                   1187 ;	se8r01.c: 427: temp[0]=0x00;
      0004DE 1E 06            [ 2] 1188 	ldw	x, (0x06, sp)
      0004E0 7F               [ 1] 1189 	clr	(x)
                                   1190 ;	se8r01.c: 428: temp[1]=0x00;
      0004E1 1E 0A            [ 2] 1191 	ldw	x, (0x0a, sp)
      0004E3 7F               [ 1] 1192 	clr	(x)
                                   1193 ;	se8r01.c: 429: if (SE8R01_DR_2M==1)
      0004E4 CEu00u00         [ 2] 1194 	ldw	x, _SE8R01_DR_2M+0
      0004E7 A3 00 01         [ 2] 1195 	cpw	x, #0x0001
      0004EA 26 07            [ 1] 1196 	jrne	00111$
                                   1197 ;	se8r01.c: 430: { temp[2]=0x1E;}
      0004EC 1E 08            [ 2] 1198 	ldw	x, (0x08, sp)
      0004EE A6 1E            [ 1] 1199 	ld	a, #0x1e
      0004F0 F7               [ 1] 1200 	ld	(x), a
      0004F1 20 05            [ 2] 1201 	jra	00112$
      0004F3                       1202 00111$:
                                   1203 ;	se8r01.c: 432: { temp[2]=0x1F;}
      0004F3 1E 08            [ 2] 1204 	ldw	x, (0x08, sp)
      0004F5 A6 1F            [ 1] 1205 	ld	a, #0x1f
      0004F7 F7               [ 1] 1206 	ld	(x), a
      0004F8                       1207 00112$:
                                   1208 ;	se8r01.c: 434: write_spi_buf(iRF_CMD_WRITE_REG|iRF_BANK1_IF_FREQ, temp, 3);
      0004F8 1E 06            [ 2] 1209 	ldw	x, (0x06, sp)
      0004FA 4B 03            [ 1] 1210 	push	#0x03
      0004FC 89               [ 2] 1211 	pushw	x
      0004FD 4B 2A            [ 1] 1212 	push	#0x2a
      0004FF CDr00rA8         [ 4] 1213 	call	_write_spi_buf
      000502 5B 04            [ 2] 1214 	addw	sp, #4
                                   1215 ;	se8r01.c: 436: if (SE8R01_DR_2M==1)
      000504 CEu00u00         [ 2] 1216 	ldw	x, _SE8R01_DR_2M+0
      000507 A3 00 01         [ 2] 1217 	cpw	x, #0x0001
      00050A 26 07            [ 1] 1218 	jrne	00114$
                                   1219 ;	se8r01.c: 437: { temp[0]=0x29;}
      00050C 1E 06            [ 2] 1220 	ldw	x, (0x06, sp)
      00050E A6 29            [ 1] 1221 	ld	a, #0x29
      000510 F7               [ 1] 1222 	ld	(x), a
      000511 20 05            [ 2] 1223 	jra	00115$
      000513                       1224 00114$:
                                   1225 ;	se8r01.c: 439: { temp[0]=0x14;}
      000513 1E 06            [ 2] 1226 	ldw	x, (0x06, sp)
      000515 A6 14            [ 1] 1227 	ld	a, #0x14
      000517 F7               [ 1] 1228 	ld	(x), a
      000518                       1229 00115$:
                                   1230 ;	se8r01.c: 441: write_spi_buf(iRF_CMD_WRITE_REG|iRF_BANK1_FDEV, temp, 1);
      000518 1E 06            [ 2] 1231 	ldw	x, (0x06, sp)
      00051A 4B 01            [ 1] 1232 	push	#0x01
      00051C 89               [ 2] 1233 	pushw	x
      00051D 4B 2C            [ 1] 1234 	push	#0x2c
      00051F CDr00rA8         [ 4] 1235 	call	_write_spi_buf
      000522 5B 04            [ 2] 1236 	addw	sp, #4
                                   1237 ;	se8r01.c: 443: temp[0]=0x00;
      000524 1E 06            [ 2] 1238 	ldw	x, (0x06, sp)
      000526 7F               [ 1] 1239 	clr	(x)
                                   1240 ;	se8r01.c: 444: write_spi_buf(iRF_CMD_WRITE_REG|iRF_BANK1_DAC_CAL_LOW,temp,1);
      000527 1E 06            [ 2] 1241 	ldw	x, (0x06, sp)
      000529 4B 01            [ 1] 1242 	push	#0x01
      00052B 89               [ 2] 1243 	pushw	x
      00052C 4B 37            [ 1] 1244 	push	#0x37
      00052E CDr00rA8         [ 4] 1245 	call	_write_spi_buf
      000531 5B 04            [ 2] 1246 	addw	sp, #4
                                   1247 ;	se8r01.c: 446: temp[0]=0x7F;
      000533 1E 06            [ 2] 1248 	ldw	x, (0x06, sp)
      000535 A6 7F            [ 1] 1249 	ld	a, #0x7f
      000537 F7               [ 1] 1250 	ld	(x), a
                                   1251 ;	se8r01.c: 447: write_spi_buf(iRF_CMD_WRITE_REG|iRF_BANK1_DAC_CAL_HI,temp,1);
      000538 1E 06            [ 2] 1252 	ldw	x, (0x06, sp)
      00053A 4B 01            [ 1] 1253 	push	#0x01
      00053C 89               [ 2] 1254 	pushw	x
      00053D 4B 38            [ 1] 1255 	push	#0x38
      00053F CDr00rA8         [ 4] 1256 	call	_write_spi_buf
      000542 5B 04            [ 2] 1257 	addw	sp, #4
                                   1258 ;	se8r01.c: 449: temp[0]=0x02;
      000544 1E 06            [ 2] 1259 	ldw	x, (0x06, sp)
      000546 A6 02            [ 1] 1260 	ld	a, #0x02
      000548 F7               [ 1] 1261 	ld	(x), a
                                   1262 ;	se8r01.c: 450: temp[1]=0xC1;
      000549 1E 0A            [ 2] 1263 	ldw	x, (0x0a, sp)
      00054B A6 C1            [ 1] 1264 	ld	a, #0xc1
      00054D F7               [ 1] 1265 	ld	(x), a
                                   1266 ;	se8r01.c: 451: temp[2]=0xEB;            
      00054E 1E 08            [ 2] 1267 	ldw	x, (0x08, sp)
      000550 A6 EB            [ 1] 1268 	ld	a, #0xeb
      000552 F7               [ 1] 1269 	ld	(x), a
                                   1270 ;	se8r01.c: 452: temp[3]=0x1C;
      000553 1E 0C            [ 2] 1271 	ldw	x, (0x0c, sp)
      000555 A6 1C            [ 1] 1272 	ld	a, #0x1c
      000557 F7               [ 1] 1273 	ld	(x), a
                                   1274 ;	se8r01.c: 453: write_spi_buf(iRF_CMD_WRITE_REG|iRF_BANK1_AGC_GAIN, temp,4);
      000558 1E 06            [ 2] 1275 	ldw	x, (0x06, sp)
      00055A 4B 04            [ 1] 1276 	push	#0x04
      00055C 89               [ 2] 1277 	pushw	x
      00055D 4B 3D            [ 1] 1278 	push	#0x3d
      00055F CDr00rA8         [ 4] 1279 	call	_write_spi_buf
      000562 5B 04            [ 2] 1280 	addw	sp, #4
                                   1281 ;	se8r01.c: 455: temp[0]=0x97;
      000564 1E 06            [ 2] 1282 	ldw	x, (0x06, sp)
      000566 A6 97            [ 1] 1283 	ld	a, #0x97
      000568 F7               [ 1] 1284 	ld	(x), a
                                   1285 ;	se8r01.c: 456: temp[1]=0x64;
      000569 1E 0A            [ 2] 1286 	ldw	x, (0x0a, sp)
      00056B A6 64            [ 1] 1287 	ld	a, #0x64
      00056D F7               [ 1] 1288 	ld	(x), a
                                   1289 ;	se8r01.c: 457: temp[2]=0x00;
      00056E 1E 08            [ 2] 1290 	ldw	x, (0x08, sp)
      000570 7F               [ 1] 1291 	clr	(x)
                                   1292 ;	se8r01.c: 458: temp[3]=0x81;
      000571 1E 0C            [ 2] 1293 	ldw	x, (0x0c, sp)
      000573 A6 81            [ 1] 1294 	ld	a, #0x81
      000575 F7               [ 1] 1295 	ld	(x), a
                                   1296 ;	se8r01.c: 459: write_spi_buf(iRF_CMD_WRITE_REG|iRF_BANK1_RF_IVGEN, temp, 4);
      000576 1E 06            [ 2] 1297 	ldw	x, (0x06, sp)
      000578 4B 04            [ 1] 1298 	push	#0x04
      00057A 89               [ 2] 1299 	pushw	x
      00057B 4B 3E            [ 1] 1300 	push	#0x3e
      00057D CDr00rA8         [ 4] 1301 	call	_write_spi_buf
      000580 5B 04            [ 2] 1302 	addw	sp, #4
                                   1303 ;	se8r01.c: 460: rf_switch_bank(iBANK0);
      000582 4B 00            [ 1] 1304 	push	#0x00
      000584 CDr03rE8         [ 4] 1305 	call	_rf_switch_bank
      000587 84               [ 1] 1306 	pop	a
                                   1307 ;	se8r01.c: 465: delayTenMicro();
      000588 CDr00r00         [ 4] 1308 	call	_delayTenMicro
                                   1309 ;	se8r01.c: 466: PC_ODR |= (1 << CE);
      00058B AE 50 0A         [ 2] 1310 	ldw	x, #0x500a
      00058E F6               [ 1] 1311 	ld	a, (x)
      00058F AA 10            [ 1] 1312 	or	a, #0x10
      000591 F7               [ 1] 1313 	ld	(x), a
                                   1314 ;	se8r01.c: 467: delayTenMicro();
      000592 CDr00r00         [ 4] 1315 	call	_delayTenMicro
                                   1316 ;	se8r01.c: 468: PC_ODR &= ~(1 << CE);
      000595 AE 50 0A         [ 2] 1317 	ldw	x, #0x500a
      000598 F6               [ 1] 1318 	ld	a, (x)
      000599 A4 EF            [ 1] 1319 	and	a, #0xef
      00059B F7               [ 1] 1320 	ld	(x), a
                                   1321 ;	se8r01.c: 469: delay(50);                            // delay 50ms waitting for calibaration.
      00059C 4B 32            [ 1] 1322 	push	#0x32
      00059E 4B 00            [ 1] 1323 	push	#0x00
      0005A0 CDr01r8E         [ 4] 1324 	call	_delay
      0005A3 5B 02            [ 2] 1325 	addw	sp, #2
                                   1326 ;	se8r01.c: 474: delayTenMicro();
      0005A5 CDr00r00         [ 4] 1327 	call	_delayTenMicro
                                   1328 ;	se8r01.c: 475: PC_ODR |= (1 << CE);
      0005A8 AE 50 0A         [ 2] 1329 	ldw	x, #0x500a
      0005AB F6               [ 1] 1330 	ld	a, (x)
      0005AC AA 10            [ 1] 1331 	or	a, #0x10
      0005AE F7               [ 1] 1332 	ld	(x), a
                                   1333 ;	se8r01.c: 476: delayTenMicro();
      0005AF CDr00r00         [ 4] 1334 	call	_delayTenMicro
                                   1335 ;	se8r01.c: 477: PC_ODR &= ~(1 << CE);
      0005B2 AE 50 0A         [ 2] 1336 	ldw	x, #0x500a
      0005B5 F6               [ 1] 1337 	ld	a, (x)
      0005B6 A4 EF            [ 1] 1338 	and	a, #0xef
      0005B8 F7               [ 1] 1339 	ld	(x), a
                                   1340 ;	se8r01.c: 478: delay(50);                            // delay 50ms waitting for calibaration.
      0005B9 4B 32            [ 1] 1341 	push	#0x32
      0005BB 4B 00            [ 1] 1342 	push	#0x00
      0005BD CDr01r8E         [ 4] 1343 	call	_delay
      0005C0 5B 02            [ 2] 1344 	addw	sp, #2
      0005C2 5B 0D            [ 2] 1345 	addw	sp, #13
      0005C4 81               [ 4] 1346 	ret
                                   1347 ;	se8r01.c: 482: void SE8R01_Analog_Init()           //SE8R01 初始化
                                   1348 ;	-----------------------------------------
                                   1349 ;	 function SE8R01_Analog_Init
                                   1350 ;	-----------------------------------------
      0005C5                       1351 _SE8R01_Analog_Init:
      0005C5 52 15            [ 2] 1352 	sub	sp, #21
                                   1353 ;	se8r01.c: 487: gtemp[0]=0x28;
      0005C7 AEr00r00         [ 2] 1354 	ldw	x, #_gtemp+0
      0005CA 1F 0E            [ 2] 1355 	ldw	(0x0e, sp), x
      0005CC 1E 0E            [ 2] 1356 	ldw	x, (0x0e, sp)
      0005CE A6 28            [ 1] 1357 	ld	a, #0x28
      0005D0 F7               [ 1] 1358 	ld	(x), a
                                   1359 ;	se8r01.c: 488: gtemp[1]=0x32;
      0005D1 1E 0E            [ 2] 1360 	ldw	x, (0x0e, sp)
      0005D3 5C               [ 2] 1361 	incw	x
      0005D4 1F 0C            [ 2] 1362 	ldw	(0x0c, sp), x
      0005D6 1E 0C            [ 2] 1363 	ldw	x, (0x0c, sp)
      0005D8 A6 32            [ 1] 1364 	ld	a, #0x32
      0005DA F7               [ 1] 1365 	ld	(x), a
                                   1366 ;	se8r01.c: 489: gtemp[2]=0x80;
      0005DB 1E 0E            [ 2] 1367 	ldw	x, (0x0e, sp)
      0005DD 5C               [ 2] 1368 	incw	x
      0005DE 5C               [ 2] 1369 	incw	x
      0005DF 1F 0A            [ 2] 1370 	ldw	(0x0a, sp), x
      0005E1 1E 0A            [ 2] 1371 	ldw	x, (0x0a, sp)
      0005E3 A6 80            [ 1] 1372 	ld	a, #0x80
      0005E5 F7               [ 1] 1373 	ld	(x), a
                                   1374 ;	se8r01.c: 490: gtemp[3]=0x90;
      0005E6 1E 0E            [ 2] 1375 	ldw	x, (0x0e, sp)
      0005E8 1C 00 03         [ 2] 1376 	addw	x, #0x0003
      0005EB 1F 08            [ 2] 1377 	ldw	(0x08, sp), x
      0005ED 1E 08            [ 2] 1378 	ldw	x, (0x08, sp)
      0005EF A6 90            [ 1] 1379 	ld	a, #0x90
      0005F1 F7               [ 1] 1380 	ld	(x), a
                                   1381 ;	se8r01.c: 491: gtemp[4]=0x00;
      0005F2 1E 0E            [ 2] 1382 	ldw	x, (0x0e, sp)
      0005F4 1C 00 04         [ 2] 1383 	addw	x, #0x0004
      0005F7 7F               [ 1] 1384 	clr	(x)
                                   1385 ;	se8r01.c: 492: write_spi_buf(iRF_CMD_WRITE_REG|iRF_BANK0_SETUP_VALUE, gtemp, 5);
      0005F8 1E 0E            [ 2] 1386 	ldw	x, (0x0e, sp)
      0005FA 4B 05            [ 1] 1387 	push	#0x05
      0005FC 89               [ 2] 1388 	pushw	x
      0005FD 4B 3E            [ 1] 1389 	push	#0x3e
      0005FF CDr00rA8         [ 4] 1390 	call	_write_spi_buf
      000602 5B 04            [ 2] 1391 	addw	sp, #4
                                   1392 ;	se8r01.c: 493: delay(2);
      000604 4B 02            [ 1] 1393 	push	#0x02
      000606 4B 00            [ 1] 1394 	push	#0x00
      000608 CDr01r8E         [ 4] 1395 	call	_delay
      00060B 5B 02            [ 2] 1396 	addw	sp, #2
                                   1397 ;	se8r01.c: 496: rf_switch_bank(iBANK1);
      00060D 4B 80            [ 1] 1398 	push	#0x80
      00060F CDr03rE8         [ 4] 1399 	call	_rf_switch_bank
      000612 84               [ 1] 1400 	pop	a
                                   1401 ;	se8r01.c: 498: temp[0]=0x40;
      000613 96               [ 1] 1402 	ldw	x, sp
      000614 5C               [ 2] 1403 	incw	x
      000615 1F 14            [ 2] 1404 	ldw	(0x14, sp), x
      000617 1E 14            [ 2] 1405 	ldw	x, (0x14, sp)
      000619 A6 40            [ 1] 1406 	ld	a, #0x40
      00061B F7               [ 1] 1407 	ld	(x), a
                                   1408 ;	se8r01.c: 499: temp[1]=0x01;               
      00061C 1E 14            [ 2] 1409 	ldw	x, (0x14, sp)
      00061E 5C               [ 2] 1410 	incw	x
      00061F 1F 12            [ 2] 1411 	ldw	(0x12, sp), x
      000621 1E 12            [ 2] 1412 	ldw	x, (0x12, sp)
      000623 A6 01            [ 1] 1413 	ld	a, #0x01
      000625 F7               [ 1] 1414 	ld	(x), a
                                   1415 ;	se8r01.c: 500: temp[2]=0x30;               
      000626 1E 14            [ 2] 1416 	ldw	x, (0x14, sp)
      000628 5C               [ 2] 1417 	incw	x
      000629 5C               [ 2] 1418 	incw	x
      00062A 1F 10            [ 2] 1419 	ldw	(0x10, sp), x
      00062C 1E 10            [ 2] 1420 	ldw	x, (0x10, sp)
      00062E A6 30            [ 1] 1421 	ld	a, #0x30
      000630 F7               [ 1] 1422 	ld	(x), a
                                   1423 ;	se8r01.c: 502: { temp[3]=0xE2; }              
      000631 1E 14            [ 2] 1424 	ldw	x, (0x14, sp)
      000633 1C 00 03         [ 2] 1425 	addw	x, #0x0003
      000636 1F 06            [ 2] 1426 	ldw	(0x06, sp), x
                                   1427 ;	se8r01.c: 501: if (SE8R01_DR_2M==1)
      000638 CEu00u00         [ 2] 1428 	ldw	x, _SE8R01_DR_2M+0
      00063B A3 00 01         [ 2] 1429 	cpw	x, #0x0001
      00063E 26 07            [ 1] 1430 	jrne	00102$
                                   1431 ;	se8r01.c: 502: { temp[3]=0xE2; }              
      000640 1E 06            [ 2] 1432 	ldw	x, (0x06, sp)
      000642 A6 E2            [ 1] 1433 	ld	a, #0xe2
      000644 F7               [ 1] 1434 	ld	(x), a
      000645 20 05            [ 2] 1435 	jra	00103$
      000647                       1436 00102$:
                                   1437 ;	se8r01.c: 504: { temp[3]=0xE0;}
      000647 1E 06            [ 2] 1438 	ldw	x, (0x06, sp)
      000649 A6 E0            [ 1] 1439 	ld	a, #0xe0
      00064B F7               [ 1] 1440 	ld	(x), a
      00064C                       1441 00103$:
                                   1442 ;	se8r01.c: 506: write_spi_buf(iRF_CMD_WRITE_REG|iRF_BANK1_PLL_CTL0, temp,4);
      00064C 1E 14            [ 2] 1443 	ldw	x, (0x14, sp)
      00064E 4B 04            [ 1] 1444 	push	#0x04
      000650 89               [ 2] 1445 	pushw	x
      000651 4B 21            [ 1] 1446 	push	#0x21
      000653 CDr00rA8         [ 4] 1447 	call	_write_spi_buf
      000656 5B 04            [ 2] 1448 	addw	sp, #4
                                   1449 ;	se8r01.c: 508: temp[0]=0x29;
      000658 1E 14            [ 2] 1450 	ldw	x, (0x14, sp)
      00065A A6 29            [ 1] 1451 	ld	a, #0x29
      00065C F7               [ 1] 1452 	ld	(x), a
                                   1453 ;	se8r01.c: 509: temp[1]=0x89;
      00065D 1E 12            [ 2] 1454 	ldw	x, (0x12, sp)
      00065F A6 89            [ 1] 1455 	ld	a, #0x89
      000661 F7               [ 1] 1456 	ld	(x), a
                                   1457 ;	se8r01.c: 510: temp[2]=0x55;                     
      000662 1E 10            [ 2] 1458 	ldw	x, (0x10, sp)
      000664 A6 55            [ 1] 1459 	ld	a, #0x55
      000666 F7               [ 1] 1460 	ld	(x), a
                                   1461 ;	se8r01.c: 511: temp[3]=0x40;
      000667 1E 06            [ 2] 1462 	ldw	x, (0x06, sp)
      000669 A6 40            [ 1] 1463 	ld	a, #0x40
      00066B F7               [ 1] 1464 	ld	(x), a
                                   1465 ;	se8r01.c: 512: temp[4]=0x50;
      00066C 1E 14            [ 2] 1466 	ldw	x, (0x14, sp)
      00066E A6 50            [ 1] 1467 	ld	a, #0x50
      000670 E7 04            [ 1] 1468 	ld	(0x0004, x), a
                                   1469 ;	se8r01.c: 513: write_spi_buf(iRF_CMD_WRITE_REG|iRF_BANK1_CAL_CTL, temp,5);
      000672 1E 14            [ 2] 1470 	ldw	x, (0x14, sp)
      000674 4B 05            [ 1] 1471 	push	#0x05
      000676 89               [ 2] 1472 	pushw	x
      000677 4B 23            [ 1] 1473 	push	#0x23
      000679 CDr00rA8         [ 4] 1474 	call	_write_spi_buf
      00067C 5B 04            [ 2] 1475 	addw	sp, #4
                                   1476 ;	se8r01.c: 515: if (SE8R01_DR_2M==1)
      00067E CEu00u00         [ 2] 1477 	ldw	x, _SE8R01_DR_2M+0
      000681 A3 00 01         [ 2] 1478 	cpw	x, #0x0001
      000684 26 07            [ 1] 1479 	jrne	00105$
                                   1480 ;	se8r01.c: 516: { temp[0]=0x29;}
      000686 1E 14            [ 2] 1481 	ldw	x, (0x14, sp)
      000688 A6 29            [ 1] 1482 	ld	a, #0x29
      00068A F7               [ 1] 1483 	ld	(x), a
      00068B 20 05            [ 2] 1484 	jra	00106$
      00068D                       1485 00105$:
                                   1486 ;	se8r01.c: 518: { temp[0]=0x14;}
      00068D 1E 14            [ 2] 1487 	ldw	x, (0x14, sp)
      00068F A6 14            [ 1] 1488 	ld	a, #0x14
      000691 F7               [ 1] 1489 	ld	(x), a
      000692                       1490 00106$:
                                   1491 ;	se8r01.c: 520: write_spi_buf(iRF_CMD_WRITE_REG|iRF_BANK1_FDEV, temp,1);
      000692 1E 14            [ 2] 1492 	ldw	x, (0x14, sp)
      000694 4B 01            [ 1] 1493 	push	#0x01
      000696 89               [ 2] 1494 	pushw	x
      000697 4B 2C            [ 1] 1495 	push	#0x2c
      000699 CDr00rA8         [ 4] 1496 	call	_write_spi_buf
      00069C 5B 04            [ 2] 1497 	addw	sp, #4
                                   1498 ;	se8r01.c: 522: temp[0]=0x55;
      00069E 1E 14            [ 2] 1499 	ldw	x, (0x14, sp)
      0006A0 A6 55            [ 1] 1500 	ld	a, #0x55
      0006A2 F7               [ 1] 1501 	ld	(x), a
                                   1502 ;	se8r01.c: 523: temp[1]=0xC2;
      0006A3 1E 12            [ 2] 1503 	ldw	x, (0x12, sp)
      0006A5 A6 C2            [ 1] 1504 	ld	a, #0xc2
      0006A7 F7               [ 1] 1505 	ld	(x), a
                                   1506 ;	se8r01.c: 524: temp[2]=0x09;
      0006A8 1E 10            [ 2] 1507 	ldw	x, (0x10, sp)
      0006AA A6 09            [ 1] 1508 	ld	a, #0x09
      0006AC F7               [ 1] 1509 	ld	(x), a
                                   1510 ;	se8r01.c: 525: temp[3]=0xAC;  
      0006AD 1E 06            [ 2] 1511 	ldw	x, (0x06, sp)
      0006AF A6 AC            [ 1] 1512 	ld	a, #0xac
      0006B1 F7               [ 1] 1513 	ld	(x), a
                                   1514 ;	se8r01.c: 526: write_spi_buf(iRF_CMD_WRITE_REG|iRF_BANK1_RX_CTRL,temp,4);
      0006B2 1E 14            [ 2] 1515 	ldw	x, (0x14, sp)
      0006B4 4B 04            [ 1] 1516 	push	#0x04
      0006B6 89               [ 2] 1517 	pushw	x
      0006B7 4B 31            [ 1] 1518 	push	#0x31
      0006B9 CDr00rA8         [ 4] 1519 	call	_write_spi_buf
      0006BC 5B 04            [ 2] 1520 	addw	sp, #4
                                   1521 ;	se8r01.c: 528: temp[0]=0x00;
      0006BE 1E 14            [ 2] 1522 	ldw	x, (0x14, sp)
      0006C0 7F               [ 1] 1523 	clr	(x)
                                   1524 ;	se8r01.c: 529: temp[1]=0x14;
      0006C1 1E 12            [ 2] 1525 	ldw	x, (0x12, sp)
      0006C3 A6 14            [ 1] 1526 	ld	a, #0x14
      0006C5 F7               [ 1] 1527 	ld	(x), a
                                   1528 ;	se8r01.c: 530: temp[2]=0x08;   
      0006C6 1E 10            [ 2] 1529 	ldw	x, (0x10, sp)
      0006C8 A6 08            [ 1] 1530 	ld	a, #0x08
      0006CA F7               [ 1] 1531 	ld	(x), a
                                   1532 ;	se8r01.c: 531: temp[3]=0x29;
      0006CB 1E 06            [ 2] 1533 	ldw	x, (0x06, sp)
      0006CD A6 29            [ 1] 1534 	ld	a, #0x29
      0006CF F7               [ 1] 1535 	ld	(x), a
                                   1536 ;	se8r01.c: 532: write_spi_buf(iRF_CMD_WRITE_REG|iRF_BANK1_FAGC_CTRL_1, temp,4);
      0006D0 1E 14            [ 2] 1537 	ldw	x, (0x14, sp)
      0006D2 4B 04            [ 1] 1538 	push	#0x04
      0006D4 89               [ 2] 1539 	pushw	x
      0006D5 4B 33            [ 1] 1540 	push	#0x33
      0006D7 CDr00rA8         [ 4] 1541 	call	_write_spi_buf
      0006DA 5B 04            [ 2] 1542 	addw	sp, #4
                                   1543 ;	se8r01.c: 534: temp[0]=0x02;
      0006DC 1E 14            [ 2] 1544 	ldw	x, (0x14, sp)
      0006DE A6 02            [ 1] 1545 	ld	a, #0x02
      0006E0 F7               [ 1] 1546 	ld	(x), a
                                   1547 ;	se8r01.c: 535: temp[1]=0xC1;
      0006E1 1E 12            [ 2] 1548 	ldw	x, (0x12, sp)
      0006E3 A6 C1            [ 1] 1549 	ld	a, #0xc1
      0006E5 F7               [ 1] 1550 	ld	(x), a
                                   1551 ;	se8r01.c: 536: temp[2]=0xCB;  
      0006E6 1E 10            [ 2] 1552 	ldw	x, (0x10, sp)
      0006E8 A6 CB            [ 1] 1553 	ld	a, #0xcb
      0006EA F7               [ 1] 1554 	ld	(x), a
                                   1555 ;	se8r01.c: 537: temp[3]=0x1C;
      0006EB 1E 06            [ 2] 1556 	ldw	x, (0x06, sp)
      0006ED A6 1C            [ 1] 1557 	ld	a, #0x1c
      0006EF F7               [ 1] 1558 	ld	(x), a
                                   1559 ;	se8r01.c: 538: write_spi_buf(iRF_CMD_WRITE_REG|iRF_BANK1_AGC_GAIN, temp,4);
      0006F0 1E 14            [ 2] 1560 	ldw	x, (0x14, sp)
      0006F2 4B 04            [ 1] 1561 	push	#0x04
      0006F4 89               [ 2] 1562 	pushw	x
      0006F5 4B 3D            [ 1] 1563 	push	#0x3d
      0006F7 CDr00rA8         [ 4] 1564 	call	_write_spi_buf
      0006FA 5B 04            [ 2] 1565 	addw	sp, #4
                                   1566 ;	se8r01.c: 540: temp[0]=0x97;
      0006FC 1E 14            [ 2] 1567 	ldw	x, (0x14, sp)
      0006FE A6 97            [ 1] 1568 	ld	a, #0x97
      000700 F7               [ 1] 1569 	ld	(x), a
                                   1570 ;	se8r01.c: 541: temp[1]=0x64;
      000701 1E 12            [ 2] 1571 	ldw	x, (0x12, sp)
      000703 A6 64            [ 1] 1572 	ld	a, #0x64
      000705 F7               [ 1] 1573 	ld	(x), a
                                   1574 ;	se8r01.c: 542: temp[2]=0x00;
      000706 1E 10            [ 2] 1575 	ldw	x, (0x10, sp)
      000708 7F               [ 1] 1576 	clr	(x)
                                   1577 ;	se8r01.c: 543: temp[3]=0x01;
      000709 1E 06            [ 2] 1578 	ldw	x, (0x06, sp)
      00070B A6 01            [ 1] 1579 	ld	a, #0x01
      00070D F7               [ 1] 1580 	ld	(x), a
                                   1581 ;	se8r01.c: 544: write_spi_buf(iRF_CMD_WRITE_REG|iRF_BANK1_RF_IVGEN, temp,4);
      00070E 1E 14            [ 2] 1582 	ldw	x, (0x14, sp)
      000710 4B 04            [ 1] 1583 	push	#0x04
      000712 89               [ 2] 1584 	pushw	x
      000713 4B 3E            [ 1] 1585 	push	#0x3e
      000715 CDr00rA8         [ 4] 1586 	call	_write_spi_buf
      000718 5B 04            [ 2] 1587 	addw	sp, #4
                                   1588 ;	se8r01.c: 546: gtemp[0]=0x2A;
      00071A 1E 0E            [ 2] 1589 	ldw	x, (0x0e, sp)
      00071C A6 2A            [ 1] 1590 	ld	a, #0x2a
      00071E F7               [ 1] 1591 	ld	(x), a
                                   1592 ;	se8r01.c: 547: gtemp[1]=0x04;
      00071F 1E 0C            [ 2] 1593 	ldw	x, (0x0c, sp)
      000721 A6 04            [ 1] 1594 	ld	a, #0x04
      000723 F7               [ 1] 1595 	ld	(x), a
                                   1596 ;	se8r01.c: 548: gtemp[2]=0x00;
      000724 1E 0A            [ 2] 1597 	ldw	x, (0x0a, sp)
      000726 7F               [ 1] 1598 	clr	(x)
                                   1599 ;	se8r01.c: 549: gtemp[3]=0x7D;
      000727 1E 08            [ 2] 1600 	ldw	x, (0x08, sp)
      000729 A6 7D            [ 1] 1601 	ld	a, #0x7d
      00072B F7               [ 1] 1602 	ld	(x), a
                                   1603 ;	se8r01.c: 550: write_spi_buf(iRF_CMD_WRITE_REG|iRF_BANK1_TEST_PKDET, gtemp, 4);
      00072C 1E 0E            [ 2] 1604 	ldw	x, (0x0e, sp)
      00072E 4B 04            [ 1] 1605 	push	#0x04
      000730 89               [ 2] 1606 	pushw	x
      000731 4B 3F            [ 1] 1607 	push	#0x3f
      000733 CDr00rA8         [ 4] 1608 	call	_write_spi_buf
      000736 5B 04            [ 2] 1609 	addw	sp, #4
                                   1610 ;	se8r01.c: 552: rf_switch_bank(iBANK0);
      000738 4B 00            [ 1] 1611 	push	#0x00
      00073A CDr03rE8         [ 4] 1612 	call	_rf_switch_bank
      00073D 84               [ 1] 1613 	pop	a
      00073E 5B 15            [ 2] 1614 	addw	sp, #21
      000740 81               [ 4] 1615 	ret
                                   1616 ;	se8r01.c: 555: void SE8R01_Init()  
                                   1617 ;	-----------------------------------------
                                   1618 ;	 function SE8R01_Init
                                   1619 ;	-----------------------------------------
      000741                       1620 _SE8R01_Init:
      000741 52 05            [ 2] 1621 	sub	sp, #5
                                   1622 ;	se8r01.c: 558: SE8R01_Calibration();   
      000743 CDr04r05         [ 4] 1623 	call	_SE8R01_Calibration
                                   1624 ;	se8r01.c: 559: SE8R01_Analog_Init();   
      000746 CDr05rC5         [ 4] 1625 	call	_SE8R01_Analog_Init
                                   1626 ;	se8r01.c: 563: if (SE8R01_DR_2M==1)
      000749 CEu00u00         [ 2] 1627 	ldw	x, _SE8R01_DR_2M+0
      00074C A3 00 01         [ 2] 1628 	cpw	x, #0x0001
      00074F 26 07            [ 1] 1629 	jrne	00105$
                                   1630 ;	se8r01.c: 564: {  temp[0]=0b01001111; }     //2MHz,+5dbm
      000751 96               [ 1] 1631 	ldw	x, sp
      000752 5C               [ 2] 1632 	incw	x
      000753 A6 4F            [ 1] 1633 	ld	a, #0x4f
      000755 F7               [ 1] 1634 	ld	(x), a
      000756 20 14            [ 2] 1635 	jra	00106$
      000758                       1636 00105$:
                                   1637 ;	se8r01.c: 565: else if  (SE8R01_DR_1M==1)
      000758 CEu00u02         [ 2] 1638 	ldw	x, _SE8R01_DR_1M+0
      00075B A3 00 01         [ 2] 1639 	cpw	x, #0x0001
      00075E 26 07            [ 1] 1640 	jrne	00102$
                                   1641 ;	se8r01.c: 566: {  temp[0]=0b01000111;  }     //1MHz,+5dbm
      000760 96               [ 1] 1642 	ldw	x, sp
      000761 5C               [ 2] 1643 	incw	x
      000762 A6 47            [ 1] 1644 	ld	a, #0x47
      000764 F7               [ 1] 1645 	ld	(x), a
      000765 20 05            [ 2] 1646 	jra	00106$
      000767                       1647 00102$:
                                   1648 ;	se8r01.c: 568: {temp[0]=0b01101111;  }     //500K,+5dbm
      000767 96               [ 1] 1649 	ldw	x, sp
      000768 5C               [ 2] 1650 	incw	x
      000769 A6 6F            [ 1] 1651 	ld	a, #0x6f
      00076B F7               [ 1] 1652 	ld	(x), a
      00076C                       1653 00106$:
                                   1654 ;	se8r01.c: 570: write_spi_buf(iRF_CMD_WRITE_REG|iRF_BANK0_RF_SETUP,temp,1);
      00076C 96               [ 1] 1655 	ldw	x, sp
      00076D 5C               [ 2] 1656 	incw	x
      00076E 4B 01            [ 1] 1657 	push	#0x01
      000770 89               [ 2] 1658 	pushw	x
      000771 4B 26            [ 1] 1659 	push	#0x26
      000773 CDr00rA8         [ 4] 1660 	call	_write_spi_buf
      000776 5B 04            [ 2] 1661 	addw	sp, #4
                                   1662 ;	se8r01.c: 574: write_spi_reg(WRITE_REG|iRF_BANK0_EN_AA, 0b00111111);          //enable auto acc on pip 1
      000778 4B 3F            [ 1] 1663 	push	#0x3f
      00077A 4B 21            [ 1] 1664 	push	#0x21
      00077C CDr00r2E         [ 4] 1665 	call	_write_spi_reg
      00077F 5B 02            [ 2] 1666 	addw	sp, #2
                                   1667 ;	se8r01.c: 575: write_spi_reg(WRITE_REG|iRF_BANK0_EN_RXADDR, 0b00111111);      //enable pip 1
      000781 4B 3F            [ 1] 1668 	push	#0x3f
      000783 4B 22            [ 1] 1669 	push	#0x22
      000785 CDr00r2E         [ 4] 1670 	call	_write_spi_reg
      000788 5B 02            [ 2] 1671 	addw	sp, #2
                                   1672 ;	se8r01.c: 576: write_spi_reg(WRITE_REG|iRF_BANK0_SETUP_AW, 0x02);  
      00078A 4B 02            [ 1] 1673 	push	#0x02
      00078C 4B 23            [ 1] 1674 	push	#0x23
      00078E CDr00r2E         [ 4] 1675 	call	_write_spi_reg
      000791 5B 02            [ 2] 1676 	addw	sp, #2
                                   1677 ;	se8r01.c: 577: write_spi_reg(WRITE_REG|iRF_BANK0_RF_CH, 40);
      000793 4B 28            [ 1] 1678 	push	#0x28
      000795 4B 25            [ 1] 1679 	push	#0x25
      000797 CDr00r2E         [ 4] 1680 	call	_write_spi_reg
      00079A 5B 02            [ 2] 1681 	addw	sp, #2
                                   1682 ;	se8r01.c: 579: write_spi_buf(WRITE_REG + TX_ADDR, ADDRESS0, ADR_WIDTH);    	
      00079C AEr00r16         [ 2] 1683 	ldw	x, #_ADDRESS0+0
      00079F 90 93            [ 1] 1684 	ldw	y, x
      0007A1 89               [ 2] 1685 	pushw	x
      0007A2 4B 04            [ 1] 1686 	push	#0x04
      0007A4 90 89            [ 2] 1687 	pushw	y
      0007A6 4B 30            [ 1] 1688 	push	#0x30
      0007A8 CDr00rA8         [ 4] 1689 	call	_write_spi_buf
      0007AB 5B 04            [ 2] 1690 	addw	sp, #4
      0007AD 85               [ 2] 1691 	popw	x
                                   1692 ;	se8r01.c: 580: write_spi_buf(WRITE_REG + RX_ADDR_P0, ADDRESS0, ADR_WIDTH); 
      0007AE 4B 04            [ 1] 1693 	push	#0x04
      0007B0 89               [ 2] 1694 	pushw	x
      0007B1 4B 2A            [ 1] 1695 	push	#0x2a
      0007B3 CDr00rA8         [ 4] 1696 	call	_write_spi_buf
      0007B6 5B 04            [ 2] 1697 	addw	sp, #4
                                   1698 ;	se8r01.c: 581: write_spi_buf(WRITE_REG + RX_ADDR_P1, ADDRESS1, ADR_WIDTH); 
      0007B8 AEr00r12         [ 2] 1699 	ldw	x, #_ADDRESS1+0
      0007BB 4B 04            [ 1] 1700 	push	#0x04
      0007BD 89               [ 2] 1701 	pushw	x
      0007BE 4B 2B            [ 1] 1702 	push	#0x2b
      0007C0 CDr00rA8         [ 4] 1703 	call	_write_spi_buf
      0007C3 5B 04            [ 2] 1704 	addw	sp, #4
                                   1705 ;	se8r01.c: 582: write_spi_buf(WRITE_REG + RX_ADDR_P2, ADDRESS2, 1); 
      0007C5 AEr00r0E         [ 2] 1706 	ldw	x, #_ADDRESS2+0
      0007C8 4B 01            [ 1] 1707 	push	#0x01
      0007CA 89               [ 2] 1708 	pushw	x
      0007CB 4B 2C            [ 1] 1709 	push	#0x2c
      0007CD CDr00rA8         [ 4] 1710 	call	_write_spi_buf
      0007D0 5B 04            [ 2] 1711 	addw	sp, #4
                                   1712 ;	se8r01.c: 583: write_spi_buf(WRITE_REG + RX_ADDR_P3, ADDRESS3, 1); 
      0007D2 AEr00r0F         [ 2] 1713 	ldw	x, #_ADDRESS3+0
      0007D5 4B 01            [ 1] 1714 	push	#0x01
      0007D7 89               [ 2] 1715 	pushw	x
      0007D8 4B 2D            [ 1] 1716 	push	#0x2d
      0007DA CDr00rA8         [ 4] 1717 	call	_write_spi_buf
      0007DD 5B 04            [ 2] 1718 	addw	sp, #4
                                   1719 ;	se8r01.c: 584: write_spi_buf(WRITE_REG + RX_ADDR_P4, ADDRESS4, 1); 
      0007DF AEr00r10         [ 2] 1720 	ldw	x, #_ADDRESS4+0
      0007E2 4B 01            [ 1] 1721 	push	#0x01
      0007E4 89               [ 2] 1722 	pushw	x
      0007E5 4B 2E            [ 1] 1723 	push	#0x2e
      0007E7 CDr00rA8         [ 4] 1724 	call	_write_spi_buf
      0007EA 5B 04            [ 2] 1725 	addw	sp, #4
                                   1726 ;	se8r01.c: 585: write_spi_buf(WRITE_REG + RX_ADDR_P5, ADDRESS5, 1); 
      0007EC AEr00r11         [ 2] 1727 	ldw	x, #_ADDRESS5+0
      0007EF 4B 01            [ 1] 1728 	push	#0x01
      0007F1 89               [ 2] 1729 	pushw	x
      0007F2 4B 2F            [ 1] 1730 	push	#0x2f
      0007F4 CDr00rA8         [ 4] 1731 	call	_write_spi_buf
      0007F7 5B 04            [ 2] 1732 	addw	sp, #4
                                   1733 ;	se8r01.c: 586: write_spi_reg(WRITE_REG + RX_PW_P0, PLOAD_WIDTH); 
      0007F9 4B 20            [ 1] 1734 	push	#0x20
      0007FB 4B 31            [ 1] 1735 	push	#0x31
      0007FD CDr00r2E         [ 4] 1736 	call	_write_spi_reg
      000800 5B 02            [ 2] 1737 	addw	sp, #2
                                   1738 ;	se8r01.c: 587: write_spi_reg(WRITE_REG|iRF_BANK0_CONFIG, 0x3f); 
      000802 4B 3F            [ 1] 1739 	push	#0x3f
      000804 4B 20            [ 1] 1740 	push	#0x20
      000806 CDr00r2E         [ 4] 1741 	call	_write_spi_reg
      000809 5B 02            [ 2] 1742 	addw	sp, #2
                                   1743 ;	se8r01.c: 588: write_spi_reg(WRITE_REG|iRF_BANK0_DYNPD, 0b00111111);          // enable dynamic payload length data
      00080B 4B 3F            [ 1] 1744 	push	#0x3f
      00080D 4B 3C            [ 1] 1745 	push	#0x3c
      00080F CDr00r2E         [ 4] 1746 	call	_write_spi_reg
      000812 5B 02            [ 2] 1747 	addw	sp, #2
                                   1748 ;	se8r01.c: 589: write_spi_reg(WRITE_REG|iRF_BANK0_FEATURE, 0x07);        // enable dynamic paload lenght; enbale payload with ack enable w_tx_payload_noack
      000814 4B 07            [ 1] 1749 	push	#0x07
      000816 4B 3D            [ 1] 1750 	push	#0x3d
      000818 CDr00r2E         [ 4] 1751 	call	_write_spi_reg
      00081B 5B 02            [ 2] 1752 	addw	sp, #2
                                   1753 ;	se8r01.c: 593: PC_ODR |= (1 << CE);
      00081D AE 50 0A         [ 2] 1754 	ldw	x, #0x500a
      000820 F6               [ 1] 1755 	ld	a, (x)
      000821 AA 10            [ 1] 1756 	or	a, #0x10
      000823 F7               [ 1] 1757 	ld	(x), a
      000824 5B 05            [ 2] 1758 	addw	sp, #5
      000826 81               [ 4] 1759 	ret
                                   1760 ;	se8r01.c: 601: int main () {
                                   1761 ;	-----------------------------------------
                                   1762 ;	 function main
                                   1763 ;	-----------------------------------------
      000827                       1764 _main:
      000827 52 33            [ 2] 1765 	sub	sp, #51
                                   1766 ;	se8r01.c: 603: UCHAR rx_addr_p1[]  = { 0xd2, 0xf0, 0xf0, 0xf0, 0xf0 };
      000829 90 96            [ 1] 1767 	ldw	y, sp
      00082B 72 A9 00 22      [ 2] 1768 	addw	y, #34
      00082F A6 D2            [ 1] 1769 	ld	a, #0xd2
      000831 90 F7            [ 1] 1770 	ld	(y), a
      000833 93               [ 1] 1771 	ldw	x, y
      000834 5C               [ 2] 1772 	incw	x
      000835 A6 F0            [ 1] 1773 	ld	a, #0xf0
      000837 F7               [ 1] 1774 	ld	(x), a
      000838 93               [ 1] 1775 	ldw	x, y
      000839 5C               [ 2] 1776 	incw	x
      00083A 5C               [ 2] 1777 	incw	x
      00083B A6 F0            [ 1] 1778 	ld	a, #0xf0
      00083D F7               [ 1] 1779 	ld	(x), a
      00083E 93               [ 1] 1780 	ldw	x, y
      00083F A6 F0            [ 1] 1781 	ld	a, #0xf0
      000841 E7 03            [ 1] 1782 	ld	(0x0003, x), a
      000843 93               [ 1] 1783 	ldw	x, y
      000844 A6 F0            [ 1] 1784 	ld	a, #0xf0
      000846 E7 04            [ 1] 1785 	ld	(0x0004, x), a
                                   1786 ;	se8r01.c: 604: UCHAR tx_addr[]     = { 0xe1, 0xf0, 0xf0, 0xf0, 0xf0 };
      000848 90 96            [ 1] 1787 	ldw	y, sp
      00084A 72 A9 00 27      [ 2] 1788 	addw	y, #39
      00084E A6 E1            [ 1] 1789 	ld	a, #0xe1
      000850 90 F7            [ 1] 1790 	ld	(y), a
      000852 93               [ 1] 1791 	ldw	x, y
      000853 5C               [ 2] 1792 	incw	x
      000854 A6 F0            [ 1] 1793 	ld	a, #0xf0
      000856 F7               [ 1] 1794 	ld	(x), a
      000857 93               [ 1] 1795 	ldw	x, y
      000858 5C               [ 2] 1796 	incw	x
      000859 5C               [ 2] 1797 	incw	x
      00085A A6 F0            [ 1] 1798 	ld	a, #0xf0
      00085C F7               [ 1] 1799 	ld	(x), a
      00085D 93               [ 1] 1800 	ldw	x, y
      00085E A6 F0            [ 1] 1801 	ld	a, #0xf0
      000860 E7 03            [ 1] 1802 	ld	(0x0003, x), a
      000862 93               [ 1] 1803 	ldw	x, y
      000863 1C 00 04         [ 2] 1804 	addw	x, #0x0004
      000866 A6 F0            [ 1] 1805 	ld	a, #0xf0
      000868 F7               [ 1] 1806 	ld	(x), a
                                   1807 ;	se8r01.c: 608: InitializeSystemClock();
      000869 CDr01r44         [ 4] 1808 	call	_InitializeSystemClock
                                   1809 ;	se8r01.c: 609: InitializeUART();
      00086C CDr03r44         [ 4] 1810 	call	_InitializeUART
                                   1811 ;	se8r01.c: 611: InitializeSPI ();
      00086F CDr01r1C         [ 4] 1812 	call	_InitializeSPI
                                   1813 ;	se8r01.c: 614: memset (tx_payload, 0, sizeof(tx_payload));
      000872 96               [ 1] 1814 	ldw	x, sp
      000873 5C               [ 2] 1815 	incw	x
      000874 1F 32            [ 2] 1816 	ldw	(0x32, sp), x
      000876 16 32            [ 2] 1817 	ldw	y, (0x32, sp)
      000878 4B 21            [ 1] 1818 	push	#0x21
      00087A 4B 00            [ 1] 1819 	push	#0x00
      00087C 5F               [ 1] 1820 	clrw	x
      00087D 89               [ 2] 1821 	pushw	x
      00087E 90 89            [ 2] 1822 	pushw	y
      000880 CDr00r00         [ 4] 1823 	call	_memset
      000883 5B 06            [ 2] 1824 	addw	sp, #6
                                   1825 ;	se8r01.c: 617: init_io();                        // Initialize IO port
      000885 CDr03rBD         [ 4] 1826 	call	_init_io
                                   1827 ;	se8r01.c: 618: write_spi_reg(FLUSH_TX,0); // transmit -- send data 
      000888 4B 00            [ 1] 1828 	push	#0x00
      00088A 4B E1            [ 1] 1829 	push	#0xe1
      00088C CDr00r2E         [ 4] 1830 	call	_write_spi_reg
      00088F 5B 02            [ 2] 1831 	addw	sp, #2
                                   1832 ;	se8r01.c: 619: readstatus = read_spi_reg(CONFIG);
      000891 4B 00            [ 1] 1833 	push	#0x00
      000893 CDr00r6A         [ 4] 1834 	call	_read_spi_reg
      000896 5B 01            [ 2] 1835 	addw	sp, #1
                                   1836 ;	se8r01.c: 620: UARTPrintF("config = \n\r");
      000898 AEr09r20         [ 2] 1837 	ldw	x, #___str_0+0
      00089B 88               [ 1] 1838 	push	a
      00089C 89               [ 2] 1839 	pushw	x
      00089D CDr02r6C         [ 4] 1840 	call	_UARTPrintF
      0008A0 5B 02            [ 2] 1841 	addw	sp, #2
      0008A2 84               [ 1] 1842 	pop	a
                                   1843 ;	se8r01.c: 621: print_UCHAR_hex(readstatus);
      0008A3 88               [ 1] 1844 	push	a
      0008A4 CDr02r83         [ 4] 1845 	call	_print_UCHAR_hex
      0008A7 84               [ 1] 1846 	pop	a
                                   1847 ;	se8r01.c: 622: readstatus = read_spi_reg(STATUS);
      0008A8 4B 07            [ 1] 1848 	push	#0x07
      0008AA CDr00r6A         [ 4] 1849 	call	_read_spi_reg
      0008AD 5B 01            [ 2] 1850 	addw	sp, #1
                                   1851 ;	se8r01.c: 623: UARTPrintF("status = \n\r");
      0008AF AEr09r2C         [ 2] 1852 	ldw	x, #___str_1+0
      0008B2 88               [ 1] 1853 	push	a
      0008B3 89               [ 2] 1854 	pushw	x
      0008B4 CDr02r6C         [ 4] 1855 	call	_UARTPrintF
      0008B7 5B 02            [ 2] 1856 	addw	sp, #2
      0008B9 84               [ 1] 1857 	pop	a
                                   1858 ;	se8r01.c: 624: print_UCHAR_hex(readstatus);
      0008BA 88               [ 1] 1859 	push	a
      0008BB CDr02r83         [ 4] 1860 	call	_print_UCHAR_hex
      0008BE 84               [ 1] 1861 	pop	a
                                   1862 ;	se8r01.c: 626: SE8R01_Init();
      0008BF CDr07r41         [ 4] 1863 	call	_SE8R01_Init
                                   1864 ;	se8r01.c: 630: while (1) {
      0008C2                       1865 00105$:
                                   1866 ;	se8r01.c: 632: tx_payload[0] = 0xf0;
      0008C2 1E 32            [ 2] 1867 	ldw	x, (0x32, sp)
      0008C4 A6 F0            [ 1] 1868 	ld	a, #0xf0
      0008C6 F7               [ 1] 1869 	ld	(x), a
                                   1870 ;	se8r01.c: 633: tx_payload[1] = 0x01;
      0008C7 1E 32            [ 2] 1871 	ldw	x, (0x32, sp)
      0008C9 5C               [ 2] 1872 	incw	x
      0008CA A6 01            [ 1] 1873 	ld	a, #0x01
      0008CC F7               [ 1] 1874 	ld	(x), a
                                   1875 ;	se8r01.c: 634: tx_payload[2] = 0x33;
      0008CD 1E 32            [ 2] 1876 	ldw	x, (0x32, sp)
      0008CF 5C               [ 2] 1877 	incw	x
      0008D0 5C               [ 2] 1878 	incw	x
      0008D1 A6 33            [ 1] 1879 	ld	a, #0x33
      0008D3 F7               [ 1] 1880 	ld	(x), a
                                   1881 ;	se8r01.c: 635: write_spi_buf(iRF_CMD_WR_TX_PLOAD, tx_payload, 32);
      0008D4 1E 32            [ 2] 1882 	ldw	x, (0x32, sp)
      0008D6 4B 20            [ 1] 1883 	push	#0x20
      0008D8 89               [ 2] 1884 	pushw	x
      0008D9 4B A0            [ 1] 1885 	push	#0xa0
      0008DB CDr00rA8         [ 4] 1886 	call	_write_spi_buf
      0008DE 5B 04            [ 2] 1887 	addw	sp, #4
                                   1888 ;	se8r01.c: 636: write_spi_reg(WRITE_REG+STATUS, 0xff);
      0008E0 4B FF            [ 1] 1889 	push	#0xff
      0008E2 4B 27            [ 1] 1890 	push	#0x27
      0008E4 CDr00r2E         [ 4] 1891 	call	_write_spi_reg
      0008E7 5B 02            [ 2] 1892 	addw	sp, #2
                                   1893 ;	se8r01.c: 638: for (x1 = 0; x1 < 50; ++x1)
      0008E9 5F               [ 1] 1894 	clrw	x
      0008EA 1F 30            [ 2] 1895 	ldw	(0x30, sp), x
      0008EC                       1896 00114$:
      0008EC 1E 30            [ 2] 1897 	ldw	x, (0x30, sp)
      0008EE A3 00 32         [ 2] 1898 	cpw	x, #0x0032
      0008F1 2E CF            [ 1] 1899 	jrsge	00105$
                                   1900 ;	se8r01.c: 639: for (y1 = 0; y1 < 50; ++y1)
      0008F3 5F               [ 1] 1901 	clrw	x
      0008F4 1F 2E            [ 2] 1902 	ldw	(0x2e, sp), x
      0008F6                       1903 00111$:
      0008F6 1E 2E            [ 2] 1904 	ldw	x, (0x2e, sp)
      0008F8 A3 00 32         [ 2] 1905 	cpw	x, #0x0032
      0008FB 2E 19            [ 1] 1906 	jrsge	00115$
                                   1907 ;	se8r01.c: 640: for (z1 = 0; z1 < 50; ++z1)
      0008FD 5F               [ 1] 1908 	clrw	x
      0008FE 1F 2C            [ 2] 1909 	ldw	(0x2c, sp), x
      000900                       1910 00108$:
      000900 1E 2C            [ 2] 1911 	ldw	x, (0x2c, sp)
      000902 A3 00 32         [ 2] 1912 	cpw	x, #0x0032
      000905 2E 08            [ 1] 1913 	jrsge	00112$
                                   1914 ;	se8r01.c: 641: __asm__("nop");
      000907 9D               [ 1] 1915 	nop
                                   1916 ;	se8r01.c: 640: for (z1 = 0; z1 < 50; ++z1)
      000908 1E 2C            [ 2] 1917 	ldw	x, (0x2c, sp)
      00090A 5C               [ 2] 1918 	incw	x
      00090B 1F 2C            [ 2] 1919 	ldw	(0x2c, sp), x
      00090D 20 F1            [ 2] 1920 	jra	00108$
      00090F                       1921 00112$:
                                   1922 ;	se8r01.c: 639: for (y1 = 0; y1 < 50; ++y1)
      00090F 1E 2E            [ 2] 1923 	ldw	x, (0x2e, sp)
      000911 5C               [ 2] 1924 	incw	x
      000912 1F 2E            [ 2] 1925 	ldw	(0x2e, sp), x
      000914 20 E0            [ 2] 1926 	jra	00111$
      000916                       1927 00115$:
                                   1928 ;	se8r01.c: 638: for (x1 = 0; x1 < 50; ++x1)
      000916 1E 30            [ 2] 1929 	ldw	x, (0x30, sp)
      000918 5C               [ 2] 1930 	incw	x
      000919 1F 30            [ 2] 1931 	ldw	(0x30, sp), x
      00091B 20 CF            [ 2] 1932 	jra	00114$
      00091D 5B 33            [ 2] 1933 	addw	sp, #51
      00091F 81               [ 4] 1934 	ret
                                   1935 	.area CODE
      000920                       1936 ___str_0:
      000920 63 6F 6E 66 69 67 20  1937 	.ascii "config = "
             3D 20
      000929 0A                    1938 	.db 0x0A
      00092A 0D                    1939 	.db 0x0D
      00092B 00                    1940 	.db 0x00
      00092C                       1941 ___str_1:
      00092C 73 74 61 74 75 73 20  1942 	.ascii "status = "
             3D 20
      000935 0A                    1943 	.db 0x0A
      000936 0D                    1944 	.db 0x0D
      000937 00                    1945 	.db 0x00
                                   1946 	.area INITIALIZER
      000000                       1947 __xinit__SE8R01_DR_2M:
      000000 00 00                 1948 	.dw #0x0000
      000002                       1949 __xinit__SE8R01_DR_1M:
      000002 00 00                 1950 	.dw #0x0000
      000004                       1951 __xinit__SE8R01_DR_500K:
      000004 00 01                 1952 	.dw #0x0001
      000006                       1953 __xinit__pload_width_now:
      000006 00 00                 1954 	.dw #0x0000
      000008                       1955 __xinit__newdata:
      000008 00 00                 1956 	.dw #0x0000
      00000A                       1957 __xinit__signal_lv:
      00000A 00                    1958 	.db #0x00	;  0
      00000B                       1959 __xinit__pip:
      00000B 00 00                 1960 	.dw #0x0000
      00000D                       1961 __xinit__status:
      00000D 00                    1962 	.db #0x00	; 0
      00000E                       1963 __xinit__ADDRESS2:
      00000E B1                    1964 	.db #0xB1	; 177
      00000F                       1965 __xinit__ADDRESS3:
      00000F B2                    1966 	.db #0xB2	; 178
      000010                       1967 __xinit__ADDRESS4:
      000010 B3                    1968 	.db #0xB3	; 179
      000011                       1969 __xinit__ADDRESS5:
      000011 B4                    1970 	.db #0xB4	; 180
      000012                       1971 __xinit__ADDRESS1:
      000012 B0                    1972 	.db #0xB0	; 176
      000013 43                    1973 	.db #0x43	; 67	'C'
      000014 10                    1974 	.db #0x10	; 16
      000015 10                    1975 	.db #0x10	; 16
      000016                       1976 __xinit__ADDRESS0:
      000016 34                    1977 	.db #0x34	; 52	'4'
      000017 43                    1978 	.db #0x43	; 67	'C'
      000018 10                    1979 	.db #0x10	; 16
      000019 10                    1980 	.db #0x10	; 16
      00001A                       1981 __xinit__rx_buf:
      00001A 00                    1982 	.db #0x00	; 0
      00001B 00                    1983 	.db 0x00
      00001C 00                    1984 	.db 0x00
      00001D 00                    1985 	.db 0x00
      00001E 00                    1986 	.db 0x00
      00001F 00                    1987 	.db 0x00
      000020 00                    1988 	.db 0x00
      000021 00                    1989 	.db 0x00
      000022 00                    1990 	.db 0x00
      000023 00                    1991 	.db 0x00
      000024 00                    1992 	.db 0x00
      000025 00                    1993 	.db 0x00
      000026 00                    1994 	.db 0x00
      000027 00                    1995 	.db 0x00
      000028 00                    1996 	.db 0x00
      000029 00                    1997 	.db 0x00
      00002A 00                    1998 	.db 0x00
      00002B 00                    1999 	.db 0x00
      00002C 00                    2000 	.db 0x00
      00002D 00                    2001 	.db 0x00
      00002E 00                    2002 	.db 0x00
      00002F 00                    2003 	.db 0x00
      000030 00                    2004 	.db 0x00
      000031 00                    2005 	.db 0x00
      000032 00                    2006 	.db 0x00
      000033 00                    2007 	.db 0x00
      000034 00                    2008 	.db 0x00
      000035 00                    2009 	.db 0x00
      000036 00                    2010 	.db 0x00
      000037 00                    2011 	.db 0x00
      000038 00                    2012 	.db 0x00
      000039 00                    2013 	.db 0x00
      00003A                       2014 __xinit__tx_buf:
      00003A 00                    2015 	.db #0x00	; 0
      00003B 00                    2016 	.db 0x00
      00003C 00                    2017 	.db 0x00
      00003D 00                    2018 	.db 0x00
      00003E 00                    2019 	.db 0x00
      00003F 00                    2020 	.db 0x00
      000040 00                    2021 	.db 0x00
      000041 00                    2022 	.db 0x00
      000042 00                    2023 	.db 0x00
      000043 00                    2024 	.db 0x00
      000044 00                    2025 	.db 0x00
      000045 00                    2026 	.db 0x00
      000046 00                    2027 	.db 0x00
      000047 00                    2028 	.db 0x00
      000048 00                    2029 	.db 0x00
      000049 00                    2030 	.db 0x00
      00004A 00                    2031 	.db 0x00
      00004B 00                    2032 	.db 0x00
      00004C 00                    2033 	.db 0x00
      00004D 00                    2034 	.db 0x00
      00004E 00                    2035 	.db 0x00
      00004F 00                    2036 	.db 0x00
      000050 00                    2037 	.db 0x00
      000051 00                    2038 	.db 0x00
      000052 00                    2039 	.db 0x00
      000053 00                    2040 	.db 0x00
      000054 00                    2041 	.db 0x00
      000055 00                    2042 	.db 0x00
      000056 00                    2043 	.db 0x00
      000057 00                    2044 	.db 0x00
      000058 00                    2045 	.db 0x00
      000059 00                    2046 	.db 0x00
                                   2047 	.area CABS (ABS)
