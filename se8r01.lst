                                      1 ;--------------------------------------------------------
                                      2 ; File Created by SDCC : free open source ANSI-C Compiler
                                      3 ; Version 3.4.0 #8981 (Jul 11 2014) (Linux)
                                      4 ; This file was generated Wed May  3 08:56:15 2017
                                      5 ;--------------------------------------------------------
                                      6 	.module se8r01
                                      7 	.optsdcc -mstm8
                                      8 	
                                      9 ;--------------------------------------------------------
                                     10 ; Public variables in this module
                                     11 ;--------------------------------------------------------
                                     12 	.globl _main
                                     13 	.globl _SE8R01_Init
                                     14 	.globl _SE8R01_Analog_Init
                                     15 	.globl _SE8R01_Calibration
                                     16 	.globl _rf_switch_bank
                                     17 	.globl _init_io
                                     18 	.globl _InitializeUART
                                     19 	.globl _InitializeI2C
                                     20 	.globl _i2c_read_register
                                     21 	.globl _print_UCHAR_hex
                                     22 	.globl _UARTPrintF
                                     23 	.globl _i2c_set_start_ack
                                     24 	.globl _i2c_send_address
                                     25 	.globl _i2c_send_reg
                                     26 	.globl _i2c_set_stop
                                     27 	.globl _i2c_set_nak
                                     28 	.globl _i2c_read
                                     29 	.globl _delay
                                     30 	.globl _InitializeSystemClock
                                     31 	.globl _InitializeSPI
                                     32 	.globl _read_spi_buf
                                     33 	.globl _write_spi_buf
                                     34 	.globl _read_spi_reg
                                     35 	.globl _write_spi_reg
                                     36 	.globl _write_spi
                                     37 	.globl _delayTenMicro
                                     38 	.globl _tx_buf
                                     39 	.globl _rx_buf
                                     40 	.globl _ADDRESS0
                                     41 	.globl _ADDRESS1
                                     42 	.globl _ADDRESS5
                                     43 	.globl _ADDRESS4
                                     44 	.globl _ADDRESS3
                                     45 	.globl _ADDRESS2
                                     46 	.globl _status
                                     47 	.globl _pip
                                     48 	.globl _signal_lv
                                     49 	.globl _newdata
                                     50 	.globl _pload_width_now
                                     51 	.globl _SE8R01_DR_500K
                                     52 	.globl _SE8R01_DR_1M
                                     53 	.globl _SE8R01_DR_2M
                                     54 	.globl _myData_pip4
                                     55 	.globl _myData_pip5
                                     56 	.globl _gtemp
                                     57 ;--------------------------------------------------------
                                     58 ; ram data
                                     59 ;--------------------------------------------------------
                                     60 	.area DATA
      000000                         61 _gtemp::
      000000                         62 	.ds 5
      000005                         63 _myData_pip5::
      000005                         64 	.ds 5
      00000A                         65 _myData_pip4::
      00000A                         66 	.ds 5
                                     67 ;--------------------------------------------------------
                                     68 ; ram data
                                     69 ;--------------------------------------------------------
                                     70 	.area INITIALIZED
      000000                         71 _SE8R01_DR_2M::
      000000                         72 	.ds 2
      000002                         73 _SE8R01_DR_1M::
      000002                         74 	.ds 2
      000004                         75 _SE8R01_DR_500K::
      000004                         76 	.ds 2
      000006                         77 _pload_width_now::
      000006                         78 	.ds 2
      000008                         79 _newdata::
      000008                         80 	.ds 2
      00000A                         81 _signal_lv::
      00000A                         82 	.ds 1
      00000B                         83 _pip::
      00000B                         84 	.ds 2
      00000D                         85 _status::
      00000D                         86 	.ds 1
      00000E                         87 _ADDRESS2::
      00000E                         88 	.ds 1
      00000F                         89 _ADDRESS3::
      00000F                         90 	.ds 1
      000010                         91 _ADDRESS4::
      000010                         92 	.ds 1
      000011                         93 _ADDRESS5::
      000011                         94 	.ds 1
      000012                         95 _ADDRESS1::
      000012                         96 	.ds 4
      000016                         97 _ADDRESS0::
      000016                         98 	.ds 4
      00001A                         99 _rx_buf::
      00001A                        100 	.ds 32
      00003A                        101 _tx_buf::
      00003A                        102 	.ds 32
                                    103 ;--------------------------------------------------------
                                    104 ; Stack segment in internal ram 
                                    105 ;--------------------------------------------------------
                                    106 	.area	SSEG
      000000                        107 __start__stack:
      000000                        108 	.ds	1
                                    109 
                                    110 ;--------------------------------------------------------
                                    111 ; absolute external ram data
                                    112 ;--------------------------------------------------------
                                    113 	.area DABS (ABS)
                                    114 ;--------------------------------------------------------
                                    115 ; interrupt vector 
                                    116 ;--------------------------------------------------------
                                    117 	.area HOME
      000000                        118 __interrupt_vect:
      000000 82v00u00u00            119 	int s_GSINIT ;reset
      000004 82 00 00 00            120 	int 0x0000 ;trap
      000008 82 00 00 00            121 	int 0x0000 ;int0
      00000C 82 00 00 00            122 	int 0x0000 ;int1
      000010 82 00 00 00            123 	int 0x0000 ;int2
      000014 82 00 00 00            124 	int 0x0000 ;int3
      000018 82 00 00 00            125 	int 0x0000 ;int4
      00001C 82 00 00 00            126 	int 0x0000 ;int5
      000020 82 00 00 00            127 	int 0x0000 ;int6
      000024 82 00 00 00            128 	int 0x0000 ;int7
      000028 82 00 00 00            129 	int 0x0000 ;int8
      00002C 82 00 00 00            130 	int 0x0000 ;int9
      000030 82 00 00 00            131 	int 0x0000 ;int10
      000034 82 00 00 00            132 	int 0x0000 ;int11
      000038 82 00 00 00            133 	int 0x0000 ;int12
      00003C 82 00 00 00            134 	int 0x0000 ;int13
      000040 82 00 00 00            135 	int 0x0000 ;int14
      000044 82 00 00 00            136 	int 0x0000 ;int15
      000048 82 00 00 00            137 	int 0x0000 ;int16
      00004C 82 00 00 00            138 	int 0x0000 ;int17
      000050 82 00 00 00            139 	int 0x0000 ;int18
      000054 82 00 00 00            140 	int 0x0000 ;int19
      000058 82 00 00 00            141 	int 0x0000 ;int20
      00005C 82 00 00 00            142 	int 0x0000 ;int21
      000060 82 00 00 00            143 	int 0x0000 ;int22
      000064 82 00 00 00            144 	int 0x0000 ;int23
      000068 82 00 00 00            145 	int 0x0000 ;int24
      00006C 82 00 00 00            146 	int 0x0000 ;int25
      000070 82 00 00 00            147 	int 0x0000 ;int26
      000074 82 00 00 00            148 	int 0x0000 ;int27
      000078 82 00 00 00            149 	int 0x0000 ;int28
      00007C 82 00 00 00            150 	int 0x0000 ;int29
                                    151 ;--------------------------------------------------------
                                    152 ; global & static initialisations
                                    153 ;--------------------------------------------------------
                                    154 	.area HOME
                                    155 	.area GSINIT
                                    156 	.area GSFINAL
                                    157 	.area GSINIT
      000000                        158 __sdcc_gs_init_startup:
      000000                        159 __sdcc_init_data:
                                    160 ; stm8_genXINIT() start
      000000 AEr00r00         [ 2]  161 	ldw x, #l_DATA
      000003 27 07            [ 1]  162 	jreq	00002$
      000005                        163 00001$:
      000005 72 4FuFFuFF      [ 1]  164 	clr (s_DATA - 1, x)
      000009 5A               [ 2]  165 	decw x
      00000A 26 F9            [ 1]  166 	jrne	00001$
      00000C                        167 00002$:
      00000C AEr00r00         [ 2]  168 	ldw	x, #l_INITIALIZER
      00000F 27 09            [ 1]  169 	jreq	00004$
      000011                        170 00003$:
      000011 D6uFFuFF         [ 1]  171 	ld	a, (s_INITIALIZER - 1, x)
      000014 D7uFFuFF         [ 1]  172 	ld	(s_INITIALIZED - 1, x), a
      000017 5A               [ 2]  173 	decw	x
      000018 26 F7            [ 1]  174 	jrne	00003$
      00001A                        175 00004$:
                                    176 ; stm8_genXINIT() end
                                    177 	.area GSFINAL
      000000 CCr00r80         [ 2]  178 	jp	__sdcc_program_startup
                                    179 ;--------------------------------------------------------
                                    180 ; Home
                                    181 ;--------------------------------------------------------
                                    182 	.area HOME
                                    183 	.area HOME
      000080                        184 __sdcc_program_startup:
      000080 CCr08r27         [ 2]  185 	jp	_main
                                    186 ;	return from main will return to caller
                                    187 ;--------------------------------------------------------
                                    188 ; code
                                    189 ;--------------------------------------------------------
                                    190 	.area CODE
                                    191 ;	se8r01.c: 27: void delayTenMicro (void) {
                                    192 ;	-----------------------------------------
                                    193 ;	 function delayTenMicro
                                    194 ;	-----------------------------------------
      000000                        195 _delayTenMicro:
                                    196 ;	se8r01.c: 29: for (a = 0; a < 50; ++a)
      000000 A6 32            [ 1]  197 	ld	a, #0x32
      000002                        198 00104$:
                                    199 ;	se8r01.c: 30: __asm__("nop");
      000002 9D               [ 1]  200 	nop
      000003 4A               [ 1]  201 	dec	a
                                    202 ;	se8r01.c: 29: for (a = 0; a < 50; ++a)
      000004 4D               [ 1]  203 	tnz	a
      000005 26 FB            [ 1]  204 	jrne	00104$
      000007 81               [ 4]  205 	ret
                                    206 ;	se8r01.c: 32: UCHAR write_spi (UCHAR value) {
                                    207 ;	-----------------------------------------
                                    208 ;	 function write_spi
                                    209 ;	-----------------------------------------
      000008                        210 _write_spi:
                                    211 ;	se8r01.c: 34: delayTenMicro ();
      000008 CDr00r00         [ 4]  212 	call	_delayTenMicro
                                    213 ;	se8r01.c: 35: SPI_DR = value;
      00000B AE 52 04         [ 2]  214 	ldw	x, #0x5204
      00000E 7B 03            [ 1]  215 	ld	a, (0x03, sp)
      000010 F7               [ 1]  216 	ld	(x), a
                                    217 ;	se8r01.c: 36: delayTenMicro ();
      000011 CDr00r00         [ 4]  218 	call	_delayTenMicro
                                    219 ;	se8r01.c: 37: while ((SPI_SR & TXE) == 0);
      000014                        220 00101$:
      000014 AE 52 03         [ 2]  221 	ldw	x, #0x5203
      000017 F6               [ 1]  222 	ld	a, (x)
      000018 A5 02            [ 1]  223 	bcp	a, #0x02
      00001A 27 F8            [ 1]  224 	jreq	00101$
                                    225 ;	se8r01.c: 38: delayTenMicro ();
      00001C CDr00r00         [ 4]  226 	call	_delayTenMicro
                                    227 ;	se8r01.c: 39: while ((SPI_SR & RXNE) == 0);
      00001F                        228 00104$:
      00001F AE 52 03         [ 2]  229 	ldw	x, #0x5203
      000022 F6               [ 1]  230 	ld	a, (x)
      000023 44               [ 1]  231 	srl	a
      000024 24 F9            [ 1]  232 	jrnc	00104$
                                    233 ;	se8r01.c: 40: delayTenMicro ();
      000026 CDr00r00         [ 4]  234 	call	_delayTenMicro
                                    235 ;	se8r01.c: 41: ret = SPI_DR;
      000029 AE 52 04         [ 2]  236 	ldw	x, #0x5204
      00002C F6               [ 1]  237 	ld	a, (x)
                                    238 ;	se8r01.c: 42: return (ret);
      00002D 81               [ 4]  239 	ret
                                    240 ;	se8r01.c: 44: UCHAR write_spi_reg (UCHAR reg, UCHAR value) {
                                    241 ;	-----------------------------------------
                                    242 ;	 function write_spi_reg
                                    243 ;	-----------------------------------------
      00002E                        244 _write_spi_reg:
      00002E 88               [ 1]  245 	push	a
                                    246 ;	se8r01.c: 46: PC_ODR &= ~(1 << CSN);
      00002F AE 50 0A         [ 2]  247 	ldw	x, #0x500a
      000032 F6               [ 1]  248 	ld	a, (x)
      000033 A4 F7            [ 1]  249 	and	a, #0xf7
      000035 F7               [ 1]  250 	ld	(x), a
                                    251 ;	se8r01.c: 47: ret = write_spi (reg);
      000036 7B 04            [ 1]  252 	ld	a, (0x04, sp)
      000038 88               [ 1]  253 	push	a
      000039 CDr00r08         [ 4]  254 	call	_write_spi
      00003C 5B 01            [ 2]  255 	addw	sp, #1
      00003E 6B 01            [ 1]  256 	ld	(0x01, sp), a
                                    257 ;	se8r01.c: 48: if (reg != NOP && reg != FLUSH_RX && reg != FLUSH_TX)
      000040 7B 04            [ 1]  258 	ld	a, (0x04, sp)
      000042 A1 FF            [ 1]  259 	cp	a, #0xff
      000044 27 15            [ 1]  260 	jreq	00102$
      000046 7B 04            [ 1]  261 	ld	a, (0x04, sp)
      000048 A1 E2            [ 1]  262 	cp	a, #0xe2
      00004A 27 0F            [ 1]  263 	jreq	00102$
      00004C 7B 04            [ 1]  264 	ld	a, (0x04, sp)
      00004E A1 E1            [ 1]  265 	cp	a, #0xe1
      000050 27 09            [ 1]  266 	jreq	00102$
                                    267 ;	se8r01.c: 49: write_spi (value);
      000052 7B 05            [ 1]  268 	ld	a, (0x05, sp)
      000054 88               [ 1]  269 	push	a
      000055 CDr00r08         [ 4]  270 	call	_write_spi
      000058 84               [ 1]  271 	pop	a
      000059 20 03            [ 2]  272 	jra	00103$
      00005B                        273 00102$:
                                    274 ;	se8r01.c: 51: delayTenMicro ();
      00005B CDr00r00         [ 4]  275 	call	_delayTenMicro
      00005E                        276 00103$:
                                    277 ;	se8r01.c: 52: PC_ODR |= (1 << CSN);
      00005E AE 50 0A         [ 2]  278 	ldw	x, #0x500a
      000061 F6               [ 1]  279 	ld	a, (x)
      000062 AA 08            [ 1]  280 	or	a, #0x08
      000064 F7               [ 1]  281 	ld	(x), a
                                    282 ;	se8r01.c: 53: return (ret);
      000065 7B 01            [ 1]  283 	ld	a, (0x01, sp)
      000067 5B 01            [ 2]  284 	addw	sp, #1
      000069 81               [ 4]  285 	ret
                                    286 ;	se8r01.c: 55: UCHAR read_spi_reg (UCHAR reg) {
                                    287 ;	-----------------------------------------
                                    288 ;	 function read_spi_reg
                                    289 ;	-----------------------------------------
      00006A                        290 _read_spi_reg:
      00006A 88               [ 1]  291 	push	a
                                    292 ;	se8r01.c: 57: PC_ODR &= ~(1 << CSN);
      00006B AE 50 0A         [ 2]  293 	ldw	x, #0x500a
      00006E F6               [ 1]  294 	ld	a, (x)
      00006F A4 F7            [ 1]  295 	and	a, #0xf7
      000071 F7               [ 1]  296 	ld	(x), a
                                    297 ;	se8r01.c: 58: ret = write_spi (reg);
      000072 7B 04            [ 1]  298 	ld	a, (0x04, sp)
      000074 88               [ 1]  299 	push	a
      000075 CDr00r08         [ 4]  300 	call	_write_spi
      000078 5B 01            [ 2]  301 	addw	sp, #1
      00007A 6B 01            [ 1]  302 	ld	(0x01, sp), a
                                    303 ;	se8r01.c: 59: if (reg != NOP && reg != FLUSH_RX && reg != FLUSH_TX)
      00007C 7B 04            [ 1]  304 	ld	a, (0x04, sp)
      00007E A1 FF            [ 1]  305 	cp	a, #0xff
      000080 27 17            [ 1]  306 	jreq	00102$
      000082 7B 04            [ 1]  307 	ld	a, (0x04, sp)
      000084 A1 E2            [ 1]  308 	cp	a, #0xe2
      000086 27 11            [ 1]  309 	jreq	00102$
      000088 7B 04            [ 1]  310 	ld	a, (0x04, sp)
      00008A A1 E1            [ 1]  311 	cp	a, #0xe1
      00008C 27 0B            [ 1]  312 	jreq	00102$
                                    313 ;	se8r01.c: 60: ret = write_spi (NOP);
      00008E 4B FF            [ 1]  314 	push	#0xff
      000090 CDr00r08         [ 4]  315 	call	_write_spi
      000093 5B 01            [ 2]  316 	addw	sp, #1
      000095 6B 01            [ 1]  317 	ld	(0x01, sp), a
      000097 20 03            [ 2]  318 	jra	00103$
      000099                        319 00102$:
                                    320 ;	se8r01.c: 62: delayTenMicro ();
      000099 CDr00r00         [ 4]  321 	call	_delayTenMicro
      00009C                        322 00103$:
                                    323 ;	se8r01.c: 63: PC_ODR |= (1 << CSN);
      00009C AE 50 0A         [ 2]  324 	ldw	x, #0x500a
      00009F F6               [ 1]  325 	ld	a, (x)
      0000A0 AA 08            [ 1]  326 	or	a, #0x08
      0000A2 F7               [ 1]  327 	ld	(x), a
                                    328 ;	se8r01.c: 64: return (ret);
      0000A3 7B 01            [ 1]  329 	ld	a, (0x01, sp)
      0000A5 5B 01            [ 2]  330 	addw	sp, #1
      0000A7 81               [ 4]  331 	ret
                                    332 ;	se8r01.c: 66: UCHAR write_spi_buf (UCHAR reg, UCHAR *array, UCHAR len) {
                                    333 ;	-----------------------------------------
                                    334 ;	 function write_spi_buf
                                    335 ;	-----------------------------------------
      0000A8                        336 _write_spi_buf:
      0000A8 52 02            [ 2]  337 	sub	sp, #2
                                    338 ;	se8r01.c: 68: PC_ODR &= ~(1 << CSN);
      0000AA AE 50 0A         [ 2]  339 	ldw	x, #0x500a
      0000AD F6               [ 1]  340 	ld	a, (x)
      0000AE A4 F7            [ 1]  341 	and	a, #0xf7
      0000B0 F7               [ 1]  342 	ld	(x), a
                                    343 ;	se8r01.c: 69: ret = write_spi (reg);
      0000B1 7B 05            [ 1]  344 	ld	a, (0x05, sp)
      0000B3 88               [ 1]  345 	push	a
      0000B4 CDr00r08         [ 4]  346 	call	_write_spi
      0000B7 5B 01            [ 2]  347 	addw	sp, #1
      0000B9 6B 02            [ 1]  348 	ld	(0x02, sp), a
                                    349 ;	se8r01.c: 70: for (n = 0; n < len; ++n)
      0000BB 0F 01            [ 1]  350 	clr	(0x01, sp)
      0000BD                        351 00103$:
      0000BD 7B 01            [ 1]  352 	ld	a, (0x01, sp)
      0000BF 11 08            [ 1]  353 	cp	a, (0x08, sp)
      0000C1 24 11            [ 1]  354 	jrnc	00101$
                                    355 ;	se8r01.c: 71: write_spi (array[n]);
      0000C3 5F               [ 1]  356 	clrw	x
      0000C4 7B 01            [ 1]  357 	ld	a, (0x01, sp)
      0000C6 97               [ 1]  358 	ld	xl, a
      0000C7 72 FB 06         [ 2]  359 	addw	x, (0x06, sp)
      0000CA F6               [ 1]  360 	ld	a, (x)
      0000CB 88               [ 1]  361 	push	a
      0000CC CDr00r08         [ 4]  362 	call	_write_spi
      0000CF 84               [ 1]  363 	pop	a
                                    364 ;	se8r01.c: 70: for (n = 0; n < len; ++n)
      0000D0 0C 01            [ 1]  365 	inc	(0x01, sp)
      0000D2 20 E9            [ 2]  366 	jra	00103$
      0000D4                        367 00101$:
                                    368 ;	se8r01.c: 72: PC_ODR |= (1 << CSN);
      0000D4 AE 50 0A         [ 2]  369 	ldw	x, #0x500a
      0000D7 F6               [ 1]  370 	ld	a, (x)
      0000D8 AA 08            [ 1]  371 	or	a, #0x08
      0000DA F7               [ 1]  372 	ld	(x), a
                                    373 ;	se8r01.c: 73: return (ret);
      0000DB 7B 02            [ 1]  374 	ld	a, (0x02, sp)
      0000DD 5B 02            [ 2]  375 	addw	sp, #2
      0000DF 81               [ 4]  376 	ret
                                    377 ;	se8r01.c: 75: UCHAR read_spi_buf (UCHAR reg, UCHAR *array, UCHAR len) {
                                    378 ;	-----------------------------------------
                                    379 ;	 function read_spi_buf
                                    380 ;	-----------------------------------------
      0000E0                        381 _read_spi_buf:
      0000E0 52 02            [ 2]  382 	sub	sp, #2
                                    383 ;	se8r01.c: 77: PC_ODR &= ~(1 << CSN);
      0000E2 AE 50 0A         [ 2]  384 	ldw	x, #0x500a
      0000E5 F6               [ 1]  385 	ld	a, (x)
      0000E6 A4 F7            [ 1]  386 	and	a, #0xf7
      0000E8 F7               [ 1]  387 	ld	(x), a
                                    388 ;	se8r01.c: 78: ret = write_spi (reg);
      0000E9 7B 05            [ 1]  389 	ld	a, (0x05, sp)
      0000EB 88               [ 1]  390 	push	a
      0000EC CDr00r08         [ 4]  391 	call	_write_spi
      0000EF 5B 01            [ 2]  392 	addw	sp, #1
      0000F1 6B 01            [ 1]  393 	ld	(0x01, sp), a
                                    394 ;	se8r01.c: 79: for (n = 0; n < len; ++n)
      0000F3 0F 02            [ 1]  395 	clr	(0x02, sp)
      0000F5                        396 00103$:
      0000F5 7B 02            [ 1]  397 	ld	a, (0x02, sp)
      0000F7 11 08            [ 1]  398 	cp	a, (0x08, sp)
      0000F9 24 15            [ 1]  399 	jrnc	00101$
                                    400 ;	se8r01.c: 80: array[n] = write_spi (NOP);
      0000FB 5F               [ 1]  401 	clrw	x
      0000FC 7B 02            [ 1]  402 	ld	a, (0x02, sp)
      0000FE 97               [ 1]  403 	ld	xl, a
      0000FF 72 FB 06         [ 2]  404 	addw	x, (0x06, sp)
      000102 89               [ 2]  405 	pushw	x
      000103 4B FF            [ 1]  406 	push	#0xff
      000105 CDr00r08         [ 4]  407 	call	_write_spi
      000108 5B 01            [ 2]  408 	addw	sp, #1
      00010A 85               [ 2]  409 	popw	x
      00010B F7               [ 1]  410 	ld	(x), a
                                    411 ;	se8r01.c: 79: for (n = 0; n < len; ++n)
      00010C 0C 02            [ 1]  412 	inc	(0x02, sp)
      00010E 20 E5            [ 2]  413 	jra	00103$
      000110                        414 00101$:
                                    415 ;	se8r01.c: 81: PC_ODR |= (1 << CSN);
      000110 AE 50 0A         [ 2]  416 	ldw	x, #0x500a
      000113 F6               [ 1]  417 	ld	a, (x)
      000114 AA 08            [ 1]  418 	or	a, #0x08
      000116 F7               [ 1]  419 	ld	(x), a
                                    420 ;	se8r01.c: 82: return (ret);
      000117 7B 01            [ 1]  421 	ld	a, (0x01, sp)
      000119 5B 02            [ 2]  422 	addw	sp, #2
      00011B 81               [ 4]  423 	ret
                                    424 ;	se8r01.c: 84: void InitializeSPI () {
                                    425 ;	-----------------------------------------
                                    426 ;	 function InitializeSPI
                                    427 ;	-----------------------------------------
      00011C                        428 _InitializeSPI:
                                    429 ;	se8r01.c: 85: SPI_CR1 = MSBFIRST | SPI_ENABLE | BR_DIV256 | MASTER | CPOL0 | CPHA0;
      00011C AE 52 00         [ 2]  430 	ldw	x, #0x5200
      00011F A6 7C            [ 1]  431 	ld	a, #0x7c
      000121 F7               [ 1]  432 	ld	(x), a
                                    433 ;	se8r01.c: 86: SPI_CR2 = BDM_2LINE | CRCEN_OFF | CRCNEXT_TXBUF | FULL_DUPLEX | SSM_DISABLE;
      000122 AE 52 01         [ 2]  434 	ldw	x, #0x5201
      000125 7F               [ 1]  435 	clr	(x)
                                    436 ;	se8r01.c: 87: SPI_ICR = TXIE_MASKED | RXIE_MASKED | ERRIE_MASKED | WKIE_MASKED;
      000126 AE 52 02         [ 2]  437 	ldw	x, #0x5202
      000129 7F               [ 1]  438 	clr	(x)
                                    439 ;	se8r01.c: 88: PC_DDR = (1 << PC3) | (1 << PC4); // output mode
      00012A AE 50 0C         [ 2]  440 	ldw	x, #0x500c
      00012D A6 18            [ 1]  441 	ld	a, #0x18
      00012F F7               [ 1]  442 	ld	(x), a
                                    443 ;	se8r01.c: 89: PC_CR1 = (1 << PC3) | (1 << PC4); // push-pull
      000130 AE 50 0D         [ 2]  444 	ldw	x, #0x500d
      000133 A6 18            [ 1]  445 	ld	a, #0x18
      000135 F7               [ 1]  446 	ld	(x), a
                                    447 ;	se8r01.c: 90: PC_CR2 = (1 << PC3) | (1 << PC4); // up to 10MHz speed
      000136 AE 50 0E         [ 2]  448 	ldw	x, #0x500e
      000139 A6 18            [ 1]  449 	ld	a, #0x18
      00013B F7               [ 1]  450 	ld	(x), a
                                    451 ;	se8r01.c: 92: PC_ODR &= ~(1 << CE);
      00013C AE 50 0A         [ 2]  452 	ldw	x, #0x500a
      00013F F6               [ 1]  453 	ld	a, (x)
      000140 A4 EF            [ 1]  454 	and	a, #0xef
      000142 F7               [ 1]  455 	ld	(x), a
      000143 81               [ 4]  456 	ret
                                    457 ;	se8r01.c: 94: void InitializeSystemClock() {
                                    458 ;	-----------------------------------------
                                    459 ;	 function InitializeSystemClock
                                    460 ;	-----------------------------------------
      000144                        461 _InitializeSystemClock:
                                    462 ;	se8r01.c: 95: CLK_ICKR = 0;                       //  Reset the Internal Clock Register.
      000144 AE 50 C0         [ 2]  463 	ldw	x, #0x50c0
      000147 7F               [ 1]  464 	clr	(x)
                                    465 ;	se8r01.c: 96: CLK_ICKR = CLK_HSIEN;               //  Enable the HSI.
      000148 AE 50 C0         [ 2]  466 	ldw	x, #0x50c0
      00014B A6 01            [ 1]  467 	ld	a, #0x01
      00014D F7               [ 1]  468 	ld	(x), a
                                    469 ;	se8r01.c: 97: CLK_ECKR = 0;                       //  Disable the external clock.
      00014E AE 50 C1         [ 2]  470 	ldw	x, #0x50c1
      000151 7F               [ 1]  471 	clr	(x)
                                    472 ;	se8r01.c: 98: while ((CLK_ICKR & CLK_HSIRDY) == 0);       //  Wait for the HSI to be ready for use.
      000152                        473 00101$:
      000152 AE 50 C0         [ 2]  474 	ldw	x, #0x50c0
      000155 F6               [ 1]  475 	ld	a, (x)
      000156 A5 02            [ 1]  476 	bcp	a, #0x02
      000158 27 F8            [ 1]  477 	jreq	00101$
                                    478 ;	se8r01.c: 99: CLK_CKDIVR = 0;                     //  Ensure the clocks are running at full speed.
      00015A AE 50 C6         [ 2]  479 	ldw	x, #0x50c6
      00015D 7F               [ 1]  480 	clr	(x)
                                    481 ;	se8r01.c: 100: CLK_PCKENR1 = 0xff;                 //  Enable all peripheral clocks.
      00015E AE 50 C7         [ 2]  482 	ldw	x, #0x50c7
      000161 A6 FF            [ 1]  483 	ld	a, #0xff
      000163 F7               [ 1]  484 	ld	(x), a
                                    485 ;	se8r01.c: 101: CLK_PCKENR2 = 0xff;                 //  Ditto.
      000164 AE 50 CA         [ 2]  486 	ldw	x, #0x50ca
      000167 A6 FF            [ 1]  487 	ld	a, #0xff
      000169 F7               [ 1]  488 	ld	(x), a
                                    489 ;	se8r01.c: 102: CLK_CCOR = 0;                       //  Turn off CCO.
      00016A AE 50 C9         [ 2]  490 	ldw	x, #0x50c9
      00016D 7F               [ 1]  491 	clr	(x)
                                    492 ;	se8r01.c: 103: CLK_HSITRIMR = 0;                   //  Turn off any HSIU trimming.
      00016E AE 50 CC         [ 2]  493 	ldw	x, #0x50cc
      000171 7F               [ 1]  494 	clr	(x)
                                    495 ;	se8r01.c: 104: CLK_SWIMCCR = 0;                    //  Set SWIM to run at clock / 2.
      000172 AE 50 CD         [ 2]  496 	ldw	x, #0x50cd
      000175 7F               [ 1]  497 	clr	(x)
                                    498 ;	se8r01.c: 105: CLK_SWR = 0xe1;                     //  Use HSI as the clock source.
      000176 AE 50 C4         [ 2]  499 	ldw	x, #0x50c4
      000179 A6 E1            [ 1]  500 	ld	a, #0xe1
      00017B F7               [ 1]  501 	ld	(x), a
                                    502 ;	se8r01.c: 106: CLK_SWCR = 0;                       //  Reset the clock switch control register.
      00017C AE 50 C5         [ 2]  503 	ldw	x, #0x50c5
      00017F 7F               [ 1]  504 	clr	(x)
                                    505 ;	se8r01.c: 107: CLK_SWCR = CLK_SWEN;                //  Enable switching.
      000180 AE 50 C5         [ 2]  506 	ldw	x, #0x50c5
      000183 A6 02            [ 1]  507 	ld	a, #0x02
      000185 F7               [ 1]  508 	ld	(x), a
                                    509 ;	se8r01.c: 108: while ((CLK_SWCR & CLK_SWBSY) != 0);        //  Pause while the clock switch is busy.
      000186                        510 00104$:
      000186 AE 50 C5         [ 2]  511 	ldw	x, #0x50c5
      000189 F6               [ 1]  512 	ld	a, (x)
      00018A 44               [ 1]  513 	srl	a
      00018B 25 F9            [ 1]  514 	jrc	00104$
      00018D 81               [ 4]  515 	ret
                                    516 ;	se8r01.c: 110: void delay (int time_ms) {
                                    517 ;	-----------------------------------------
                                    518 ;	 function delay
                                    519 ;	-----------------------------------------
      00018E                        520 _delay:
      00018E 52 0A            [ 2]  521 	sub	sp, #10
                                    522 ;	se8r01.c: 112: for (x = 0; x < 1036*time_ms; ++x)
      000190 5F               [ 1]  523 	clrw	x
      000191 1F 03            [ 2]  524 	ldw	(0x03, sp), x
      000193 1F 01            [ 2]  525 	ldw	(0x01, sp), x
      000195 1E 0D            [ 2]  526 	ldw	x, (0x0d, sp)
      000197 89               [ 2]  527 	pushw	x
      000198 4B 0C            [ 1]  528 	push	#0x0c
      00019A 4B 04            [ 1]  529 	push	#0x04
      00019C CDr00r00         [ 4]  530 	call	__mulint
      00019F 5B 04            [ 2]  531 	addw	sp, #4
      0001A1 1F 09            [ 2]  532 	ldw	(0x09, sp), x
      0001A3                        533 00103$:
      0001A3 16 09            [ 2]  534 	ldw	y, (0x09, sp)
      0001A5 17 07            [ 2]  535 	ldw	(0x07, sp), y
      0001A7 7B 07            [ 1]  536 	ld	a, (0x07, sp)
      0001A9 49               [ 1]  537 	rlc	a
      0001AA 4F               [ 1]  538 	clr	a
      0001AB A2 00            [ 1]  539 	sbc	a, #0x00
      0001AD 6B 06            [ 1]  540 	ld	(0x06, sp), a
      0001AF 6B 05            [ 1]  541 	ld	(0x05, sp), a
      0001B1 1E 03            [ 2]  542 	ldw	x, (0x03, sp)
      0001B3 13 07            [ 2]  543 	cpw	x, (0x07, sp)
      0001B5 7B 02            [ 1]  544 	ld	a, (0x02, sp)
      0001B7 12 06            [ 1]  545 	sbc	a, (0x06, sp)
      0001B9 7B 01            [ 1]  546 	ld	a, (0x01, sp)
      0001BB 12 05            [ 1]  547 	sbc	a, (0x05, sp)
      0001BD 2E 17            [ 1]  548 	jrsge	00105$
                                    549 ;	se8r01.c: 113: __asm__("nop");
      0001BF 9D               [ 1]  550 	nop
                                    551 ;	se8r01.c: 112: for (x = 0; x < 1036*time_ms; ++x)
      0001C0 16 03            [ 2]  552 	ldw	y, (0x03, sp)
      0001C2 72 A9 00 01      [ 2]  553 	addw	y, #0x0001
      0001C6 7B 02            [ 1]  554 	ld	a, (0x02, sp)
      0001C8 A9 00            [ 1]  555 	adc	a, #0x00
      0001CA 97               [ 1]  556 	ld	xl, a
      0001CB 7B 01            [ 1]  557 	ld	a, (0x01, sp)
      0001CD A9 00            [ 1]  558 	adc	a, #0x00
      0001CF 95               [ 1]  559 	ld	xh, a
      0001D0 17 03            [ 2]  560 	ldw	(0x03, sp), y
      0001D2 1F 01            [ 2]  561 	ldw	(0x01, sp), x
      0001D4 20 CD            [ 2]  562 	jra	00103$
      0001D6                        563 00105$:
      0001D6 5B 0A            [ 2]  564 	addw	sp, #10
      0001D8 81               [ 4]  565 	ret
                                    566 ;	se8r01.c: 115: void i2c_read (unsigned char *x) {
                                    567 ;	-----------------------------------------
                                    568 ;	 function i2c_read
                                    569 ;	-----------------------------------------
      0001D9                        570 _i2c_read:
                                    571 ;	se8r01.c: 116: while ((I2C_SR1 & I2C_RXNE) == 0);
      0001D9                        572 00101$:
      0001D9 AE 52 17         [ 2]  573 	ldw	x, #0x5217
      0001DC F6               [ 1]  574 	ld	a, (x)
      0001DD A5 40            [ 1]  575 	bcp	a, #0x40
      0001DF 27 F8            [ 1]  576 	jreq	00101$
                                    577 ;	se8r01.c: 117: *x = I2C_DR;
      0001E1 16 03            [ 2]  578 	ldw	y, (0x03, sp)
      0001E3 AE 52 16         [ 2]  579 	ldw	x, #0x5216
      0001E6 F6               [ 1]  580 	ld	a, (x)
      0001E7 90 F7            [ 1]  581 	ld	(y), a
      0001E9 81               [ 4]  582 	ret
                                    583 ;	se8r01.c: 119: void i2c_set_nak (void) {
                                    584 ;	-----------------------------------------
                                    585 ;	 function i2c_set_nak
                                    586 ;	-----------------------------------------
      0001EA                        587 _i2c_set_nak:
                                    588 ;	se8r01.c: 120: I2C_CR2 &= ~I2C_ACK;
      0001EA AE 52 11         [ 2]  589 	ldw	x, #0x5211
      0001ED F6               [ 1]  590 	ld	a, (x)
      0001EE A4 FB            [ 1]  591 	and	a, #0xfb
      0001F0 F7               [ 1]  592 	ld	(x), a
      0001F1 81               [ 4]  593 	ret
                                    594 ;	se8r01.c: 122: void i2c_set_stop (void) {
                                    595 ;	-----------------------------------------
                                    596 ;	 function i2c_set_stop
                                    597 ;	-----------------------------------------
      0001F2                        598 _i2c_set_stop:
                                    599 ;	se8r01.c: 123: I2C_CR2 |= I2C_STOP;
      0001F2 AE 52 11         [ 2]  600 	ldw	x, #0x5211
      0001F5 F6               [ 1]  601 	ld	a, (x)
      0001F6 AA 02            [ 1]  602 	or	a, #0x02
      0001F8 F7               [ 1]  603 	ld	(x), a
      0001F9 81               [ 4]  604 	ret
                                    605 ;	se8r01.c: 125: void i2c_send_reg (UCHAR addr) {
                                    606 ;	-----------------------------------------
                                    607 ;	 function i2c_send_reg
                                    608 ;	-----------------------------------------
      0001FA                        609 _i2c_send_reg:
      0001FA 52 02            [ 2]  610 	sub	sp, #2
                                    611 ;	se8r01.c: 127: reg = I2C_SR1;
      0001FC AE 52 17         [ 2]  612 	ldw	x, #0x5217
      0001FF F6               [ 1]  613 	ld	a, (x)
      000200 5F               [ 1]  614 	clrw	x
      000201 97               [ 1]  615 	ld	xl, a
      000202 1F 01            [ 2]  616 	ldw	(0x01, sp), x
                                    617 ;	se8r01.c: 128: reg = I2C_SR3;
      000204 AE 52 19         [ 2]  618 	ldw	x, #0x5219
      000207 F6               [ 1]  619 	ld	a, (x)
      000208 5F               [ 1]  620 	clrw	x
      000209 97               [ 1]  621 	ld	xl, a
      00020A 1F 01            [ 2]  622 	ldw	(0x01, sp), x
                                    623 ;	se8r01.c: 129: I2C_DR = addr;
      00020C AE 52 16         [ 2]  624 	ldw	x, #0x5216
      00020F 7B 05            [ 1]  625 	ld	a, (0x05, sp)
      000211 F7               [ 1]  626 	ld	(x), a
                                    627 ;	se8r01.c: 130: while ((I2C_SR1 & I2C_TXE) == 0);
      000212                        628 00101$:
      000212 AE 52 17         [ 2]  629 	ldw	x, #0x5217
      000215 F6               [ 1]  630 	ld	a, (x)
      000216 48               [ 1]  631 	sll	a
      000217 24 F9            [ 1]  632 	jrnc	00101$
      000219 5B 02            [ 2]  633 	addw	sp, #2
      00021B 81               [ 4]  634 	ret
                                    635 ;	se8r01.c: 132: void i2c_send_address (UCHAR addr, UCHAR mode) {
                                    636 ;	-----------------------------------------
                                    637 ;	 function i2c_send_address
                                    638 ;	-----------------------------------------
      00021C                        639 _i2c_send_address:
      00021C 52 03            [ 2]  640 	sub	sp, #3
                                    641 ;	se8r01.c: 134: reg = I2C_SR1;
      00021E AE 52 17         [ 2]  642 	ldw	x, #0x5217
      000221 F6               [ 1]  643 	ld	a, (x)
      000222 5F               [ 1]  644 	clrw	x
      000223 97               [ 1]  645 	ld	xl, a
      000224 1F 01            [ 2]  646 	ldw	(0x01, sp), x
                                    647 ;	se8r01.c: 135: I2C_DR = (addr << 1) | mode;
      000226 7B 06            [ 1]  648 	ld	a, (0x06, sp)
      000228 48               [ 1]  649 	sll	a
      000229 1A 07            [ 1]  650 	or	a, (0x07, sp)
      00022B AE 52 16         [ 2]  651 	ldw	x, #0x5216
      00022E F7               [ 1]  652 	ld	(x), a
                                    653 ;	se8r01.c: 136: if (mode == I2C_READ) {
      00022F 7B 07            [ 1]  654 	ld	a, (0x07, sp)
      000231 A1 01            [ 1]  655 	cp	a, #0x01
      000233 26 06            [ 1]  656 	jrne	00127$
      000235 A6 01            [ 1]  657 	ld	a, #0x01
      000237 6B 03            [ 1]  658 	ld	(0x03, sp), a
      000239 20 02            [ 2]  659 	jra	00128$
      00023B                        660 00127$:
      00023B 0F 03            [ 1]  661 	clr	(0x03, sp)
      00023D                        662 00128$:
      00023D 0D 03            [ 1]  663 	tnz	(0x03, sp)
      00023F 27 08            [ 1]  664 	jreq	00103$
                                    665 ;	se8r01.c: 137: I2C_OARL = 0;
      000241 AE 52 13         [ 2]  666 	ldw	x, #0x5213
      000244 7F               [ 1]  667 	clr	(x)
                                    668 ;	se8r01.c: 138: I2C_OARH = 0;
      000245 AE 52 14         [ 2]  669 	ldw	x, #0x5214
      000248 7F               [ 1]  670 	clr	(x)
                                    671 ;	se8r01.c: 140: while ((I2C_SR1 & I2C_ADDR) == 0);
      000249                        672 00103$:
                                    673 ;	se8r01.c: 134: reg = I2C_SR1;
      000249 AE 52 17         [ 2]  674 	ldw	x, #0x5217
      00024C F6               [ 1]  675 	ld	a, (x)
                                    676 ;	se8r01.c: 140: while ((I2C_SR1 & I2C_ADDR) == 0);
      00024D A5 02            [ 1]  677 	bcp	a, #0x02
      00024F 27 F8            [ 1]  678 	jreq	00103$
                                    679 ;	se8r01.c: 141: if (mode == I2C_READ)
      000251 0D 03            [ 1]  680 	tnz	(0x03, sp)
      000253 27 06            [ 1]  681 	jreq	00108$
                                    682 ;	se8r01.c: 142: UNSET (I2C_SR1, I2C_ADDR);
      000255 A4 FD            [ 1]  683 	and	a, #0xfd
      000257 AE 52 17         [ 2]  684 	ldw	x, #0x5217
      00025A F7               [ 1]  685 	ld	(x), a
      00025B                        686 00108$:
      00025B 5B 03            [ 2]  687 	addw	sp, #3
      00025D 81               [ 4]  688 	ret
                                    689 ;	se8r01.c: 144: void i2c_set_start_ack (void) {
                                    690 ;	-----------------------------------------
                                    691 ;	 function i2c_set_start_ack
                                    692 ;	-----------------------------------------
      00025E                        693 _i2c_set_start_ack:
                                    694 ;	se8r01.c: 145: I2C_CR2 = I2C_ACK | I2C_START;
      00025E AE 52 11         [ 2]  695 	ldw	x, #0x5211
      000261 A6 05            [ 1]  696 	ld	a, #0x05
      000263 F7               [ 1]  697 	ld	(x), a
                                    698 ;	se8r01.c: 146: while ((I2C_SR1 & I2C_SB) == 0);
      000264                        699 00101$:
      000264 AE 52 17         [ 2]  700 	ldw	x, #0x5217
      000267 F6               [ 1]  701 	ld	a, (x)
      000268 44               [ 1]  702 	srl	a
      000269 24 F9            [ 1]  703 	jrnc	00101$
      00026B 81               [ 4]  704 	ret
                                    705 ;	se8r01.c: 151: void UARTPrintF (char *message) {
                                    706 ;	-----------------------------------------
                                    707 ;	 function UARTPrintF
                                    708 ;	-----------------------------------------
      00026C                        709 _UARTPrintF:
                                    710 ;	se8r01.c: 152: char *ch = message;
      00026C 16 03            [ 2]  711 	ldw	y, (0x03, sp)
                                    712 ;	se8r01.c: 153: while (*ch) {
      00026E                        713 00104$:
      00026E 90 F6            [ 1]  714 	ld	a, (y)
      000270 4D               [ 1]  715 	tnz	a
      000271 27 0F            [ 1]  716 	jreq	00107$
                                    717 ;	se8r01.c: 154: UART1_DR = (unsigned char) *ch;     //  Put the next character into the data transmission register.
      000273 AE 52 31         [ 2]  718 	ldw	x, #0x5231
      000276 F7               [ 1]  719 	ld	(x), a
                                    720 ;	se8r01.c: 155: while ((UART1_SR & SR_TXE) == 0);   //  Wait for transmission to complete.
      000277                        721 00101$:
      000277 AE 52 30         [ 2]  722 	ldw	x, #0x5230
      00027A F6               [ 1]  723 	ld	a, (x)
      00027B 48               [ 1]  724 	sll	a
      00027C 24 F9            [ 1]  725 	jrnc	00101$
                                    726 ;	se8r01.c: 156: ch++;                               //  Grab the next character.
      00027E 90 5C            [ 2]  727 	incw	y
      000280 20 EC            [ 2]  728 	jra	00104$
      000282                        729 00107$:
      000282 81               [ 4]  730 	ret
                                    731 ;	se8r01.c: 159: void print_UCHAR_hex (unsigned char buffer) {
                                    732 ;	-----------------------------------------
                                    733 ;	 function print_UCHAR_hex
                                    734 ;	-----------------------------------------
      000283                        735 _print_UCHAR_hex:
      000283 52 0C            [ 2]  736 	sub	sp, #12
                                    737 ;	se8r01.c: 162: a = (buffer >> 4);
      000285 7B 0F            [ 1]  738 	ld	a, (0x0f, sp)
      000287 4E               [ 1]  739 	swap	a
      000288 A4 0F            [ 1]  740 	and	a, #0x0f
      00028A 5F               [ 1]  741 	clrw	x
      00028B 97               [ 1]  742 	ld	xl, a
                                    743 ;	se8r01.c: 163: if (a > 9)
      00028C A3 00 09         [ 2]  744 	cpw	x, #0x0009
      00028F 2D 07            [ 1]  745 	jrsle	00102$
                                    746 ;	se8r01.c: 164: a = a + 'a' - 10;
      000291 1C 00 57         [ 2]  747 	addw	x, #0x0057
      000294 1F 0B            [ 2]  748 	ldw	(0x0b, sp), x
      000296 20 05            [ 2]  749 	jra	00103$
      000298                        750 00102$:
                                    751 ;	se8r01.c: 166: a += '0'; 
      000298 1C 00 30         [ 2]  752 	addw	x, #0x0030
      00029B 1F 0B            [ 2]  753 	ldw	(0x0b, sp), x
      00029D                        754 00103$:
                                    755 ;	se8r01.c: 167: b = buffer & 0x0f;
      00029D 7B 0F            [ 1]  756 	ld	a, (0x0f, sp)
      00029F A4 0F            [ 1]  757 	and	a, #0x0f
      0002A1 5F               [ 1]  758 	clrw	x
      0002A2 97               [ 1]  759 	ld	xl, a
                                    760 ;	se8r01.c: 168: if (b > 9)
      0002A3 A3 00 09         [ 2]  761 	cpw	x, #0x0009
      0002A6 2D 07            [ 1]  762 	jrsle	00105$
                                    763 ;	se8r01.c: 169: b = b + 'a' - 10;
      0002A8 1C 00 57         [ 2]  764 	addw	x, #0x0057
      0002AB 1F 09            [ 2]  765 	ldw	(0x09, sp), x
      0002AD 20 05            [ 2]  766 	jra	00106$
      0002AF                        767 00105$:
                                    768 ;	se8r01.c: 171: b += '0'; 
      0002AF 1C 00 30         [ 2]  769 	addw	x, #0x0030
      0002B2 1F 09            [ 2]  770 	ldw	(0x09, sp), x
      0002B4                        771 00106$:
                                    772 ;	se8r01.c: 172: message[0] = a;
      0002B4 90 96            [ 1]  773 	ldw	y, sp
      0002B6 90 5C            [ 2]  774 	incw	y
      0002B8 7B 0C            [ 1]  775 	ld	a, (0x0c, sp)
      0002BA 90 F7            [ 1]  776 	ld	(y), a
                                    777 ;	se8r01.c: 173: message[1] = b;
      0002BC 93               [ 1]  778 	ldw	x, y
      0002BD 5C               [ 2]  779 	incw	x
      0002BE 7B 0A            [ 1]  780 	ld	a, (0x0a, sp)
      0002C0 F7               [ 1]  781 	ld	(x), a
                                    782 ;	se8r01.c: 174: message[2] = 0;
      0002C1 93               [ 1]  783 	ldw	x, y
      0002C2 5C               [ 2]  784 	incw	x
      0002C3 5C               [ 2]  785 	incw	x
      0002C4 7F               [ 1]  786 	clr	(x)
                                    787 ;	se8r01.c: 175: UARTPrintF (message);
      0002C5 90 89            [ 2]  788 	pushw	y
      0002C7 CDr02r6C         [ 4]  789 	call	_UARTPrintF
      0002CA 5B 02            [ 2]  790 	addw	sp, #2
      0002CC 5B 0C            [ 2]  791 	addw	sp, #12
      0002CE 81               [ 4]  792 	ret
                                    793 ;	se8r01.c: 177: unsigned char i2c_read_register (UCHAR addr, UCHAR rg) {
                                    794 ;	-----------------------------------------
                                    795 ;	 function i2c_read_register
                                    796 ;	-----------------------------------------
      0002CF                        797 _i2c_read_register:
      0002CF 52 02            [ 2]  798 	sub	sp, #2
                                    799 ;	se8r01.c: 180: i2c_set_start_ack ();
      0002D1 CDr02r5E         [ 4]  800 	call	_i2c_set_start_ack
                                    801 ;	se8r01.c: 181: i2c_send_address (addr, I2C_WRITE);
      0002D4 4B 00            [ 1]  802 	push	#0x00
      0002D6 7B 06            [ 1]  803 	ld	a, (0x06, sp)
      0002D8 88               [ 1]  804 	push	a
      0002D9 CDr02r1C         [ 4]  805 	call	_i2c_send_address
      0002DC 5B 02            [ 2]  806 	addw	sp, #2
                                    807 ;	se8r01.c: 182: i2c_send_reg (rg);
      0002DE 7B 06            [ 1]  808 	ld	a, (0x06, sp)
      0002E0 88               [ 1]  809 	push	a
      0002E1 CDr01rFA         [ 4]  810 	call	_i2c_send_reg
      0002E4 84               [ 1]  811 	pop	a
                                    812 ;	se8r01.c: 183: i2c_set_start_ack ();
      0002E5 CDr02r5E         [ 4]  813 	call	_i2c_set_start_ack
                                    814 ;	se8r01.c: 184: i2c_send_address (addr, I2C_READ);
      0002E8 4B 01            [ 1]  815 	push	#0x01
      0002EA 7B 06            [ 1]  816 	ld	a, (0x06, sp)
      0002EC 88               [ 1]  817 	push	a
      0002ED CDr02r1C         [ 4]  818 	call	_i2c_send_address
      0002F0 5B 02            [ 2]  819 	addw	sp, #2
                                    820 ;	se8r01.c: 185: reg = I2C_SR1;
      0002F2 AE 52 17         [ 2]  821 	ldw	x, #0x5217
      0002F5 F6               [ 1]  822 	ld	a, (x)
      0002F6 6B 02            [ 1]  823 	ld	(0x02, sp), a
                                    824 ;	se8r01.c: 186: reg = I2C_SR3;
      0002F8 AE 52 19         [ 2]  825 	ldw	x, #0x5219
      0002FB F6               [ 1]  826 	ld	a, (x)
      0002FC 6B 02            [ 1]  827 	ld	(0x02, sp), a
                                    828 ;	se8r01.c: 187: i2c_set_nak ();
      0002FE CDr01rEA         [ 4]  829 	call	_i2c_set_nak
                                    830 ;	se8r01.c: 188: i2c_set_stop ();
      000301 CDr01rF2         [ 4]  831 	call	_i2c_set_stop
                                    832 ;	se8r01.c: 189: i2c_read (&x);
      000304 96               [ 1]  833 	ldw	x, sp
      000305 5C               [ 2]  834 	incw	x
      000306 89               [ 2]  835 	pushw	x
      000307 CDr01rD9         [ 4]  836 	call	_i2c_read
      00030A 5B 02            [ 2]  837 	addw	sp, #2
                                    838 ;	se8r01.c: 190: return (x);
      00030C 7B 01            [ 1]  839 	ld	a, (0x01, sp)
      00030E 5B 02            [ 2]  840 	addw	sp, #2
      000310 81               [ 4]  841 	ret
                                    842 ;	se8r01.c: 193: void InitializeI2C (void) {
                                    843 ;	-----------------------------------------
                                    844 ;	 function InitializeI2C
                                    845 ;	-----------------------------------------
      000311                        846 _InitializeI2C:
                                    847 ;	se8r01.c: 194: I2C_CR1 = 0;   //  Disable I2C before configuration starts. PE bit is bit 0
      000311 AE 52 10         [ 2]  848 	ldw	x, #0x5210
      000314 7F               [ 1]  849 	clr	(x)
                                    850 ;	se8r01.c: 198: I2C_FREQR = 16;                     //  Set the internal clock frequency (MHz).
      000315 AE 52 12         [ 2]  851 	ldw	x, #0x5212
      000318 A6 10            [ 1]  852 	ld	a, #0x10
      00031A F7               [ 1]  853 	ld	(x), a
                                    854 ;	se8r01.c: 199: UNSET (I2C_CCRH, I2C_FS);           //  I2C running is standard mode.
      00031B 72 17 52 1C      [ 1]  855 	bres	0x521c, #7
                                    856 ;	se8r01.c: 200: I2C_CCRL = 0x10;                    //  SCL clock speed is 500 kHz.
      00031F AE 52 1B         [ 2]  857 	ldw	x, #0x521b
      000322 A6 10            [ 1]  858 	ld	a, #0x10
      000324 F7               [ 1]  859 	ld	(x), a
                                    860 ;	se8r01.c: 201: I2C_CCRH &= 0xf0;	// Clears lower 4 bits "CCR"
      000325 AE 52 1C         [ 2]  861 	ldw	x, #0x521c
      000328 F6               [ 1]  862 	ld	a, (x)
      000329 A4 F0            [ 1]  863 	and	a, #0xf0
      00032B F7               [ 1]  864 	ld	(x), a
                                    865 ;	se8r01.c: 205: UNSET (I2C_OARH, I2C_ADDMODE);      //  7 bit address mode.
      00032C 72 17 52 14      [ 1]  866 	bres	0x5214, #7
                                    867 ;	se8r01.c: 206: SET (I2C_OARH, I2C_ADDCONF);        //  Docs say this must always be 1.
      000330 AE 52 14         [ 2]  868 	ldw	x, #0x5214
      000333 F6               [ 1]  869 	ld	a, (x)
      000334 AA 40            [ 1]  870 	or	a, #0x40
      000336 F7               [ 1]  871 	ld	(x), a
                                    872 ;	se8r01.c: 210: I2C_TRISER = 17;
      000337 AE 52 1D         [ 2]  873 	ldw	x, #0x521d
      00033A A6 11            [ 1]  874 	ld	a, #0x11
      00033C F7               [ 1]  875 	ld	(x), a
                                    876 ;	se8r01.c: 218: I2C_CR1 = I2C_PE;	// Enables port
      00033D AE 52 10         [ 2]  877 	ldw	x, #0x5210
      000340 A6 01            [ 1]  878 	ld	a, #0x01
      000342 F7               [ 1]  879 	ld	(x), a
      000343 81               [ 4]  880 	ret
                                    881 ;	se8r01.c: 224: void InitializeUART() {
                                    882 ;	-----------------------------------------
                                    883 ;	 function InitializeUART
                                    884 ;	-----------------------------------------
      000344                        885 _InitializeUART:
                                    886 ;	se8r01.c: 234: UART1_CR1 = 0;
      000344 AE 52 34         [ 2]  887 	ldw	x, #0x5234
      000347 7F               [ 1]  888 	clr	(x)
                                    889 ;	se8r01.c: 235: UART1_CR2 = 0;
      000348 AE 52 35         [ 2]  890 	ldw	x, #0x5235
      00034B 7F               [ 1]  891 	clr	(x)
                                    892 ;	se8r01.c: 236: UART1_CR4 = 0;
      00034C AE 52 37         [ 2]  893 	ldw	x, #0x5237
      00034F 7F               [ 1]  894 	clr	(x)
                                    895 ;	se8r01.c: 237: UART1_CR3 = 0;
      000350 AE 52 36         [ 2]  896 	ldw	x, #0x5236
      000353 7F               [ 1]  897 	clr	(x)
                                    898 ;	se8r01.c: 238: UART1_CR5 = 0;
      000354 AE 52 38         [ 2]  899 	ldw	x, #0x5238
      000357 7F               [ 1]  900 	clr	(x)
                                    901 ;	se8r01.c: 239: UART1_GTR = 0;
      000358 AE 52 39         [ 2]  902 	ldw	x, #0x5239
      00035B 7F               [ 1]  903 	clr	(x)
                                    904 ;	se8r01.c: 240: UART1_PSCR = 0;
      00035C AE 52 3A         [ 2]  905 	ldw	x, #0x523a
      00035F 7F               [ 1]  906 	clr	(x)
                                    907 ;	se8r01.c: 244: UNSET (UART1_CR1, CR1_M);        //  8 Data bits.
      000360 AE 52 34         [ 2]  908 	ldw	x, #0x5234
      000363 F6               [ 1]  909 	ld	a, (x)
      000364 A4 EF            [ 1]  910 	and	a, #0xef
      000366 F7               [ 1]  911 	ld	(x), a
                                    912 ;	se8r01.c: 245: UNSET (UART1_CR1, CR1_PCEN);     //  Disable parity.
      000367 AE 52 34         [ 2]  913 	ldw	x, #0x5234
      00036A F6               [ 1]  914 	ld	a, (x)
      00036B A4 FB            [ 1]  915 	and	a, #0xfb
      00036D F7               [ 1]  916 	ld	(x), a
                                    917 ;	se8r01.c: 246: UNSET (UART1_CR3, CR3_STOPH);    //  1 stop bit.
      00036E AE 52 36         [ 2]  918 	ldw	x, #0x5236
      000371 F6               [ 1]  919 	ld	a, (x)
      000372 A4 DF            [ 1]  920 	and	a, #0xdf
      000374 F7               [ 1]  921 	ld	(x), a
                                    922 ;	se8r01.c: 247: UNSET (UART1_CR3, CR3_STOPL);    //  1 stop bit.
      000375 AE 52 36         [ 2]  923 	ldw	x, #0x5236
      000378 F6               [ 1]  924 	ld	a, (x)
      000379 A4 EF            [ 1]  925 	and	a, #0xef
      00037B F7               [ 1]  926 	ld	(x), a
                                    927 ;	se8r01.c: 248: UART1_BRR2 = 0x0a;      //  Set the baud rate registers to 115200 baud
      00037C AE 52 33         [ 2]  928 	ldw	x, #0x5233
      00037F A6 0A            [ 1]  929 	ld	a, #0x0a
      000381 F7               [ 1]  930 	ld	(x), a
                                    931 ;	se8r01.c: 249: UART1_BRR1 = 0x08;      //  based upon a 16 MHz system clock.
      000382 AE 52 32         [ 2]  932 	ldw	x, #0x5232
      000385 A6 08            [ 1]  933 	ld	a, #0x08
      000387 F7               [ 1]  934 	ld	(x), a
                                    935 ;	se8r01.c: 253: UNSET (UART1_CR2, CR2_TEN);      //  Disable transmit.
      000388 AE 52 35         [ 2]  936 	ldw	x, #0x5235
      00038B F6               [ 1]  937 	ld	a, (x)
      00038C A4 F7            [ 1]  938 	and	a, #0xf7
      00038E F7               [ 1]  939 	ld	(x), a
                                    940 ;	se8r01.c: 254: UNSET (UART1_CR2, CR2_REN);      //  Disable receive.
      00038F AE 52 35         [ 2]  941 	ldw	x, #0x5235
      000392 F6               [ 1]  942 	ld	a, (x)
      000393 A4 FB            [ 1]  943 	and	a, #0xfb
      000395 F7               [ 1]  944 	ld	(x), a
                                    945 ;	se8r01.c: 258: SET (UART1_CR3, CR3_CPOL);
      000396 AE 52 36         [ 2]  946 	ldw	x, #0x5236
      000399 F6               [ 1]  947 	ld	a, (x)
      00039A AA 04            [ 1]  948 	or	a, #0x04
      00039C F7               [ 1]  949 	ld	(x), a
                                    950 ;	se8r01.c: 259: SET (UART1_CR3, CR3_CPHA);
      00039D AE 52 36         [ 2]  951 	ldw	x, #0x5236
      0003A0 F6               [ 1]  952 	ld	a, (x)
      0003A1 AA 02            [ 1]  953 	or	a, #0x02
      0003A3 F7               [ 1]  954 	ld	(x), a
                                    955 ;	se8r01.c: 260: SET (UART1_CR3, CR3_LBCL);
      0003A4 72 10 52 36      [ 1]  956 	bset	0x5236, #0
                                    957 ;	se8r01.c: 264: SET (UART1_CR2, CR2_TEN);
      0003A8 AE 52 35         [ 2]  958 	ldw	x, #0x5235
      0003AB F6               [ 1]  959 	ld	a, (x)
      0003AC AA 08            [ 1]  960 	or	a, #0x08
      0003AE F7               [ 1]  961 	ld	(x), a
                                    962 ;	se8r01.c: 265: SET (UART1_CR2, CR2_REN);
      0003AF AE 52 35         [ 2]  963 	ldw	x, #0x5235
      0003B2 F6               [ 1]  964 	ld	a, (x)
      0003B3 AA 04            [ 1]  965 	or	a, #0x04
      0003B5 F7               [ 1]  966 	ld	(x), a
                                    967 ;	se8r01.c: 266: UART1_CR3 = CR3_CLKEN;
      0003B6 AE 52 36         [ 2]  968 	ldw	x, #0x5236
      0003B9 A6 08            [ 1]  969 	ld	a, #0x08
      0003BB F7               [ 1]  970 	ld	(x), a
      0003BC 81               [ 4]  971 	ret
                                    972 ;	se8r01.c: 334: void init_io(void)
                                    973 ;	-----------------------------------------
                                    974 ;	 function init_io
                                    975 ;	-----------------------------------------
      0003BD                        976 _init_io:
                                    977 ;	se8r01.c: 336: PD_DDR &= ~(1 << 3); // input mode
      0003BD AE 50 11         [ 2]  978 	ldw	x, #0x5011
      0003C0 F6               [ 1]  979 	ld	a, (x)
      0003C1 A4 F7            [ 1]  980 	and	a, #0xf7
      0003C3 F7               [ 1]  981 	ld	(x), a
                                    982 ;	se8r01.c: 337: PD_CR1 |= (1 << 3); // input with pull up 
      0003C4 AE 50 12         [ 2]  983 	ldw	x, #0x5012
      0003C7 F6               [ 1]  984 	ld	a, (x)
      0003C8 AA 08            [ 1]  985 	or	a, #0x08
      0003CA F7               [ 1]  986 	ld	(x), a
                                    987 ;	se8r01.c: 338: PD_CR2 |= (1 << 3); // interrupt enabled 
      0003CB AE 50 13         [ 2]  988 	ldw	x, #0x5013
      0003CE F6               [ 1]  989 	ld	a, (x)
      0003CF AA 08            [ 1]  990 	or	a, #0x08
      0003D1 F7               [ 1]  991 	ld	(x), a
                                    992 ;	se8r01.c: 339: PD_ODR &= ~(1 << 3);
      0003D2 AE 50 0F         [ 2]  993 	ldw	x, #0x500f
      0003D5 F6               [ 1]  994 	ld	a, (x)
      0003D6 A4 F7            [ 1]  995 	and	a, #0xf7
      0003D8 F7               [ 1]  996 	ld	(x), a
                                    997 ;	se8r01.c: 342: PC_ODR &= ~(1 << CE);
      0003D9 AE 50 0A         [ 2]  998 	ldw	x, #0x500a
      0003DC F6               [ 1]  999 	ld	a, (x)
      0003DD A4 EF            [ 1] 1000 	and	a, #0xef
      0003DF F7               [ 1] 1001 	ld	(x), a
                                   1002 ;	se8r01.c: 344: PC_ODR |= (1 << CSN);
      0003E0 AE 50 0A         [ 2] 1003 	ldw	x, #0x500a
      0003E3 F6               [ 1] 1004 	ld	a, (x)
      0003E4 AA 08            [ 1] 1005 	or	a, #0x08
      0003E6 F7               [ 1] 1006 	ld	(x), a
      0003E7 81               [ 4] 1007 	ret
                                   1008 ;	se8r01.c: 350: void rf_switch_bank(unsigned char bankindex)
                                   1009 ;	-----------------------------------------
                                   1010 ;	 function rf_switch_bank
                                   1011 ;	-----------------------------------------
      0003E8                       1012 _rf_switch_bank:
      0003E8 88               [ 1] 1013 	push	a
                                   1014 ;	se8r01.c: 353: temp1 = bankindex;
      0003E9 7B 04            [ 1] 1015 	ld	a, (0x04, sp)
      0003EB 6B 01            [ 1] 1016 	ld	(0x01, sp), a
                                   1017 ;	se8r01.c: 355: temp0 = write_spi(iRF_BANK0_STATUS);
      0003ED 4B 07            [ 1] 1018 	push	#0x07
      0003EF CDr00r08         [ 4] 1019 	call	_write_spi
      0003F2 5B 01            [ 2] 1020 	addw	sp, #1
                                   1021 ;	se8r01.c: 357: if((temp0&0x80)!=temp1)
      0003F4 A4 80            [ 1] 1022 	and	a, #0x80
      0003F6 11 01            [ 1] 1023 	cp	a, (0x01, sp)
      0003F8 27 09            [ 1] 1024 	jreq	00103$
                                   1025 ;	se8r01.c: 359: write_spi_reg(iRF_CMD_ACTIVATE,0x53);
      0003FA 4B 53            [ 1] 1026 	push	#0x53
      0003FC 4B 50            [ 1] 1027 	push	#0x50
      0003FE CDr00r2E         [ 4] 1028 	call	_write_spi_reg
      000401 5B 02            [ 2] 1029 	addw	sp, #2
      000403                       1030 00103$:
      000403 84               [ 1] 1031 	pop	a
      000404 81               [ 4] 1032 	ret
                                   1033 ;	se8r01.c: 366: void SE8R01_Calibration()
                                   1034 ;	-----------------------------------------
                                   1035 ;	 function SE8R01_Calibration
                                   1036 ;	-----------------------------------------
      000405                       1037 _SE8R01_Calibration:
      000405 52 0D            [ 2] 1038 	sub	sp, #13
                                   1039 ;	se8r01.c: 369: rf_switch_bank(iBANK0);
      000407 4B 00            [ 1] 1040 	push	#0x00
      000409 CDr03rE8         [ 4] 1041 	call	_rf_switch_bank
      00040C 84               [ 1] 1042 	pop	a
                                   1043 ;	se8r01.c: 370: temp[0]=0x03;
      00040D 96               [ 1] 1044 	ldw	x, sp
      00040E 5C               [ 2] 1045 	incw	x
      00040F 1F 0C            [ 2] 1046 	ldw	(0x0c, sp), x
      000411 1E 0C            [ 2] 1047 	ldw	x, (0x0c, sp)
      000413 A6 03            [ 1] 1048 	ld	a, #0x03
      000415 F7               [ 1] 1049 	ld	(x), a
                                   1050 ;	se8r01.c: 371: write_spi_buf(iRF_CMD_WRITE_REG|iRF_BANK0_CONFIG,temp, 1);
      000416 1E 0C            [ 2] 1051 	ldw	x, (0x0c, sp)
      000418 4B 01            [ 1] 1052 	push	#0x01
      00041A 89               [ 2] 1053 	pushw	x
      00041B 4B 20            [ 1] 1054 	push	#0x20
      00041D CDr00rA8         [ 4] 1055 	call	_write_spi_buf
      000420 5B 04            [ 2] 1056 	addw	sp, #4
                                   1057 ;	se8r01.c: 373: temp[0]=0x32;
      000422 1E 0C            [ 2] 1058 	ldw	x, (0x0c, sp)
      000424 A6 32            [ 1] 1059 	ld	a, #0x32
      000426 F7               [ 1] 1060 	ld	(x), a
                                   1061 ;	se8r01.c: 375: write_spi_buf(iRF_CMD_WRITE_REG|iRF_BANK0_RF_CH, temp,1);
      000427 1E 0C            [ 2] 1062 	ldw	x, (0x0c, sp)
      000429 4B 01            [ 1] 1063 	push	#0x01
      00042B 89               [ 2] 1064 	pushw	x
      00042C 4B 25            [ 1] 1065 	push	#0x25
      00042E CDr00rA8         [ 4] 1066 	call	_write_spi_buf
      000431 5B 04            [ 2] 1067 	addw	sp, #4
                                   1068 ;	se8r01.c: 379: if (SE8R01_DR_2M==1)
      000433 CEu00u00         [ 2] 1069 	ldw	x, _SE8R01_DR_2M+0
      000436 A3 00 01         [ 2] 1070 	cpw	x, #0x0001
      000439 26 07            [ 1] 1071 	jrne	00105$
                                   1072 ;	se8r01.c: 380: {temp[0]=0x48;}
      00043B 1E 0C            [ 2] 1073 	ldw	x, (0x0c, sp)
      00043D A6 48            [ 1] 1074 	ld	a, #0x48
      00043F F7               [ 1] 1075 	ld	(x), a
      000440 20 14            [ 2] 1076 	jra	00106$
      000442                       1077 00105$:
                                   1078 ;	se8r01.c: 381: else if (SE8R01_DR_1M==1)
      000442 CEu00u02         [ 2] 1079 	ldw	x, _SE8R01_DR_1M+0
      000445 A3 00 01         [ 2] 1080 	cpw	x, #0x0001
      000448 26 07            [ 1] 1081 	jrne	00102$
                                   1082 ;	se8r01.c: 382: {temp[0]=0x40;}
      00044A 1E 0C            [ 2] 1083 	ldw	x, (0x0c, sp)
      00044C A6 40            [ 1] 1084 	ld	a, #0x40
      00044E F7               [ 1] 1085 	ld	(x), a
      00044F 20 05            [ 2] 1086 	jra	00106$
      000451                       1087 00102$:
                                   1088 ;	se8r01.c: 384: {temp[0]=0x68;}   
      000451 1E 0C            [ 2] 1089 	ldw	x, (0x0c, sp)
      000453 A6 68            [ 1] 1090 	ld	a, #0x68
      000455 F7               [ 1] 1091 	ld	(x), a
      000456                       1092 00106$:
                                   1093 ;	se8r01.c: 386: write_spi_buf(iRF_CMD_WRITE_REG|iRF_BANK0_RF_SETUP,temp,1);
      000456 1E 0C            [ 2] 1094 	ldw	x, (0x0c, sp)
      000458 4B 01            [ 1] 1095 	push	#0x01
      00045A 89               [ 2] 1096 	pushw	x
      00045B 4B 26            [ 1] 1097 	push	#0x26
      00045D CDr00rA8         [ 4] 1098 	call	_write_spi_buf
      000460 5B 04            [ 2] 1099 	addw	sp, #4
                                   1100 ;	se8r01.c: 387: temp[0]=0x77;
      000462 1E 0C            [ 2] 1101 	ldw	x, (0x0c, sp)
      000464 A6 77            [ 1] 1102 	ld	a, #0x77
      000466 F7               [ 1] 1103 	ld	(x), a
                                   1104 ;	se8r01.c: 388: write_spi_buf(iRF_CMD_WRITE_REG|iRF_BANK0_PRE_GURD, temp,1);
      000467 1E 0C            [ 2] 1105 	ldw	x, (0x0c, sp)
      000469 4B 01            [ 1] 1106 	push	#0x01
      00046B 89               [ 2] 1107 	pushw	x
      00046C 4B 3F            [ 1] 1108 	push	#0x3f
      00046E CDr00rA8         [ 4] 1109 	call	_write_spi_buf
      000471 5B 04            [ 2] 1110 	addw	sp, #4
                                   1111 ;	se8r01.c: 390: rf_switch_bank(iBANK1);
      000473 4B 80            [ 1] 1112 	push	#0x80
      000475 CDr03rE8         [ 4] 1113 	call	_rf_switch_bank
      000478 84               [ 1] 1114 	pop	a
                                   1115 ;	se8r01.c: 391: temp[0]=0x40;
      000479 1E 0C            [ 2] 1116 	ldw	x, (0x0c, sp)
      00047B A6 40            [ 1] 1117 	ld	a, #0x40
      00047D F7               [ 1] 1118 	ld	(x), a
                                   1119 ;	se8r01.c: 392: temp[1]=0x00;
      00047E 1E 0C            [ 2] 1120 	ldw	x, (0x0c, sp)
      000480 5C               [ 2] 1121 	incw	x
      000481 1F 0A            [ 2] 1122 	ldw	(0x0a, sp), x
      000483 1E 0A            [ 2] 1123 	ldw	x, (0x0a, sp)
      000485 7F               [ 1] 1124 	clr	(x)
                                   1125 ;	se8r01.c: 393: temp[2]=0x10;
      000486 1E 0C            [ 2] 1126 	ldw	x, (0x0c, sp)
      000488 5C               [ 2] 1127 	incw	x
      000489 5C               [ 2] 1128 	incw	x
      00048A 1F 08            [ 2] 1129 	ldw	(0x08, sp), x
      00048C 1E 08            [ 2] 1130 	ldw	x, (0x08, sp)
      00048E A6 10            [ 1] 1131 	ld	a, #0x10
      000490 F7               [ 1] 1132 	ld	(x), a
                                   1133 ;	se8r01.c: 395: {temp[3]=0xE6;}
      000491 1E 0C            [ 2] 1134 	ldw	x, (0x0c, sp)
      000493 1C 00 03         [ 2] 1135 	addw	x, #0x0003
      000496 1F 06            [ 2] 1136 	ldw	(0x06, sp), x
                                   1137 ;	se8r01.c: 394: if (SE8R01_DR_2M==1)
      000498 CEu00u00         [ 2] 1138 	ldw	x, _SE8R01_DR_2M+0
      00049B A3 00 01         [ 2] 1139 	cpw	x, #0x0001
      00049E 26 07            [ 1] 1140 	jrne	00108$
                                   1141 ;	se8r01.c: 395: {temp[3]=0xE6;}
      0004A0 1E 06            [ 2] 1142 	ldw	x, (0x06, sp)
      0004A2 A6 E6            [ 1] 1143 	ld	a, #0xe6
      0004A4 F7               [ 1] 1144 	ld	(x), a
      0004A5 20 05            [ 2] 1145 	jra	00109$
      0004A7                       1146 00108$:
                                   1147 ;	se8r01.c: 397: {temp[3]=0xE4;}
      0004A7 1E 06            [ 2] 1148 	ldw	x, (0x06, sp)
      0004A9 A6 E4            [ 1] 1149 	ld	a, #0xe4
      0004AB F7               [ 1] 1150 	ld	(x), a
      0004AC                       1151 00109$:
                                   1152 ;	se8r01.c: 399: write_spi_buf(iRF_CMD_WRITE_REG|iRF_BANK1_PLL_CTL0, temp, 4);
      0004AC 1E 0C            [ 2] 1153 	ldw	x, (0x0c, sp)
      0004AE 4B 04            [ 1] 1154 	push	#0x04
      0004B0 89               [ 2] 1155 	pushw	x
      0004B1 4B 21            [ 1] 1156 	push	#0x21
      0004B3 CDr00rA8         [ 4] 1157 	call	_write_spi_buf
      0004B6 5B 04            [ 2] 1158 	addw	sp, #4
                                   1159 ;	se8r01.c: 401: temp[0]=0x20;
      0004B8 1E 0C            [ 2] 1160 	ldw	x, (0x0c, sp)
      0004BA A6 20            [ 1] 1161 	ld	a, #0x20
      0004BC F7               [ 1] 1162 	ld	(x), a
                                   1163 ;	se8r01.c: 402: temp[1]=0x08;
      0004BD 1E 0A            [ 2] 1164 	ldw	x, (0x0a, sp)
      0004BF A6 08            [ 1] 1165 	ld	a, #0x08
      0004C1 F7               [ 1] 1166 	ld	(x), a
                                   1167 ;	se8r01.c: 403: temp[2]=0x50;
      0004C2 1E 08            [ 2] 1168 	ldw	x, (0x08, sp)
      0004C4 A6 50            [ 1] 1169 	ld	a, #0x50
      0004C6 F7               [ 1] 1170 	ld	(x), a
                                   1171 ;	se8r01.c: 404: temp[3]=0x40;
      0004C7 1E 06            [ 2] 1172 	ldw	x, (0x06, sp)
      0004C9 A6 40            [ 1] 1173 	ld	a, #0x40
      0004CB F7               [ 1] 1174 	ld	(x), a
                                   1175 ;	se8r01.c: 405: temp[4]=0x50;
      0004CC 1E 0C            [ 2] 1176 	ldw	x, (0x0c, sp)
      0004CE A6 50            [ 1] 1177 	ld	a, #0x50
      0004D0 E7 04            [ 1] 1178 	ld	(0x0004, x), a
                                   1179 ;	se8r01.c: 406: write_spi_buf(iRF_CMD_WRITE_REG|iRF_BANK1_CAL_CTL, temp, 5);
      0004D2 1E 0C            [ 2] 1180 	ldw	x, (0x0c, sp)
      0004D4 4B 05            [ 1] 1181 	push	#0x05
      0004D6 89               [ 2] 1182 	pushw	x
      0004D7 4B 23            [ 1] 1183 	push	#0x23
      0004D9 CDr00rA8         [ 4] 1184 	call	_write_spi_buf
      0004DC 5B 04            [ 2] 1185 	addw	sp, #4
                                   1186 ;	se8r01.c: 408: temp[0]=0x00;
      0004DE 1E 0C            [ 2] 1187 	ldw	x, (0x0c, sp)
      0004E0 7F               [ 1] 1188 	clr	(x)
                                   1189 ;	se8r01.c: 409: temp[1]=0x00;
      0004E1 1E 0A            [ 2] 1190 	ldw	x, (0x0a, sp)
      0004E3 7F               [ 1] 1191 	clr	(x)
                                   1192 ;	se8r01.c: 410: if (SE8R01_DR_2M==1)
      0004E4 CEu00u00         [ 2] 1193 	ldw	x, _SE8R01_DR_2M+0
      0004E7 A3 00 01         [ 2] 1194 	cpw	x, #0x0001
      0004EA 26 07            [ 1] 1195 	jrne	00111$
                                   1196 ;	se8r01.c: 411: { temp[2]=0x1E;}
      0004EC 1E 08            [ 2] 1197 	ldw	x, (0x08, sp)
      0004EE A6 1E            [ 1] 1198 	ld	a, #0x1e
      0004F0 F7               [ 1] 1199 	ld	(x), a
      0004F1 20 05            [ 2] 1200 	jra	00112$
      0004F3                       1201 00111$:
                                   1202 ;	se8r01.c: 413: { temp[2]=0x1F;}
      0004F3 1E 08            [ 2] 1203 	ldw	x, (0x08, sp)
      0004F5 A6 1F            [ 1] 1204 	ld	a, #0x1f
      0004F7 F7               [ 1] 1205 	ld	(x), a
      0004F8                       1206 00112$:
                                   1207 ;	se8r01.c: 415: write_spi_buf(iRF_CMD_WRITE_REG|iRF_BANK1_IF_FREQ, temp, 3);
      0004F8 1E 0C            [ 2] 1208 	ldw	x, (0x0c, sp)
      0004FA 4B 03            [ 1] 1209 	push	#0x03
      0004FC 89               [ 2] 1210 	pushw	x
      0004FD 4B 2A            [ 1] 1211 	push	#0x2a
      0004FF CDr00rA8         [ 4] 1212 	call	_write_spi_buf
      000502 5B 04            [ 2] 1213 	addw	sp, #4
                                   1214 ;	se8r01.c: 417: if (SE8R01_DR_2M==1)
      000504 CEu00u00         [ 2] 1215 	ldw	x, _SE8R01_DR_2M+0
      000507 A3 00 01         [ 2] 1216 	cpw	x, #0x0001
      00050A 26 07            [ 1] 1217 	jrne	00114$
                                   1218 ;	se8r01.c: 418: { temp[0]=0x29;}
      00050C 1E 0C            [ 2] 1219 	ldw	x, (0x0c, sp)
      00050E A6 29            [ 1] 1220 	ld	a, #0x29
      000510 F7               [ 1] 1221 	ld	(x), a
      000511 20 05            [ 2] 1222 	jra	00115$
      000513                       1223 00114$:
                                   1224 ;	se8r01.c: 420: { temp[0]=0x14;}
      000513 1E 0C            [ 2] 1225 	ldw	x, (0x0c, sp)
      000515 A6 14            [ 1] 1226 	ld	a, #0x14
      000517 F7               [ 1] 1227 	ld	(x), a
      000518                       1228 00115$:
                                   1229 ;	se8r01.c: 422: write_spi_buf(iRF_CMD_WRITE_REG|iRF_BANK1_FDEV, temp, 1);
      000518 1E 0C            [ 2] 1230 	ldw	x, (0x0c, sp)
      00051A 4B 01            [ 1] 1231 	push	#0x01
      00051C 89               [ 2] 1232 	pushw	x
      00051D 4B 2C            [ 1] 1233 	push	#0x2c
      00051F CDr00rA8         [ 4] 1234 	call	_write_spi_buf
      000522 5B 04            [ 2] 1235 	addw	sp, #4
                                   1236 ;	se8r01.c: 424: temp[0]=0x00;
      000524 1E 0C            [ 2] 1237 	ldw	x, (0x0c, sp)
      000526 7F               [ 1] 1238 	clr	(x)
                                   1239 ;	se8r01.c: 425: write_spi_buf(iRF_CMD_WRITE_REG|iRF_BANK1_DAC_CAL_LOW,temp,1);
      000527 1E 0C            [ 2] 1240 	ldw	x, (0x0c, sp)
      000529 4B 01            [ 1] 1241 	push	#0x01
      00052B 89               [ 2] 1242 	pushw	x
      00052C 4B 37            [ 1] 1243 	push	#0x37
      00052E CDr00rA8         [ 4] 1244 	call	_write_spi_buf
      000531 5B 04            [ 2] 1245 	addw	sp, #4
                                   1246 ;	se8r01.c: 427: temp[0]=0x7F;
      000533 1E 0C            [ 2] 1247 	ldw	x, (0x0c, sp)
      000535 A6 7F            [ 1] 1248 	ld	a, #0x7f
      000537 F7               [ 1] 1249 	ld	(x), a
                                   1250 ;	se8r01.c: 428: write_spi_buf(iRF_CMD_WRITE_REG|iRF_BANK1_DAC_CAL_HI,temp,1);
      000538 1E 0C            [ 2] 1251 	ldw	x, (0x0c, sp)
      00053A 4B 01            [ 1] 1252 	push	#0x01
      00053C 89               [ 2] 1253 	pushw	x
      00053D 4B 38            [ 1] 1254 	push	#0x38
      00053F CDr00rA8         [ 4] 1255 	call	_write_spi_buf
      000542 5B 04            [ 2] 1256 	addw	sp, #4
                                   1257 ;	se8r01.c: 430: temp[0]=0x02;
      000544 1E 0C            [ 2] 1258 	ldw	x, (0x0c, sp)
      000546 A6 02            [ 1] 1259 	ld	a, #0x02
      000548 F7               [ 1] 1260 	ld	(x), a
                                   1261 ;	se8r01.c: 431: temp[1]=0xC1;
      000549 1E 0A            [ 2] 1262 	ldw	x, (0x0a, sp)
      00054B A6 C1            [ 1] 1263 	ld	a, #0xc1
      00054D F7               [ 1] 1264 	ld	(x), a
                                   1265 ;	se8r01.c: 432: temp[2]=0xEB;            
      00054E 1E 08            [ 2] 1266 	ldw	x, (0x08, sp)
      000550 A6 EB            [ 1] 1267 	ld	a, #0xeb
      000552 F7               [ 1] 1268 	ld	(x), a
                                   1269 ;	se8r01.c: 433: temp[3]=0x1C;
      000553 1E 06            [ 2] 1270 	ldw	x, (0x06, sp)
      000555 A6 1C            [ 1] 1271 	ld	a, #0x1c
      000557 F7               [ 1] 1272 	ld	(x), a
                                   1273 ;	se8r01.c: 434: write_spi_buf(iRF_CMD_WRITE_REG|iRF_BANK1_AGC_GAIN, temp,4);
      000558 1E 0C            [ 2] 1274 	ldw	x, (0x0c, sp)
      00055A 4B 04            [ 1] 1275 	push	#0x04
      00055C 89               [ 2] 1276 	pushw	x
      00055D 4B 3D            [ 1] 1277 	push	#0x3d
      00055F CDr00rA8         [ 4] 1278 	call	_write_spi_buf
      000562 5B 04            [ 2] 1279 	addw	sp, #4
                                   1280 ;	se8r01.c: 436: temp[0]=0x97;
      000564 1E 0C            [ 2] 1281 	ldw	x, (0x0c, sp)
      000566 A6 97            [ 1] 1282 	ld	a, #0x97
      000568 F7               [ 1] 1283 	ld	(x), a
                                   1284 ;	se8r01.c: 437: temp[1]=0x64;
      000569 1E 0A            [ 2] 1285 	ldw	x, (0x0a, sp)
      00056B A6 64            [ 1] 1286 	ld	a, #0x64
      00056D F7               [ 1] 1287 	ld	(x), a
                                   1288 ;	se8r01.c: 438: temp[2]=0x00;
      00056E 1E 08            [ 2] 1289 	ldw	x, (0x08, sp)
      000570 7F               [ 1] 1290 	clr	(x)
                                   1291 ;	se8r01.c: 439: temp[3]=0x81;
      000571 1E 06            [ 2] 1292 	ldw	x, (0x06, sp)
      000573 A6 81            [ 1] 1293 	ld	a, #0x81
      000575 F7               [ 1] 1294 	ld	(x), a
                                   1295 ;	se8r01.c: 440: write_spi_buf(iRF_CMD_WRITE_REG|iRF_BANK1_RF_IVGEN, temp, 4);
      000576 1E 0C            [ 2] 1296 	ldw	x, (0x0c, sp)
      000578 4B 04            [ 1] 1297 	push	#0x04
      00057A 89               [ 2] 1298 	pushw	x
      00057B 4B 3E            [ 1] 1299 	push	#0x3e
      00057D CDr00rA8         [ 4] 1300 	call	_write_spi_buf
      000580 5B 04            [ 2] 1301 	addw	sp, #4
                                   1302 ;	se8r01.c: 441: rf_switch_bank(iBANK0);
      000582 4B 00            [ 1] 1303 	push	#0x00
      000584 CDr03rE8         [ 4] 1304 	call	_rf_switch_bank
      000587 84               [ 1] 1305 	pop	a
                                   1306 ;	se8r01.c: 446: delayTenMicro();
      000588 CDr00r00         [ 4] 1307 	call	_delayTenMicro
                                   1308 ;	se8r01.c: 447: PC_ODR |= (1 << CE);
      00058B AE 50 0A         [ 2] 1309 	ldw	x, #0x500a
      00058E F6               [ 1] 1310 	ld	a, (x)
      00058F AA 10            [ 1] 1311 	or	a, #0x10
      000591 F7               [ 1] 1312 	ld	(x), a
                                   1313 ;	se8r01.c: 448: delayTenMicro();
      000592 CDr00r00         [ 4] 1314 	call	_delayTenMicro
                                   1315 ;	se8r01.c: 449: PC_ODR &= ~(1 << CE);
      000595 AE 50 0A         [ 2] 1316 	ldw	x, #0x500a
      000598 F6               [ 1] 1317 	ld	a, (x)
      000599 A4 EF            [ 1] 1318 	and	a, #0xef
      00059B F7               [ 1] 1319 	ld	(x), a
                                   1320 ;	se8r01.c: 450: delay(50);                            // delay 50ms waitting for calibaration.
      00059C 4B 32            [ 1] 1321 	push	#0x32
      00059E 4B 00            [ 1] 1322 	push	#0x00
      0005A0 CDr01r8E         [ 4] 1323 	call	_delay
      0005A3 5B 02            [ 2] 1324 	addw	sp, #2
                                   1325 ;	se8r01.c: 455: delayTenMicro();
      0005A5 CDr00r00         [ 4] 1326 	call	_delayTenMicro
                                   1327 ;	se8r01.c: 456: PC_ODR |= (1 << CE);
      0005A8 AE 50 0A         [ 2] 1328 	ldw	x, #0x500a
      0005AB F6               [ 1] 1329 	ld	a, (x)
      0005AC AA 10            [ 1] 1330 	or	a, #0x10
      0005AE F7               [ 1] 1331 	ld	(x), a
                                   1332 ;	se8r01.c: 457: delayTenMicro();
      0005AF CDr00r00         [ 4] 1333 	call	_delayTenMicro
                                   1334 ;	se8r01.c: 458: PC_ODR &= ~(1 << CE);
      0005B2 AE 50 0A         [ 2] 1335 	ldw	x, #0x500a
      0005B5 F6               [ 1] 1336 	ld	a, (x)
      0005B6 A4 EF            [ 1] 1337 	and	a, #0xef
      0005B8 F7               [ 1] 1338 	ld	(x), a
                                   1339 ;	se8r01.c: 459: delay(50);                            // delay 50ms waitting for calibaration.
      0005B9 4B 32            [ 1] 1340 	push	#0x32
      0005BB 4B 00            [ 1] 1341 	push	#0x00
      0005BD CDr01r8E         [ 4] 1342 	call	_delay
      0005C0 5B 02            [ 2] 1343 	addw	sp, #2
      0005C2 5B 0D            [ 2] 1344 	addw	sp, #13
      0005C4 81               [ 4] 1345 	ret
                                   1346 ;	se8r01.c: 463: void SE8R01_Analog_Init()           //SE8R01 初始化
                                   1347 ;	-----------------------------------------
                                   1348 ;	 function SE8R01_Analog_Init
                                   1349 ;	-----------------------------------------
      0005C5                       1350 _SE8R01_Analog_Init:
      0005C5 52 15            [ 2] 1351 	sub	sp, #21
                                   1352 ;	se8r01.c: 468: gtemp[0]=0x28;
      0005C7 AEr00r00         [ 2] 1353 	ldw	x, #_gtemp+0
      0005CA 1F 0A            [ 2] 1354 	ldw	(0x0a, sp), x
      0005CC 1E 0A            [ 2] 1355 	ldw	x, (0x0a, sp)
      0005CE A6 28            [ 1] 1356 	ld	a, #0x28
      0005D0 F7               [ 1] 1357 	ld	(x), a
                                   1358 ;	se8r01.c: 469: gtemp[1]=0x32;
      0005D1 1E 0A            [ 2] 1359 	ldw	x, (0x0a, sp)
      0005D3 5C               [ 2] 1360 	incw	x
      0005D4 1F 08            [ 2] 1361 	ldw	(0x08, sp), x
      0005D6 1E 08            [ 2] 1362 	ldw	x, (0x08, sp)
      0005D8 A6 32            [ 1] 1363 	ld	a, #0x32
      0005DA F7               [ 1] 1364 	ld	(x), a
                                   1365 ;	se8r01.c: 470: gtemp[2]=0x80;
      0005DB 1E 0A            [ 2] 1366 	ldw	x, (0x0a, sp)
      0005DD 5C               [ 2] 1367 	incw	x
      0005DE 5C               [ 2] 1368 	incw	x
      0005DF 1F 06            [ 2] 1369 	ldw	(0x06, sp), x
      0005E1 1E 06            [ 2] 1370 	ldw	x, (0x06, sp)
      0005E3 A6 80            [ 1] 1371 	ld	a, #0x80
      0005E5 F7               [ 1] 1372 	ld	(x), a
                                   1373 ;	se8r01.c: 471: gtemp[3]=0x90;
      0005E6 1E 0A            [ 2] 1374 	ldw	x, (0x0a, sp)
      0005E8 1C 00 03         [ 2] 1375 	addw	x, #0x0003
      0005EB 1F 10            [ 2] 1376 	ldw	(0x10, sp), x
      0005ED 1E 10            [ 2] 1377 	ldw	x, (0x10, sp)
      0005EF A6 90            [ 1] 1378 	ld	a, #0x90
      0005F1 F7               [ 1] 1379 	ld	(x), a
                                   1380 ;	se8r01.c: 472: gtemp[4]=0x00;
      0005F2 1E 0A            [ 2] 1381 	ldw	x, (0x0a, sp)
      0005F4 1C 00 04         [ 2] 1382 	addw	x, #0x0004
      0005F7 7F               [ 1] 1383 	clr	(x)
                                   1384 ;	se8r01.c: 473: write_spi_buf(iRF_CMD_WRITE_REG|iRF_BANK0_SETUP_VALUE, gtemp, 5);
      0005F8 1E 0A            [ 2] 1385 	ldw	x, (0x0a, sp)
      0005FA 4B 05            [ 1] 1386 	push	#0x05
      0005FC 89               [ 2] 1387 	pushw	x
      0005FD 4B 3E            [ 1] 1388 	push	#0x3e
      0005FF CDr00rA8         [ 4] 1389 	call	_write_spi_buf
      000602 5B 04            [ 2] 1390 	addw	sp, #4
                                   1391 ;	se8r01.c: 474: delay(2);
      000604 4B 02            [ 1] 1392 	push	#0x02
      000606 4B 00            [ 1] 1393 	push	#0x00
      000608 CDr01r8E         [ 4] 1394 	call	_delay
      00060B 5B 02            [ 2] 1395 	addw	sp, #2
                                   1396 ;	se8r01.c: 477: rf_switch_bank(iBANK1);
      00060D 4B 80            [ 1] 1397 	push	#0x80
      00060F CDr03rE8         [ 4] 1398 	call	_rf_switch_bank
      000612 84               [ 1] 1399 	pop	a
                                   1400 ;	se8r01.c: 479: temp[0]=0x40;
      000613 96               [ 1] 1401 	ldw	x, sp
      000614 5C               [ 2] 1402 	incw	x
      000615 1F 0E            [ 2] 1403 	ldw	(0x0e, sp), x
      000617 1E 0E            [ 2] 1404 	ldw	x, (0x0e, sp)
      000619 A6 40            [ 1] 1405 	ld	a, #0x40
      00061B F7               [ 1] 1406 	ld	(x), a
                                   1407 ;	se8r01.c: 480: temp[1]=0x01;               
      00061C 1E 0E            [ 2] 1408 	ldw	x, (0x0e, sp)
      00061E 5C               [ 2] 1409 	incw	x
      00061F 1F 0C            [ 2] 1410 	ldw	(0x0c, sp), x
      000621 1E 0C            [ 2] 1411 	ldw	x, (0x0c, sp)
      000623 A6 01            [ 1] 1412 	ld	a, #0x01
      000625 F7               [ 1] 1413 	ld	(x), a
                                   1414 ;	se8r01.c: 481: temp[2]=0x30;               
      000626 1E 0E            [ 2] 1415 	ldw	x, (0x0e, sp)
      000628 5C               [ 2] 1416 	incw	x
      000629 5C               [ 2] 1417 	incw	x
      00062A 1F 14            [ 2] 1418 	ldw	(0x14, sp), x
      00062C 1E 14            [ 2] 1419 	ldw	x, (0x14, sp)
      00062E A6 30            [ 1] 1420 	ld	a, #0x30
      000630 F7               [ 1] 1421 	ld	(x), a
                                   1422 ;	se8r01.c: 483: { temp[3]=0xE2; }              
      000631 1E 0E            [ 2] 1423 	ldw	x, (0x0e, sp)
      000633 1C 00 03         [ 2] 1424 	addw	x, #0x0003
      000636 1F 12            [ 2] 1425 	ldw	(0x12, sp), x
                                   1426 ;	se8r01.c: 482: if (SE8R01_DR_2M==1)
      000638 CEu00u00         [ 2] 1427 	ldw	x, _SE8R01_DR_2M+0
      00063B A3 00 01         [ 2] 1428 	cpw	x, #0x0001
      00063E 26 07            [ 1] 1429 	jrne	00102$
                                   1430 ;	se8r01.c: 483: { temp[3]=0xE2; }              
      000640 1E 12            [ 2] 1431 	ldw	x, (0x12, sp)
      000642 A6 E2            [ 1] 1432 	ld	a, #0xe2
      000644 F7               [ 1] 1433 	ld	(x), a
      000645 20 05            [ 2] 1434 	jra	00103$
      000647                       1435 00102$:
                                   1436 ;	se8r01.c: 485: { temp[3]=0xE0;}
      000647 1E 12            [ 2] 1437 	ldw	x, (0x12, sp)
      000649 A6 E0            [ 1] 1438 	ld	a, #0xe0
      00064B F7               [ 1] 1439 	ld	(x), a
      00064C                       1440 00103$:
                                   1441 ;	se8r01.c: 487: write_spi_buf(iRF_CMD_WRITE_REG|iRF_BANK1_PLL_CTL0, temp,4);
      00064C 1E 0E            [ 2] 1442 	ldw	x, (0x0e, sp)
      00064E 4B 04            [ 1] 1443 	push	#0x04
      000650 89               [ 2] 1444 	pushw	x
      000651 4B 21            [ 1] 1445 	push	#0x21
      000653 CDr00rA8         [ 4] 1446 	call	_write_spi_buf
      000656 5B 04            [ 2] 1447 	addw	sp, #4
                                   1448 ;	se8r01.c: 489: temp[0]=0x29;
      000658 1E 0E            [ 2] 1449 	ldw	x, (0x0e, sp)
      00065A A6 29            [ 1] 1450 	ld	a, #0x29
      00065C F7               [ 1] 1451 	ld	(x), a
                                   1452 ;	se8r01.c: 490: temp[1]=0x89;
      00065D 1E 0C            [ 2] 1453 	ldw	x, (0x0c, sp)
      00065F A6 89            [ 1] 1454 	ld	a, #0x89
      000661 F7               [ 1] 1455 	ld	(x), a
                                   1456 ;	se8r01.c: 491: temp[2]=0x55;                     
      000662 1E 14            [ 2] 1457 	ldw	x, (0x14, sp)
      000664 A6 55            [ 1] 1458 	ld	a, #0x55
      000666 F7               [ 1] 1459 	ld	(x), a
                                   1460 ;	se8r01.c: 492: temp[3]=0x40;
      000667 1E 12            [ 2] 1461 	ldw	x, (0x12, sp)
      000669 A6 40            [ 1] 1462 	ld	a, #0x40
      00066B F7               [ 1] 1463 	ld	(x), a
                                   1464 ;	se8r01.c: 493: temp[4]=0x50;
      00066C 1E 0E            [ 2] 1465 	ldw	x, (0x0e, sp)
      00066E A6 50            [ 1] 1466 	ld	a, #0x50
      000670 E7 04            [ 1] 1467 	ld	(0x0004, x), a
                                   1468 ;	se8r01.c: 494: write_spi_buf(iRF_CMD_WRITE_REG|iRF_BANK1_CAL_CTL, temp,5);
      000672 1E 0E            [ 2] 1469 	ldw	x, (0x0e, sp)
      000674 4B 05            [ 1] 1470 	push	#0x05
      000676 89               [ 2] 1471 	pushw	x
      000677 4B 23            [ 1] 1472 	push	#0x23
      000679 CDr00rA8         [ 4] 1473 	call	_write_spi_buf
      00067C 5B 04            [ 2] 1474 	addw	sp, #4
                                   1475 ;	se8r01.c: 496: if (SE8R01_DR_2M==1)
      00067E CEu00u00         [ 2] 1476 	ldw	x, _SE8R01_DR_2M+0
      000681 A3 00 01         [ 2] 1477 	cpw	x, #0x0001
      000684 26 07            [ 1] 1478 	jrne	00105$
                                   1479 ;	se8r01.c: 497: { temp[0]=0x29;}
      000686 1E 0E            [ 2] 1480 	ldw	x, (0x0e, sp)
      000688 A6 29            [ 1] 1481 	ld	a, #0x29
      00068A F7               [ 1] 1482 	ld	(x), a
      00068B 20 05            [ 2] 1483 	jra	00106$
      00068D                       1484 00105$:
                                   1485 ;	se8r01.c: 499: { temp[0]=0x14;}
      00068D 1E 0E            [ 2] 1486 	ldw	x, (0x0e, sp)
      00068F A6 14            [ 1] 1487 	ld	a, #0x14
      000691 F7               [ 1] 1488 	ld	(x), a
      000692                       1489 00106$:
                                   1490 ;	se8r01.c: 501: write_spi_buf(iRF_CMD_WRITE_REG|iRF_BANK1_FDEV, temp,1);
      000692 1E 0E            [ 2] 1491 	ldw	x, (0x0e, sp)
      000694 4B 01            [ 1] 1492 	push	#0x01
      000696 89               [ 2] 1493 	pushw	x
      000697 4B 2C            [ 1] 1494 	push	#0x2c
      000699 CDr00rA8         [ 4] 1495 	call	_write_spi_buf
      00069C 5B 04            [ 2] 1496 	addw	sp, #4
                                   1497 ;	se8r01.c: 503: temp[0]=0x55;
      00069E 1E 0E            [ 2] 1498 	ldw	x, (0x0e, sp)
      0006A0 A6 55            [ 1] 1499 	ld	a, #0x55
      0006A2 F7               [ 1] 1500 	ld	(x), a
                                   1501 ;	se8r01.c: 504: temp[1]=0xC2;
      0006A3 1E 0C            [ 2] 1502 	ldw	x, (0x0c, sp)
      0006A5 A6 C2            [ 1] 1503 	ld	a, #0xc2
      0006A7 F7               [ 1] 1504 	ld	(x), a
                                   1505 ;	se8r01.c: 505: temp[2]=0x09;
      0006A8 1E 14            [ 2] 1506 	ldw	x, (0x14, sp)
      0006AA A6 09            [ 1] 1507 	ld	a, #0x09
      0006AC F7               [ 1] 1508 	ld	(x), a
                                   1509 ;	se8r01.c: 506: temp[3]=0xAC;  
      0006AD 1E 12            [ 2] 1510 	ldw	x, (0x12, sp)
      0006AF A6 AC            [ 1] 1511 	ld	a, #0xac
      0006B1 F7               [ 1] 1512 	ld	(x), a
                                   1513 ;	se8r01.c: 507: write_spi_buf(iRF_CMD_WRITE_REG|iRF_BANK1_RX_CTRL,temp,4);
      0006B2 1E 0E            [ 2] 1514 	ldw	x, (0x0e, sp)
      0006B4 4B 04            [ 1] 1515 	push	#0x04
      0006B6 89               [ 2] 1516 	pushw	x
      0006B7 4B 31            [ 1] 1517 	push	#0x31
      0006B9 CDr00rA8         [ 4] 1518 	call	_write_spi_buf
      0006BC 5B 04            [ 2] 1519 	addw	sp, #4
                                   1520 ;	se8r01.c: 509: temp[0]=0x00;
      0006BE 1E 0E            [ 2] 1521 	ldw	x, (0x0e, sp)
      0006C0 7F               [ 1] 1522 	clr	(x)
                                   1523 ;	se8r01.c: 510: temp[1]=0x14;
      0006C1 1E 0C            [ 2] 1524 	ldw	x, (0x0c, sp)
      0006C3 A6 14            [ 1] 1525 	ld	a, #0x14
      0006C5 F7               [ 1] 1526 	ld	(x), a
                                   1527 ;	se8r01.c: 511: temp[2]=0x08;   
      0006C6 1E 14            [ 2] 1528 	ldw	x, (0x14, sp)
      0006C8 A6 08            [ 1] 1529 	ld	a, #0x08
      0006CA F7               [ 1] 1530 	ld	(x), a
                                   1531 ;	se8r01.c: 512: temp[3]=0x29;
      0006CB 1E 12            [ 2] 1532 	ldw	x, (0x12, sp)
      0006CD A6 29            [ 1] 1533 	ld	a, #0x29
      0006CF F7               [ 1] 1534 	ld	(x), a
                                   1535 ;	se8r01.c: 513: write_spi_buf(iRF_CMD_WRITE_REG|iRF_BANK1_FAGC_CTRL_1, temp,4);
      0006D0 1E 0E            [ 2] 1536 	ldw	x, (0x0e, sp)
      0006D2 4B 04            [ 1] 1537 	push	#0x04
      0006D4 89               [ 2] 1538 	pushw	x
      0006D5 4B 33            [ 1] 1539 	push	#0x33
      0006D7 CDr00rA8         [ 4] 1540 	call	_write_spi_buf
      0006DA 5B 04            [ 2] 1541 	addw	sp, #4
                                   1542 ;	se8r01.c: 515: temp[0]=0x02;
      0006DC 1E 0E            [ 2] 1543 	ldw	x, (0x0e, sp)
      0006DE A6 02            [ 1] 1544 	ld	a, #0x02
      0006E0 F7               [ 1] 1545 	ld	(x), a
                                   1546 ;	se8r01.c: 516: temp[1]=0xC1;
      0006E1 1E 0C            [ 2] 1547 	ldw	x, (0x0c, sp)
      0006E3 A6 C1            [ 1] 1548 	ld	a, #0xc1
      0006E5 F7               [ 1] 1549 	ld	(x), a
                                   1550 ;	se8r01.c: 517: temp[2]=0xCB;  
      0006E6 1E 14            [ 2] 1551 	ldw	x, (0x14, sp)
      0006E8 A6 CB            [ 1] 1552 	ld	a, #0xcb
      0006EA F7               [ 1] 1553 	ld	(x), a
                                   1554 ;	se8r01.c: 518: temp[3]=0x1C;
      0006EB 1E 12            [ 2] 1555 	ldw	x, (0x12, sp)
      0006ED A6 1C            [ 1] 1556 	ld	a, #0x1c
      0006EF F7               [ 1] 1557 	ld	(x), a
                                   1558 ;	se8r01.c: 519: write_spi_buf(iRF_CMD_WRITE_REG|iRF_BANK1_AGC_GAIN, temp,4);
      0006F0 1E 0E            [ 2] 1559 	ldw	x, (0x0e, sp)
      0006F2 4B 04            [ 1] 1560 	push	#0x04
      0006F4 89               [ 2] 1561 	pushw	x
      0006F5 4B 3D            [ 1] 1562 	push	#0x3d
      0006F7 CDr00rA8         [ 4] 1563 	call	_write_spi_buf
      0006FA 5B 04            [ 2] 1564 	addw	sp, #4
                                   1565 ;	se8r01.c: 521: temp[0]=0x97;
      0006FC 1E 0E            [ 2] 1566 	ldw	x, (0x0e, sp)
      0006FE A6 97            [ 1] 1567 	ld	a, #0x97
      000700 F7               [ 1] 1568 	ld	(x), a
                                   1569 ;	se8r01.c: 522: temp[1]=0x64;
      000701 1E 0C            [ 2] 1570 	ldw	x, (0x0c, sp)
      000703 A6 64            [ 1] 1571 	ld	a, #0x64
      000705 F7               [ 1] 1572 	ld	(x), a
                                   1573 ;	se8r01.c: 523: temp[2]=0x00;
      000706 1E 14            [ 2] 1574 	ldw	x, (0x14, sp)
      000708 7F               [ 1] 1575 	clr	(x)
                                   1576 ;	se8r01.c: 524: temp[3]=0x01;
      000709 1E 12            [ 2] 1577 	ldw	x, (0x12, sp)
      00070B A6 01            [ 1] 1578 	ld	a, #0x01
      00070D F7               [ 1] 1579 	ld	(x), a
                                   1580 ;	se8r01.c: 525: write_spi_buf(iRF_CMD_WRITE_REG|iRF_BANK1_RF_IVGEN, temp,4);
      00070E 1E 0E            [ 2] 1581 	ldw	x, (0x0e, sp)
      000710 4B 04            [ 1] 1582 	push	#0x04
      000712 89               [ 2] 1583 	pushw	x
      000713 4B 3E            [ 1] 1584 	push	#0x3e
      000715 CDr00rA8         [ 4] 1585 	call	_write_spi_buf
      000718 5B 04            [ 2] 1586 	addw	sp, #4
                                   1587 ;	se8r01.c: 527: gtemp[0]=0x2A;
      00071A 1E 0A            [ 2] 1588 	ldw	x, (0x0a, sp)
      00071C A6 2A            [ 1] 1589 	ld	a, #0x2a
      00071E F7               [ 1] 1590 	ld	(x), a
                                   1591 ;	se8r01.c: 528: gtemp[1]=0x04;
      00071F 1E 08            [ 2] 1592 	ldw	x, (0x08, sp)
      000721 A6 04            [ 1] 1593 	ld	a, #0x04
      000723 F7               [ 1] 1594 	ld	(x), a
                                   1595 ;	se8r01.c: 529: gtemp[2]=0x00;
      000724 1E 06            [ 2] 1596 	ldw	x, (0x06, sp)
      000726 7F               [ 1] 1597 	clr	(x)
                                   1598 ;	se8r01.c: 530: gtemp[3]=0x7D;
      000727 1E 10            [ 2] 1599 	ldw	x, (0x10, sp)
      000729 A6 7D            [ 1] 1600 	ld	a, #0x7d
      00072B F7               [ 1] 1601 	ld	(x), a
                                   1602 ;	se8r01.c: 531: write_spi_buf(iRF_CMD_WRITE_REG|iRF_BANK1_TEST_PKDET, gtemp, 4);
      00072C 1E 0A            [ 2] 1603 	ldw	x, (0x0a, sp)
      00072E 4B 04            [ 1] 1604 	push	#0x04
      000730 89               [ 2] 1605 	pushw	x
      000731 4B 3F            [ 1] 1606 	push	#0x3f
      000733 CDr00rA8         [ 4] 1607 	call	_write_spi_buf
      000736 5B 04            [ 2] 1608 	addw	sp, #4
                                   1609 ;	se8r01.c: 533: rf_switch_bank(iBANK0);
      000738 4B 00            [ 1] 1610 	push	#0x00
      00073A CDr03rE8         [ 4] 1611 	call	_rf_switch_bank
      00073D 84               [ 1] 1612 	pop	a
      00073E 5B 15            [ 2] 1613 	addw	sp, #21
      000740 81               [ 4] 1614 	ret
                                   1615 ;	se8r01.c: 536: void SE8R01_Init()  
                                   1616 ;	-----------------------------------------
                                   1617 ;	 function SE8R01_Init
                                   1618 ;	-----------------------------------------
      000741                       1619 _SE8R01_Init:
      000741 52 05            [ 2] 1620 	sub	sp, #5
                                   1621 ;	se8r01.c: 539: SE8R01_Calibration();   
      000743 CDr04r05         [ 4] 1622 	call	_SE8R01_Calibration
                                   1623 ;	se8r01.c: 540: SE8R01_Analog_Init();   
      000746 CDr05rC5         [ 4] 1624 	call	_SE8R01_Analog_Init
                                   1625 ;	se8r01.c: 544: if (SE8R01_DR_2M==1)
      000749 CEu00u00         [ 2] 1626 	ldw	x, _SE8R01_DR_2M+0
      00074C A3 00 01         [ 2] 1627 	cpw	x, #0x0001
      00074F 26 07            [ 1] 1628 	jrne	00105$
                                   1629 ;	se8r01.c: 545: {  temp[0]=0b01001111; }     //2MHz,+5dbm
      000751 96               [ 1] 1630 	ldw	x, sp
      000752 5C               [ 2] 1631 	incw	x
      000753 A6 4F            [ 1] 1632 	ld	a, #0x4f
      000755 F7               [ 1] 1633 	ld	(x), a
      000756 20 14            [ 2] 1634 	jra	00106$
      000758                       1635 00105$:
                                   1636 ;	se8r01.c: 546: else if  (SE8R01_DR_1M==1)
      000758 CEu00u02         [ 2] 1637 	ldw	x, _SE8R01_DR_1M+0
      00075B A3 00 01         [ 2] 1638 	cpw	x, #0x0001
      00075E 26 07            [ 1] 1639 	jrne	00102$
                                   1640 ;	se8r01.c: 547: {  temp[0]=0b01000111;  }     //1MHz,+5dbm
      000760 96               [ 1] 1641 	ldw	x, sp
      000761 5C               [ 2] 1642 	incw	x
      000762 A6 47            [ 1] 1643 	ld	a, #0x47
      000764 F7               [ 1] 1644 	ld	(x), a
      000765 20 05            [ 2] 1645 	jra	00106$
      000767                       1646 00102$:
                                   1647 ;	se8r01.c: 549: {temp[0]=0b01101111;  }     //500K,+5dbm
      000767 96               [ 1] 1648 	ldw	x, sp
      000768 5C               [ 2] 1649 	incw	x
      000769 A6 6F            [ 1] 1650 	ld	a, #0x6f
      00076B F7               [ 1] 1651 	ld	(x), a
      00076C                       1652 00106$:
                                   1653 ;	se8r01.c: 551: write_spi_buf(iRF_CMD_WRITE_REG|iRF_BANK0_RF_SETUP,temp,1);
      00076C 96               [ 1] 1654 	ldw	x, sp
      00076D 5C               [ 2] 1655 	incw	x
      00076E 4B 01            [ 1] 1656 	push	#0x01
      000770 89               [ 2] 1657 	pushw	x
      000771 4B 26            [ 1] 1658 	push	#0x26
      000773 CDr00rA8         [ 4] 1659 	call	_write_spi_buf
      000776 5B 04            [ 2] 1660 	addw	sp, #4
                                   1661 ;	se8r01.c: 555: write_spi_reg(WRITE_REG|iRF_BANK0_EN_AA, 0b00111111);          //enable auto acc on pip 1
      000778 4B 3F            [ 1] 1662 	push	#0x3f
      00077A 4B 21            [ 1] 1663 	push	#0x21
      00077C CDr00r2E         [ 4] 1664 	call	_write_spi_reg
      00077F 5B 02            [ 2] 1665 	addw	sp, #2
                                   1666 ;	se8r01.c: 556: write_spi_reg(WRITE_REG|iRF_BANK0_EN_RXADDR, 0b00111111);      //enable pip 1
      000781 4B 3F            [ 1] 1667 	push	#0x3f
      000783 4B 22            [ 1] 1668 	push	#0x22
      000785 CDr00r2E         [ 4] 1669 	call	_write_spi_reg
      000788 5B 02            [ 2] 1670 	addw	sp, #2
                                   1671 ;	se8r01.c: 557: write_spi_reg(WRITE_REG|iRF_BANK0_SETUP_AW, 0x02);  
      00078A 4B 02            [ 1] 1672 	push	#0x02
      00078C 4B 23            [ 1] 1673 	push	#0x23
      00078E CDr00r2E         [ 4] 1674 	call	_write_spi_reg
      000791 5B 02            [ 2] 1675 	addw	sp, #2
                                   1676 ;	se8r01.c: 558: write_spi_reg(WRITE_REG|iRF_BANK0_RF_CH, 40);
      000793 4B 28            [ 1] 1677 	push	#0x28
      000795 4B 25            [ 1] 1678 	push	#0x25
      000797 CDr00r2E         [ 4] 1679 	call	_write_spi_reg
      00079A 5B 02            [ 2] 1680 	addw	sp, #2
                                   1681 ;	se8r01.c: 560: write_spi_buf(WRITE_REG + TX_ADDR, ADDRESS0, ADR_WIDTH);    	
      00079C AEr00r16         [ 2] 1682 	ldw	x, #_ADDRESS0+0
      00079F 90 93            [ 1] 1683 	ldw	y, x
      0007A1 89               [ 2] 1684 	pushw	x
      0007A2 4B 04            [ 1] 1685 	push	#0x04
      0007A4 90 89            [ 2] 1686 	pushw	y
      0007A6 4B 30            [ 1] 1687 	push	#0x30
      0007A8 CDr00rA8         [ 4] 1688 	call	_write_spi_buf
      0007AB 5B 04            [ 2] 1689 	addw	sp, #4
      0007AD 85               [ 2] 1690 	popw	x
                                   1691 ;	se8r01.c: 561: write_spi_buf(WRITE_REG + RX_ADDR_P0, ADDRESS0, ADR_WIDTH); 
      0007AE 4B 04            [ 1] 1692 	push	#0x04
      0007B0 89               [ 2] 1693 	pushw	x
      0007B1 4B 2A            [ 1] 1694 	push	#0x2a
      0007B3 CDr00rA8         [ 4] 1695 	call	_write_spi_buf
      0007B6 5B 04            [ 2] 1696 	addw	sp, #4
                                   1697 ;	se8r01.c: 562: write_spi_buf(WRITE_REG + RX_ADDR_P1, ADDRESS1, ADR_WIDTH); 
      0007B8 AEr00r12         [ 2] 1698 	ldw	x, #_ADDRESS1+0
      0007BB 4B 04            [ 1] 1699 	push	#0x04
      0007BD 89               [ 2] 1700 	pushw	x
      0007BE 4B 2B            [ 1] 1701 	push	#0x2b
      0007C0 CDr00rA8         [ 4] 1702 	call	_write_spi_buf
      0007C3 5B 04            [ 2] 1703 	addw	sp, #4
                                   1704 ;	se8r01.c: 563: write_spi_buf(WRITE_REG + RX_ADDR_P2, ADDRESS2, 1); 
      0007C5 AEr00r0E         [ 2] 1705 	ldw	x, #_ADDRESS2+0
      0007C8 4B 01            [ 1] 1706 	push	#0x01
      0007CA 89               [ 2] 1707 	pushw	x
      0007CB 4B 2C            [ 1] 1708 	push	#0x2c
      0007CD CDr00rA8         [ 4] 1709 	call	_write_spi_buf
      0007D0 5B 04            [ 2] 1710 	addw	sp, #4
                                   1711 ;	se8r01.c: 564: write_spi_buf(WRITE_REG + RX_ADDR_P3, ADDRESS3, 1); 
      0007D2 AEr00r0F         [ 2] 1712 	ldw	x, #_ADDRESS3+0
      0007D5 4B 01            [ 1] 1713 	push	#0x01
      0007D7 89               [ 2] 1714 	pushw	x
      0007D8 4B 2D            [ 1] 1715 	push	#0x2d
      0007DA CDr00rA8         [ 4] 1716 	call	_write_spi_buf
      0007DD 5B 04            [ 2] 1717 	addw	sp, #4
                                   1718 ;	se8r01.c: 565: write_spi_buf(WRITE_REG + RX_ADDR_P4, ADDRESS4, 1); 
      0007DF AEr00r10         [ 2] 1719 	ldw	x, #_ADDRESS4+0
      0007E2 4B 01            [ 1] 1720 	push	#0x01
      0007E4 89               [ 2] 1721 	pushw	x
      0007E5 4B 2E            [ 1] 1722 	push	#0x2e
      0007E7 CDr00rA8         [ 4] 1723 	call	_write_spi_buf
      0007EA 5B 04            [ 2] 1724 	addw	sp, #4
                                   1725 ;	se8r01.c: 566: write_spi_buf(WRITE_REG + RX_ADDR_P5, ADDRESS5, 1); 
      0007EC AEr00r11         [ 2] 1726 	ldw	x, #_ADDRESS5+0
      0007EF 4B 01            [ 1] 1727 	push	#0x01
      0007F1 89               [ 2] 1728 	pushw	x
      0007F2 4B 2F            [ 1] 1729 	push	#0x2f
      0007F4 CDr00rA8         [ 4] 1730 	call	_write_spi_buf
      0007F7 5B 04            [ 2] 1731 	addw	sp, #4
                                   1732 ;	se8r01.c: 567: write_spi_reg(WRITE_REG + RX_PW_P0, PLOAD_WIDTH); 
      0007F9 4B 20            [ 1] 1733 	push	#0x20
      0007FB 4B 31            [ 1] 1734 	push	#0x31
      0007FD CDr00r2E         [ 4] 1735 	call	_write_spi_reg
      000800 5B 02            [ 2] 1736 	addw	sp, #2
                                   1737 ;	se8r01.c: 568: write_spi_reg(WRITE_REG|iRF_BANK0_CONFIG, 0x3f); 
      000802 4B 3F            [ 1] 1738 	push	#0x3f
      000804 4B 20            [ 1] 1739 	push	#0x20
      000806 CDr00r2E         [ 4] 1740 	call	_write_spi_reg
      000809 5B 02            [ 2] 1741 	addw	sp, #2
                                   1742 ;	se8r01.c: 569: write_spi_reg(WRITE_REG|iRF_BANK0_DYNPD, 0b00111111);          // enable dynamic payload length data
      00080B 4B 3F            [ 1] 1743 	push	#0x3f
      00080D 4B 3C            [ 1] 1744 	push	#0x3c
      00080F CDr00r2E         [ 4] 1745 	call	_write_spi_reg
      000812 5B 02            [ 2] 1746 	addw	sp, #2
                                   1747 ;	se8r01.c: 570: write_spi_reg(WRITE_REG|iRF_BANK0_FEATURE, 0x07);        // enable dynamic paload lenght; enbale payload with ack enable w_tx_payload_noack
      000814 4B 07            [ 1] 1748 	push	#0x07
      000816 4B 3D            [ 1] 1749 	push	#0x3d
      000818 CDr00r2E         [ 4] 1750 	call	_write_spi_reg
      00081B 5B 02            [ 2] 1751 	addw	sp, #2
                                   1752 ;	se8r01.c: 574: PC_ODR |= (1 << CE);
      00081D AE 50 0A         [ 2] 1753 	ldw	x, #0x500a
      000820 F6               [ 1] 1754 	ld	a, (x)
      000821 AA 10            [ 1] 1755 	or	a, #0x10
      000823 F7               [ 1] 1756 	ld	(x), a
      000824 5B 05            [ 2] 1757 	addw	sp, #5
      000826 81               [ 4] 1758 	ret
                                   1759 ;	se8r01.c: 714: int main () {
                                   1760 ;	-----------------------------------------
                                   1761 ;	 function main
                                   1762 ;	-----------------------------------------
      000827                       1763 _main:
      000827 52 3A            [ 2] 1764 	sub	sp, #58
                                   1765 ;	se8r01.c: 718: UCHAR rx_addr_p1[]  = { 0xd2, 0xf0, 0xf0, 0xf0, 0xf0 };
      000829 90 96            [ 1] 1766 	ldw	y, sp
      00082B 72 A9 00 2A      [ 2] 1767 	addw	y, #42
      00082F A6 D2            [ 1] 1768 	ld	a, #0xd2
      000831 90 F7            [ 1] 1769 	ld	(y), a
      000833 93               [ 1] 1770 	ldw	x, y
      000834 5C               [ 2] 1771 	incw	x
      000835 A6 F0            [ 1] 1772 	ld	a, #0xf0
      000837 F7               [ 1] 1773 	ld	(x), a
      000838 93               [ 1] 1774 	ldw	x, y
      000839 5C               [ 2] 1775 	incw	x
      00083A 5C               [ 2] 1776 	incw	x
      00083B A6 F0            [ 1] 1777 	ld	a, #0xf0
      00083D F7               [ 1] 1778 	ld	(x), a
      00083E 93               [ 1] 1779 	ldw	x, y
      00083F A6 F0            [ 1] 1780 	ld	a, #0xf0
      000841 E7 03            [ 1] 1781 	ld	(0x0003, x), a
      000843 93               [ 1] 1782 	ldw	x, y
      000844 A6 F0            [ 1] 1783 	ld	a, #0xf0
      000846 E7 04            [ 1] 1784 	ld	(0x0004, x), a
                                   1785 ;	se8r01.c: 719: UCHAR tx_addr[]     = { 0xe1, 0xf0, 0xf0, 0xf0, 0xf0 };
      000848 90 96            [ 1] 1786 	ldw	y, sp
      00084A 72 A9 00 2F      [ 2] 1787 	addw	y, #47
      00084E A6 E1            [ 1] 1788 	ld	a, #0xe1
      000850 90 F7            [ 1] 1789 	ld	(y), a
      000852 93               [ 1] 1790 	ldw	x, y
      000853 5C               [ 2] 1791 	incw	x
      000854 A6 F0            [ 1] 1792 	ld	a, #0xf0
      000856 F7               [ 1] 1793 	ld	(x), a
      000857 93               [ 1] 1794 	ldw	x, y
      000858 5C               [ 2] 1795 	incw	x
      000859 5C               [ 2] 1796 	incw	x
      00085A A6 F0            [ 1] 1797 	ld	a, #0xf0
      00085C F7               [ 1] 1798 	ld	(x), a
      00085D 93               [ 1] 1799 	ldw	x, y
      00085E A6 F0            [ 1] 1800 	ld	a, #0xf0
      000860 E7 03            [ 1] 1801 	ld	(0x0003, x), a
      000862 93               [ 1] 1802 	ldw	x, y
      000863 1C 00 04         [ 2] 1803 	addw	x, #0x0004
      000866 A6 F0            [ 1] 1804 	ld	a, #0xf0
      000868 F7               [ 1] 1805 	ld	(x), a
                                   1806 ;	se8r01.c: 723: InitializeSystemClock();
      000869 CDr01r44         [ 4] 1807 	call	_InitializeSystemClock
                                   1808 ;	se8r01.c: 724: InitializeUART();
      00086C CDr03r44         [ 4] 1809 	call	_InitializeUART
                                   1810 ;	se8r01.c: 725: InitializeI2C();
      00086F CDr03r11         [ 4] 1811 	call	_InitializeI2C
                                   1812 ;	se8r01.c: 726: InitializeSPI ();
      000872 CDr01r1C         [ 4] 1813 	call	_InitializeSPI
                                   1814 ;	se8r01.c: 744: init_io();                        // Initialize IO port
      000875 CDr03rBD         [ 4] 1815 	call	_init_io
                                   1816 ;	se8r01.c: 745: SE8R01_Init();
      000878 CDr07r41         [ 4] 1817 	call	_SE8R01_Init
                                   1818 ;	se8r01.c: 746: write_spi_reg(FLUSH_RX,0);
      00087B 4B 00            [ 1] 1819 	push	#0x00
      00087D 4B E2            [ 1] 1820 	push	#0xe2
      00087F CDr00r2E         [ 4] 1821 	call	_write_spi_reg
      000882 5B 02            [ 2] 1822 	addw	sp, #2
                                   1823 ;	se8r01.c: 747: readstatus = read_spi_reg(CONFIG);
      000884 4B 00            [ 1] 1824 	push	#0x00
      000886 CDr00r6A         [ 4] 1825 	call	_read_spi_reg
      000889 5B 01            [ 2] 1826 	addw	sp, #1
                                   1827 ;	se8r01.c: 748: UARTPrintF("config = \n\r");
      00088B AEr09rAD         [ 2] 1828 	ldw	x, #___str_0+0
      00088E 1F 34            [ 2] 1829 	ldw	(0x34, sp), x
      000890 1E 34            [ 2] 1830 	ldw	x, (0x34, sp)
      000892 88               [ 1] 1831 	push	a
      000893 89               [ 2] 1832 	pushw	x
      000894 CDr02r6C         [ 4] 1833 	call	_UARTPrintF
      000897 5B 02            [ 2] 1834 	addw	sp, #2
      000899 84               [ 1] 1835 	pop	a
                                   1836 ;	se8r01.c: 749: print_UCHAR_hex(readstatus);
      00089A 88               [ 1] 1837 	push	a
      00089B CDr02r83         [ 4] 1838 	call	_print_UCHAR_hex
      00089E 84               [ 1] 1839 	pop	a
                                   1840 ;	se8r01.c: 750: readstatus = read_spi_reg(STATUS);
      00089F 4B 07            [ 1] 1841 	push	#0x07
      0008A1 CDr00r6A         [ 4] 1842 	call	_read_spi_reg
      0008A4 5B 01            [ 2] 1843 	addw	sp, #1
      0008A6 6B 3A            [ 1] 1844 	ld	(0x3a, sp), a
                                   1845 ;	se8r01.c: 751: UARTPrintF("status = \n\r");
      0008A8 AEr09rB9         [ 2] 1846 	ldw	x, #___str_1+0
      0008AB 1F 38            [ 2] 1847 	ldw	(0x38, sp), x
      0008AD 1E 38            [ 2] 1848 	ldw	x, (0x38, sp)
      0008AF 89               [ 2] 1849 	pushw	x
      0008B0 CDr02r6C         [ 4] 1850 	call	_UARTPrintF
      0008B3 5B 02            [ 2] 1851 	addw	sp, #2
                                   1852 ;	se8r01.c: 752: print_UCHAR_hex(readstatus);
      0008B5 7B 3A            [ 1] 1853 	ld	a, (0x3a, sp)
      0008B7 88               [ 1] 1854 	push	a
      0008B8 CDr02r83         [ 4] 1855 	call	_print_UCHAR_hex
      0008BB 84               [ 1] 1856 	pop	a
                                   1857 ;	se8r01.c: 757: while (1) {
      0008BC                       1858 00111$:
                                   1859 ;	se8r01.c: 764: tx_payload[0] = 0xf0;
      0008BC 96               [ 1] 1860 	ldw	x, sp
      0008BD 1C 00 09         [ 2] 1861 	addw	x, #9
      0008C0 1F 36            [ 2] 1862 	ldw	(0x36, sp), x
      0008C2 1E 36            [ 2] 1863 	ldw	x, (0x36, sp)
      0008C4 A6 F0            [ 1] 1864 	ld	a, #0xf0
      0008C6 F7               [ 1] 1865 	ld	(x), a
                                   1866 ;	se8r01.c: 765: tx_payload[1] = 0x01;
      0008C7 1E 36            [ 2] 1867 	ldw	x, (0x36, sp)
      0008C9 5C               [ 2] 1868 	incw	x
      0008CA A6 01            [ 1] 1869 	ld	a, #0x01
      0008CC F7               [ 1] 1870 	ld	(x), a
                                   1871 ;	se8r01.c: 773: delayTenMicro();
      0008CD CDr00r00         [ 4] 1872 	call	_delayTenMicro
                                   1873 ;	se8r01.c: 774: PC_ODR |= (1 << CE);
      0008D0 AE 50 0A         [ 2] 1874 	ldw	x, #0x500a
      0008D3 F6               [ 1] 1875 	ld	a, (x)
      0008D4 AA 10            [ 1] 1876 	or	a, #0x10
      0008D6 F7               [ 1] 1877 	ld	(x), a
                                   1878 ;	se8r01.c: 775: delayTenMicro();
      0008D7 CDr00r00         [ 4] 1879 	call	_delayTenMicro
                                   1880 ;	se8r01.c: 776: PC_ODR &= ~(1 << CE);
      0008DA AE 50 0A         [ 2] 1881 	ldw	x, #0x500a
      0008DD F6               [ 1] 1882 	ld	a, (x)
      0008DE A4 EF            [ 1] 1883 	and	a, #0xef
      0008E0 F7               [ 1] 1884 	ld	(x), a
                                   1885 ;	se8r01.c: 781: PD_DDR |= ~(1 << 5); // input mode
      0008E1 AE 50 11         [ 2] 1886 	ldw	x, #0x5011
      0008E4 F6               [ 1] 1887 	ld	a, (x)
      0008E5 AA DF            [ 1] 1888 	or	a, #0xdf
      0008E7 F7               [ 1] 1889 	ld	(x), a
                                   1890 ;	se8r01.c: 782: PD_CR1 |= (1 << 5); // input with pull up
      0008E8 AE 50 12         [ 2] 1891 	ldw	x, #0x5012
      0008EB F6               [ 1] 1892 	ld	a, (x)
      0008EC AA 20            [ 1] 1893 	or	a, #0x20
      0008EE F7               [ 1] 1894 	ld	(x), a
                                   1895 ;	se8r01.c: 783: PD_CR2 &= ~(1 << 5); // interrupt disabled
      0008EF AE 50 13         [ 2] 1896 	ldw	x, #0x5013
      0008F2 F6               [ 1] 1897 	ld	a, (x)
      0008F3 A4 DF            [ 1] 1898 	and	a, #0xdf
      0008F5 F7               [ 1] 1899 	ld	(x), a
                                   1900 ;	se8r01.c: 787: if ((PD_IDR & 0b00001000) == 0b00001000)
      0008F6 AE 50 10         [ 2] 1901 	ldw	x, #0x5010
      0008F9 F6               [ 1] 1902 	ld	a, (x)
      0008FA A4 08            [ 1] 1903 	and	a, #0x08
      0008FC A1 08            [ 1] 1904 	cp	a, #0x08
      0008FE 26 3C            [ 1] 1905 	jrne	00105$
                                   1906 ;	se8r01.c: 789: UARTPrintF("interrupt low = \n\r");
      000900 AEr09rC5         [ 2] 1907 	ldw	x, #___str_2+0
      000903 9F               [ 1] 1908 	ld	a, xl
      000904 89               [ 2] 1909 	pushw	x
      000905 CDr02r6C         [ 4] 1910 	call	_UARTPrintF
      000908 5B 02            [ 2] 1911 	addw	sp, #2
                                   1912 ;	se8r01.c: 791: if(     ( readstatus & (RX_DR | TX_DS | MAX_RT) ) != 0  ){
      00090A 7B 3A            [ 1] 1913 	ld	a, (0x3a, sp)
      00090C A5 70            [ 1] 1914 	bcp	a, #0x70
      00090E 27 35            [ 1] 1915 	jreq	00106$
                                   1916 ;	se8r01.c: 792: read_spi_buf(RD_RX_PLOAD, tx_payload, 1);
      000910 1E 36            [ 2] 1917 	ldw	x, (0x36, sp)
      000912 4B 01            [ 1] 1918 	push	#0x01
      000914 89               [ 2] 1919 	pushw	x
      000915 4B 61            [ 1] 1920 	push	#0x61
      000917 CDr00rE0         [ 4] 1921 	call	_read_spi_buf
      00091A 5B 04            [ 2] 1922 	addw	sp, #4
                                   1923 ;	se8r01.c: 793: for(i=0;i<32;i++) print_UCHAR_hex(tx_payload[i]); 
      00091C 5F               [ 1] 1924 	clrw	x
      00091D                       1925 00113$:
      00091D 90 93            [ 1] 1926 	ldw	y, x
      00091F 72 F9 36         [ 2] 1927 	addw	y, (0x36, sp)
      000922 90 F6            [ 1] 1928 	ld	a, (y)
      000924 89               [ 2] 1929 	pushw	x
      000925 88               [ 1] 1930 	push	a
      000926 CDr02r83         [ 4] 1931 	call	_print_UCHAR_hex
      000929 84               [ 1] 1932 	pop	a
      00092A 85               [ 2] 1933 	popw	x
      00092B 5C               [ 2] 1934 	incw	x
      00092C A3 00 20         [ 2] 1935 	cpw	x, #0x0020
      00092F 2F EC            [ 1] 1936 	jrslt	00113$
                                   1937 ;	se8r01.c: 794: UARTPrintF("data \n\r");
      000931 AEr09rD8         [ 2] 1938 	ldw	x, #___str_3+0
      000934 89               [ 2] 1939 	pushw	x
      000935 CDr02r6C         [ 4] 1940 	call	_UARTPrintF
      000938 5B 02            [ 2] 1941 	addw	sp, #2
      00093A 20 09            [ 2] 1942 	jra	00106$
      00093C                       1943 00105$:
                                   1944 ;	se8r01.c: 799: UARTPrintF("interrupt high = \n\r");
      00093C AEr09rE0         [ 2] 1945 	ldw	x, #___str_4+0
      00093F 89               [ 2] 1946 	pushw	x
      000940 CDr02r6C         [ 4] 1947 	call	_UARTPrintF
      000943 5B 02            [ 2] 1948 	addw	sp, #2
      000945                       1949 00106$:
                                   1950 ;	se8r01.c: 802: for (x1 = 0; x1 < 50; ++x1)
      000945 5F               [ 1] 1951 	clrw	x
      000946 1F 05            [ 2] 1952 	ldw	(0x05, sp), x
      000948                       1953 00122$:
      000948 1E 05            [ 2] 1954 	ldw	x, (0x05, sp)
      00094A A3 00 32         [ 2] 1955 	cpw	x, #0x0032
      00094D 2E 2A            [ 1] 1956 	jrsge	00109$
                                   1957 ;	se8r01.c: 803: for (y1 = 0; y1 < 50; ++y1)
      00094F 5F               [ 1] 1958 	clrw	x
      000950 1F 03            [ 2] 1959 	ldw	(0x03, sp), x
      000952                       1960 00119$:
      000952 1E 03            [ 2] 1961 	ldw	x, (0x03, sp)
      000954 A3 00 32         [ 2] 1962 	cpw	x, #0x0032
      000957 2E 19            [ 1] 1963 	jrsge	00123$
                                   1964 ;	se8r01.c: 804: for (z1 = 0; z1 < 50; ++z1)
      000959 5F               [ 1] 1965 	clrw	x
      00095A 1F 01            [ 2] 1966 	ldw	(0x01, sp), x
      00095C                       1967 00116$:
      00095C 1E 01            [ 2] 1968 	ldw	x, (0x01, sp)
      00095E A3 00 32         [ 2] 1969 	cpw	x, #0x0032
      000961 2E 08            [ 1] 1970 	jrsge	00120$
                                   1971 ;	se8r01.c: 805: __asm__("nop");
      000963 9D               [ 1] 1972 	nop
                                   1973 ;	se8r01.c: 804: for (z1 = 0; z1 < 50; ++z1)
      000964 1E 01            [ 2] 1974 	ldw	x, (0x01, sp)
      000966 5C               [ 2] 1975 	incw	x
      000967 1F 01            [ 2] 1976 	ldw	(0x01, sp), x
      000969 20 F1            [ 2] 1977 	jra	00116$
      00096B                       1978 00120$:
                                   1979 ;	se8r01.c: 803: for (y1 = 0; y1 < 50; ++y1)
      00096B 1E 03            [ 2] 1980 	ldw	x, (0x03, sp)
      00096D 5C               [ 2] 1981 	incw	x
      00096E 1F 03            [ 2] 1982 	ldw	(0x03, sp), x
      000970 20 E0            [ 2] 1983 	jra	00119$
      000972                       1984 00123$:
                                   1985 ;	se8r01.c: 802: for (x1 = 0; x1 < 50; ++x1)
      000972 1E 05            [ 2] 1986 	ldw	x, (0x05, sp)
      000974 5C               [ 2] 1987 	incw	x
      000975 1F 05            [ 2] 1988 	ldw	(0x05, sp), x
      000977 20 CF            [ 2] 1989 	jra	00122$
      000979                       1990 00109$:
                                   1991 ;	se8r01.c: 807: readstatus = read_spi_reg(CONFIG);
      000979 4B 00            [ 1] 1992 	push	#0x00
      00097B CDr00r6A         [ 4] 1993 	call	_read_spi_reg
      00097E 5B 01            [ 2] 1994 	addw	sp, #1
                                   1995 ;	se8r01.c: 808: UARTPrintF("config = \n\r");
      000980 1E 34            [ 2] 1996 	ldw	x, (0x34, sp)
      000982 88               [ 1] 1997 	push	a
      000983 89               [ 2] 1998 	pushw	x
      000984 CDr02r6C         [ 4] 1999 	call	_UARTPrintF
      000987 5B 02            [ 2] 2000 	addw	sp, #2
      000989 84               [ 1] 2001 	pop	a
                                   2002 ;	se8r01.c: 809: print_UCHAR_hex(readstatus);
      00098A 88               [ 1] 2003 	push	a
      00098B CDr02r83         [ 4] 2004 	call	_print_UCHAR_hex
      00098E 84               [ 1] 2005 	pop	a
                                   2006 ;	se8r01.c: 810: readstatus = read_spi_reg(STATUS);
      00098F 4B 07            [ 1] 2007 	push	#0x07
      000991 CDr00r6A         [ 4] 2008 	call	_read_spi_reg
      000994 5B 01            [ 2] 2009 	addw	sp, #1
      000996 6B 3A            [ 1] 2010 	ld	(0x3a, sp), a
                                   2011 ;	se8r01.c: 811: UARTPrintF("status = \n\r");
      000998 1E 38            [ 2] 2012 	ldw	x, (0x38, sp)
      00099A 89               [ 2] 2013 	pushw	x
      00099B CDr02r6C         [ 4] 2014 	call	_UARTPrintF
      00099E 5B 02            [ 2] 2015 	addw	sp, #2
                                   2016 ;	se8r01.c: 812: print_UCHAR_hex(readstatus);
      0009A0 7B 3A            [ 1] 2017 	ld	a, (0x3a, sp)
      0009A2 88               [ 1] 2018 	push	a
      0009A3 CDr02r83         [ 4] 2019 	call	_print_UCHAR_hex
      0009A6 84               [ 1] 2020 	pop	a
      0009A7 CCr08rBC         [ 2] 2021 	jp	00111$
      0009AA 5B 3A            [ 2] 2022 	addw	sp, #58
      0009AC 81               [ 4] 2023 	ret
                                   2024 	.area CODE
      0009AD                       2025 ___str_0:
      0009AD 63 6F 6E 66 69 67 20  2026 	.ascii "config = "
             3D 20
      0009B6 0A                    2027 	.db 0x0A
      0009B7 0D                    2028 	.db 0x0D
      0009B8 00                    2029 	.db 0x00
      0009B9                       2030 ___str_1:
      0009B9 73 74 61 74 75 73 20  2031 	.ascii "status = "
             3D 20
      0009C2 0A                    2032 	.db 0x0A
      0009C3 0D                    2033 	.db 0x0D
      0009C4 00                    2034 	.db 0x00
      0009C5                       2035 ___str_2:
      0009C5 69 6E 74 65 72 72 75  2036 	.ascii "interrupt low = "
             70 74 20 6C 6F 77 20
             3D 20
      0009D5 0A                    2037 	.db 0x0A
      0009D6 0D                    2038 	.db 0x0D
      0009D7 00                    2039 	.db 0x00
      0009D8                       2040 ___str_3:
      0009D8 64 61 74 61 20        2041 	.ascii "data "
      0009DD 0A                    2042 	.db 0x0A
      0009DE 0D                    2043 	.db 0x0D
      0009DF 00                    2044 	.db 0x00
      0009E0                       2045 ___str_4:
      0009E0 69 6E 74 65 72 72 75  2046 	.ascii "interrupt high = "
             70 74 20 68 69 67 68
             20 3D 20
      0009F1 0A                    2047 	.db 0x0A
      0009F2 0D                    2048 	.db 0x0D
      0009F3 00                    2049 	.db 0x00
                                   2050 	.area INITIALIZER
      000000                       2051 __xinit__SE8R01_DR_2M:
      000000 00 00                 2052 	.dw #0x0000
      000002                       2053 __xinit__SE8R01_DR_1M:
      000002 00 00                 2054 	.dw #0x0000
      000004                       2055 __xinit__SE8R01_DR_500K:
      000004 00 01                 2056 	.dw #0x0001
      000006                       2057 __xinit__pload_width_now:
      000006 00 00                 2058 	.dw #0x0000
      000008                       2059 __xinit__newdata:
      000008 00 00                 2060 	.dw #0x0000
      00000A                       2061 __xinit__signal_lv:
      00000A 00                    2062 	.db #0x00	;  0
      00000B                       2063 __xinit__pip:
      00000B 00 00                 2064 	.dw #0x0000
      00000D                       2065 __xinit__status:
      00000D 00                    2066 	.db #0x00	; 0
      00000E                       2067 __xinit__ADDRESS2:
      00000E B1                    2068 	.db #0xB1	; 177
      00000F                       2069 __xinit__ADDRESS3:
      00000F B2                    2070 	.db #0xB2	; 178
      000010                       2071 __xinit__ADDRESS4:
      000010 B3                    2072 	.db #0xB3	; 179
      000011                       2073 __xinit__ADDRESS5:
      000011 B4                    2074 	.db #0xB4	; 180
      000012                       2075 __xinit__ADDRESS1:
      000012 B0                    2076 	.db #0xB0	; 176
      000013 43                    2077 	.db #0x43	; 67	'C'
      000014 10                    2078 	.db #0x10	; 16
      000015 10                    2079 	.db #0x10	; 16
      000016                       2080 __xinit__ADDRESS0:
      000016 34                    2081 	.db #0x34	; 52	'4'
      000017 43                    2082 	.db #0x43	; 67	'C'
      000018 10                    2083 	.db #0x10	; 16
      000019 10                    2084 	.db #0x10	; 16
      00001A                       2085 __xinit__rx_buf:
      00001A 00                    2086 	.db #0x00	; 0
      00001B 00                    2087 	.db 0x00
      00001C 00                    2088 	.db 0x00
      00001D 00                    2089 	.db 0x00
      00001E 00                    2090 	.db 0x00
      00001F 00                    2091 	.db 0x00
      000020 00                    2092 	.db 0x00
      000021 00                    2093 	.db 0x00
      000022 00                    2094 	.db 0x00
      000023 00                    2095 	.db 0x00
      000024 00                    2096 	.db 0x00
      000025 00                    2097 	.db 0x00
      000026 00                    2098 	.db 0x00
      000027 00                    2099 	.db 0x00
      000028 00                    2100 	.db 0x00
      000029 00                    2101 	.db 0x00
      00002A 00                    2102 	.db 0x00
      00002B 00                    2103 	.db 0x00
      00002C 00                    2104 	.db 0x00
      00002D 00                    2105 	.db 0x00
      00002E 00                    2106 	.db 0x00
      00002F 00                    2107 	.db 0x00
      000030 00                    2108 	.db 0x00
      000031 00                    2109 	.db 0x00
      000032 00                    2110 	.db 0x00
      000033 00                    2111 	.db 0x00
      000034 00                    2112 	.db 0x00
      000035 00                    2113 	.db 0x00
      000036 00                    2114 	.db 0x00
      000037 00                    2115 	.db 0x00
      000038 00                    2116 	.db 0x00
      000039 00                    2117 	.db 0x00
      00003A                       2118 __xinit__tx_buf:
      00003A 00                    2119 	.db #0x00	; 0
      00003B 00                    2120 	.db 0x00
      00003C 00                    2121 	.db 0x00
      00003D 00                    2122 	.db 0x00
      00003E 00                    2123 	.db 0x00
      00003F 00                    2124 	.db 0x00
      000040 00                    2125 	.db 0x00
      000041 00                    2126 	.db 0x00
      000042 00                    2127 	.db 0x00
      000043 00                    2128 	.db 0x00
      000044 00                    2129 	.db 0x00
      000045 00                    2130 	.db 0x00
      000046 00                    2131 	.db 0x00
      000047 00                    2132 	.db 0x00
      000048 00                    2133 	.db 0x00
      000049 00                    2134 	.db 0x00
      00004A 00                    2135 	.db 0x00
      00004B 00                    2136 	.db 0x00
      00004C 00                    2137 	.db 0x00
      00004D 00                    2138 	.db 0x00
      00004E 00                    2139 	.db 0x00
      00004F 00                    2140 	.db 0x00
      000050 00                    2141 	.db 0x00
      000051 00                    2142 	.db 0x00
      000052 00                    2143 	.db 0x00
      000053 00                    2144 	.db 0x00
      000054 00                    2145 	.db 0x00
      000055 00                    2146 	.db 0x00
      000056 00                    2147 	.db 0x00
      000057 00                    2148 	.db 0x00
      000058 00                    2149 	.db 0x00
      000059 00                    2150 	.db 0x00
                                   2151 	.area CABS (ABS)
