                                      1 ;--------------------------------------------------------
                                      2 ; File Created by SDCC : free open source ANSI-C Compiler
                                      3 ; Version 3.4.0 #8981 (Jul 11 2014) (Linux)
                                      4 ; This file was generated Wed May  3 08:56:15 2017
                                      5 ;--------------------------------------------------------
                                      6 	.module se8r01
                                      7 	.optsdcc -mstm8
                                      8 	
                                      9 ;--------------------------------------------------------
                                     10 ; Public variables in this module
                                     11 ;--------------------------------------------------------
                                     12 	.globl _main
                                     13 	.globl _SE8R01_Init
                                     14 	.globl _SE8R01_Analog_Init
                                     15 	.globl _SE8R01_Calibration
                                     16 	.globl _rf_switch_bank
                                     17 	.globl _init_io
                                     18 	.globl _InitializeUART
                                     19 	.globl _InitializeI2C
                                     20 	.globl _i2c_read_register
                                     21 	.globl _print_UCHAR_hex
                                     22 	.globl _UARTPrintF
                                     23 	.globl _i2c_set_start_ack
                                     24 	.globl _i2c_send_address
                                     25 	.globl _i2c_send_reg
                                     26 	.globl _i2c_set_stop
                                     27 	.globl _i2c_set_nak
                                     28 	.globl _i2c_read
                                     29 	.globl _delay
                                     30 	.globl _InitializeSystemClock
                                     31 	.globl _InitializeSPI
                                     32 	.globl _read_spi_buf
                                     33 	.globl _write_spi_buf
                                     34 	.globl _read_spi_reg
                                     35 	.globl _write_spi_reg
                                     36 	.globl _write_spi
                                     37 	.globl _delayTenMicro
                                     38 	.globl _tx_buf
                                     39 	.globl _rx_buf
                                     40 	.globl _ADDRESS0
                                     41 	.globl _ADDRESS1
                                     42 	.globl _ADDRESS5
                                     43 	.globl _ADDRESS4
                                     44 	.globl _ADDRESS3
                                     45 	.globl _ADDRESS2
                                     46 	.globl _status
                                     47 	.globl _pip
                                     48 	.globl _signal_lv
                                     49 	.globl _newdata
                                     50 	.globl _pload_width_now
                                     51 	.globl _SE8R01_DR_500K
                                     52 	.globl _SE8R01_DR_1M
                                     53 	.globl _SE8R01_DR_2M
                                     54 	.globl _myData_pip4
                                     55 	.globl _myData_pip5
                                     56 	.globl _gtemp
                                     57 ;--------------------------------------------------------
                                     58 ; ram data
                                     59 ;--------------------------------------------------------
                                     60 	.area DATA
      000001                         61 _gtemp::
      000001                         62 	.ds 5
      000006                         63 _myData_pip5::
      000006                         64 	.ds 5
      00000B                         65 _myData_pip4::
      00000B                         66 	.ds 5
                                     67 ;--------------------------------------------------------
                                     68 ; ram data
                                     69 ;--------------------------------------------------------
                                     70 	.area INITIALIZED
      000010                         71 _SE8R01_DR_2M::
      000010                         72 	.ds 2
      000012                         73 _SE8R01_DR_1M::
      000012                         74 	.ds 2
      000014                         75 _SE8R01_DR_500K::
      000014                         76 	.ds 2
      000016                         77 _pload_width_now::
      000016                         78 	.ds 2
      000018                         79 _newdata::
      000018                         80 	.ds 2
      00001A                         81 _signal_lv::
      00001A                         82 	.ds 1
      00001B                         83 _pip::
      00001B                         84 	.ds 2
      00001D                         85 _status::
      00001D                         86 	.ds 1
      00001E                         87 _ADDRESS2::
      00001E                         88 	.ds 1
      00001F                         89 _ADDRESS3::
      00001F                         90 	.ds 1
      000020                         91 _ADDRESS4::
      000020                         92 	.ds 1
      000021                         93 _ADDRESS5::
      000021                         94 	.ds 1
      000022                         95 _ADDRESS1::
      000022                         96 	.ds 4
      000026                         97 _ADDRESS0::
      000026                         98 	.ds 4
      00002A                         99 _rx_buf::
      00002A                        100 	.ds 32
      00004A                        101 _tx_buf::
      00004A                        102 	.ds 32
                                    103 ;--------------------------------------------------------
                                    104 ; Stack segment in internal ram 
                                    105 ;--------------------------------------------------------
                                    106 	.area	SSEG
      000000                        107 __start__stack:
      000000                        108 	.ds	1
                                    109 
                                    110 ;--------------------------------------------------------
                                    111 ; absolute external ram data
                                    112 ;--------------------------------------------------------
                                    113 	.area DABS (ABS)
                                    114 ;--------------------------------------------------------
                                    115 ; interrupt vector 
                                    116 ;--------------------------------------------------------
                                    117 	.area HOME
      008000                        118 __interrupt_vect:
      008000 82 00 80 83            119 	int s_GSINIT ;reset
      008004 82 00 00 00            120 	int 0x0000 ;trap
      008008 82 00 00 00            121 	int 0x0000 ;int0
      00800C 82 00 00 00            122 	int 0x0000 ;int1
      008010 82 00 00 00            123 	int 0x0000 ;int2
      008014 82 00 00 00            124 	int 0x0000 ;int3
      008018 82 00 00 00            125 	int 0x0000 ;int4
      00801C 82 00 00 00            126 	int 0x0000 ;int5
      008020 82 00 00 00            127 	int 0x0000 ;int6
      008024 82 00 00 00            128 	int 0x0000 ;int7
      008028 82 00 00 00            129 	int 0x0000 ;int8
      00802C 82 00 00 00            130 	int 0x0000 ;int9
      008030 82 00 00 00            131 	int 0x0000 ;int10
      008034 82 00 00 00            132 	int 0x0000 ;int11
      008038 82 00 00 00            133 	int 0x0000 ;int12
      00803C 82 00 00 00            134 	int 0x0000 ;int13
      008040 82 00 00 00            135 	int 0x0000 ;int14
      008044 82 00 00 00            136 	int 0x0000 ;int15
      008048 82 00 00 00            137 	int 0x0000 ;int16
      00804C 82 00 00 00            138 	int 0x0000 ;int17
      008050 82 00 00 00            139 	int 0x0000 ;int18
      008054 82 00 00 00            140 	int 0x0000 ;int19
      008058 82 00 00 00            141 	int 0x0000 ;int20
      00805C 82 00 00 00            142 	int 0x0000 ;int21
      008060 82 00 00 00            143 	int 0x0000 ;int22
      008064 82 00 00 00            144 	int 0x0000 ;int23
      008068 82 00 00 00            145 	int 0x0000 ;int24
      00806C 82 00 00 00            146 	int 0x0000 ;int25
      008070 82 00 00 00            147 	int 0x0000 ;int26
      008074 82 00 00 00            148 	int 0x0000 ;int27
      008078 82 00 00 00            149 	int 0x0000 ;int28
      00807C 82 00 00 00            150 	int 0x0000 ;int29
                                    151 ;--------------------------------------------------------
                                    152 ; global & static initialisations
                                    153 ;--------------------------------------------------------
                                    154 	.area HOME
                                    155 	.area GSINIT
                                    156 	.area GSFINAL
                                    157 	.area GSINIT
      008083                        158 __sdcc_gs_init_startup:
      008083                        159 __sdcc_init_data:
                                    160 ; stm8_genXINIT() start
      008083 AE 00 0F         [ 2]  161 	ldw x, #l_DATA
      008086 27 07            [ 1]  162 	jreq	00002$
      008088                        163 00001$:
      008088 72 4F 00 00      [ 1]  164 	clr (s_DATA - 1, x)
      00808C 5A               [ 2]  165 	decw x
      00808D 26 F9            [ 1]  166 	jrne	00001$
      00808F                        167 00002$:
      00808F AE 00 5A         [ 2]  168 	ldw	x, #l_INITIALIZER
      008092 27 09            [ 1]  169 	jreq	00004$
      008094                        170 00003$:
      008094 D6 8A E9         [ 1]  171 	ld	a, (s_INITIALIZER - 1, x)
      008097 D7 00 0F         [ 1]  172 	ld	(s_INITIALIZED - 1, x), a
      00809A 5A               [ 2]  173 	decw	x
      00809B 26 F7            [ 1]  174 	jrne	00003$
      00809D                        175 00004$:
                                    176 ; stm8_genXINIT() end
                                    177 	.area GSFINAL
      00809D CC 80 80         [ 2]  178 	jp	__sdcc_program_startup
                                    179 ;--------------------------------------------------------
                                    180 ; Home
                                    181 ;--------------------------------------------------------
                                    182 	.area HOME
                                    183 	.area HOME
      008080                        184 __sdcc_program_startup:
      008080 CC 88 C7         [ 2]  185 	jp	_main
                                    186 ;	return from main will return to caller
                                    187 ;--------------------------------------------------------
                                    188 ; code
                                    189 ;--------------------------------------------------------
                                    190 	.area CODE
                                    191 ;	se8r01.c: 27: void delayTenMicro (void) {
                                    192 ;	-----------------------------------------
                                    193 ;	 function delayTenMicro
                                    194 ;	-----------------------------------------
      0080A0                        195 _delayTenMicro:
                                    196 ;	se8r01.c: 29: for (a = 0; a < 50; ++a)
      0080A0 A6 32            [ 1]  197 	ld	a, #0x32
      0080A2                        198 00104$:
                                    199 ;	se8r01.c: 30: __asm__("nop");
      0080A2 9D               [ 1]  200 	nop
      0080A3 4A               [ 1]  201 	dec	a
                                    202 ;	se8r01.c: 29: for (a = 0; a < 50; ++a)
      0080A4 4D               [ 1]  203 	tnz	a
      0080A5 26 FB            [ 1]  204 	jrne	00104$
      0080A7 81               [ 4]  205 	ret
                                    206 ;	se8r01.c: 32: UCHAR write_spi (UCHAR value) {
                                    207 ;	-----------------------------------------
                                    208 ;	 function write_spi
                                    209 ;	-----------------------------------------
      0080A8                        210 _write_spi:
                                    211 ;	se8r01.c: 34: delayTenMicro ();
      0080A8 CD 80 A0         [ 4]  212 	call	_delayTenMicro
                                    213 ;	se8r01.c: 35: SPI_DR = value;
      0080AB AE 52 04         [ 2]  214 	ldw	x, #0x5204
      0080AE 7B 03            [ 1]  215 	ld	a, (0x03, sp)
      0080B0 F7               [ 1]  216 	ld	(x), a
                                    217 ;	se8r01.c: 36: delayTenMicro ();
      0080B1 CD 80 A0         [ 4]  218 	call	_delayTenMicro
                                    219 ;	se8r01.c: 37: while ((SPI_SR & TXE) == 0);
      0080B4                        220 00101$:
      0080B4 AE 52 03         [ 2]  221 	ldw	x, #0x5203
      0080B7 F6               [ 1]  222 	ld	a, (x)
      0080B8 A5 02            [ 1]  223 	bcp	a, #0x02
      0080BA 27 F8            [ 1]  224 	jreq	00101$
                                    225 ;	se8r01.c: 38: delayTenMicro ();
      0080BC CD 80 A0         [ 4]  226 	call	_delayTenMicro
                                    227 ;	se8r01.c: 39: while ((SPI_SR & RXNE) == 0);
      0080BF                        228 00104$:
      0080BF AE 52 03         [ 2]  229 	ldw	x, #0x5203
      0080C2 F6               [ 1]  230 	ld	a, (x)
      0080C3 44               [ 1]  231 	srl	a
      0080C4 24 F9            [ 1]  232 	jrnc	00104$
                                    233 ;	se8r01.c: 40: delayTenMicro ();
      0080C6 CD 80 A0         [ 4]  234 	call	_delayTenMicro
                                    235 ;	se8r01.c: 41: ret = SPI_DR;
      0080C9 AE 52 04         [ 2]  236 	ldw	x, #0x5204
      0080CC F6               [ 1]  237 	ld	a, (x)
                                    238 ;	se8r01.c: 42: return (ret);
      0080CD 81               [ 4]  239 	ret
                                    240 ;	se8r01.c: 44: UCHAR write_spi_reg (UCHAR reg, UCHAR value) {
                                    241 ;	-----------------------------------------
                                    242 ;	 function write_spi_reg
                                    243 ;	-----------------------------------------
      0080CE                        244 _write_spi_reg:
      0080CE 88               [ 1]  245 	push	a
                                    246 ;	se8r01.c: 46: PC_ODR &= ~(1 << CSN);
      0080CF AE 50 0A         [ 2]  247 	ldw	x, #0x500a
      0080D2 F6               [ 1]  248 	ld	a, (x)
      0080D3 A4 F7            [ 1]  249 	and	a, #0xf7
      0080D5 F7               [ 1]  250 	ld	(x), a
                                    251 ;	se8r01.c: 47: ret = write_spi (reg);
      0080D6 7B 04            [ 1]  252 	ld	a, (0x04, sp)
      0080D8 88               [ 1]  253 	push	a
      0080D9 CD 80 A8         [ 4]  254 	call	_write_spi
      0080DC 5B 01            [ 2]  255 	addw	sp, #1
      0080DE 6B 01            [ 1]  256 	ld	(0x01, sp), a
                                    257 ;	se8r01.c: 48: if (reg != NOP && reg != FLUSH_RX && reg != FLUSH_TX)
      0080E0 7B 04            [ 1]  258 	ld	a, (0x04, sp)
      0080E2 A1 FF            [ 1]  259 	cp	a, #0xff
      0080E4 27 15            [ 1]  260 	jreq	00102$
      0080E6 7B 04            [ 1]  261 	ld	a, (0x04, sp)
      0080E8 A1 E2            [ 1]  262 	cp	a, #0xe2
      0080EA 27 0F            [ 1]  263 	jreq	00102$
      0080EC 7B 04            [ 1]  264 	ld	a, (0x04, sp)
      0080EE A1 E1            [ 1]  265 	cp	a, #0xe1
      0080F0 27 09            [ 1]  266 	jreq	00102$
                                    267 ;	se8r01.c: 49: write_spi (value);
      0080F2 7B 05            [ 1]  268 	ld	a, (0x05, sp)
      0080F4 88               [ 1]  269 	push	a
      0080F5 CD 80 A8         [ 4]  270 	call	_write_spi
      0080F8 84               [ 1]  271 	pop	a
      0080F9 20 03            [ 2]  272 	jra	00103$
      0080FB                        273 00102$:
                                    274 ;	se8r01.c: 51: delayTenMicro ();
      0080FB CD 80 A0         [ 4]  275 	call	_delayTenMicro
      0080FE                        276 00103$:
                                    277 ;	se8r01.c: 52: PC_ODR |= (1 << CSN);
      0080FE AE 50 0A         [ 2]  278 	ldw	x, #0x500a
      008101 F6               [ 1]  279 	ld	a, (x)
      008102 AA 08            [ 1]  280 	or	a, #0x08
      008104 F7               [ 1]  281 	ld	(x), a
                                    282 ;	se8r01.c: 53: return (ret);
      008105 7B 01            [ 1]  283 	ld	a, (0x01, sp)
      008107 5B 01            [ 2]  284 	addw	sp, #1
      008109 81               [ 4]  285 	ret
                                    286 ;	se8r01.c: 55: UCHAR read_spi_reg (UCHAR reg) {
                                    287 ;	-----------------------------------------
                                    288 ;	 function read_spi_reg
                                    289 ;	-----------------------------------------
      00810A                        290 _read_spi_reg:
      00810A 88               [ 1]  291 	push	a
                                    292 ;	se8r01.c: 57: PC_ODR &= ~(1 << CSN);
      00810B AE 50 0A         [ 2]  293 	ldw	x, #0x500a
      00810E F6               [ 1]  294 	ld	a, (x)
      00810F A4 F7            [ 1]  295 	and	a, #0xf7
      008111 F7               [ 1]  296 	ld	(x), a
                                    297 ;	se8r01.c: 58: ret = write_spi (reg);
      008112 7B 04            [ 1]  298 	ld	a, (0x04, sp)
      008114 88               [ 1]  299 	push	a
      008115 CD 80 A8         [ 4]  300 	call	_write_spi
      008118 5B 01            [ 2]  301 	addw	sp, #1
      00811A 6B 01            [ 1]  302 	ld	(0x01, sp), a
                                    303 ;	se8r01.c: 59: if (reg != NOP && reg != FLUSH_RX && reg != FLUSH_TX)
      00811C 7B 04            [ 1]  304 	ld	a, (0x04, sp)
      00811E A1 FF            [ 1]  305 	cp	a, #0xff
      008120 27 17            [ 1]  306 	jreq	00102$
      008122 7B 04            [ 1]  307 	ld	a, (0x04, sp)
      008124 A1 E2            [ 1]  308 	cp	a, #0xe2
      008126 27 11            [ 1]  309 	jreq	00102$
      008128 7B 04            [ 1]  310 	ld	a, (0x04, sp)
      00812A A1 E1            [ 1]  311 	cp	a, #0xe1
      00812C 27 0B            [ 1]  312 	jreq	00102$
                                    313 ;	se8r01.c: 60: ret = write_spi (NOP);
      00812E 4B FF            [ 1]  314 	push	#0xff
      008130 CD 80 A8         [ 4]  315 	call	_write_spi
      008133 5B 01            [ 2]  316 	addw	sp, #1
      008135 6B 01            [ 1]  317 	ld	(0x01, sp), a
      008137 20 03            [ 2]  318 	jra	00103$
      008139                        319 00102$:
                                    320 ;	se8r01.c: 62: delayTenMicro ();
      008139 CD 80 A0         [ 4]  321 	call	_delayTenMicro
      00813C                        322 00103$:
                                    323 ;	se8r01.c: 63: PC_ODR |= (1 << CSN);
      00813C AE 50 0A         [ 2]  324 	ldw	x, #0x500a
      00813F F6               [ 1]  325 	ld	a, (x)
      008140 AA 08            [ 1]  326 	or	a, #0x08
      008142 F7               [ 1]  327 	ld	(x), a
                                    328 ;	se8r01.c: 64: return (ret);
      008143 7B 01            [ 1]  329 	ld	a, (0x01, sp)
      008145 5B 01            [ 2]  330 	addw	sp, #1
      008147 81               [ 4]  331 	ret
                                    332 ;	se8r01.c: 66: UCHAR write_spi_buf (UCHAR reg, UCHAR *array, UCHAR len) {
                                    333 ;	-----------------------------------------
                                    334 ;	 function write_spi_buf
                                    335 ;	-----------------------------------------
      008148                        336 _write_spi_buf:
      008148 52 02            [ 2]  337 	sub	sp, #2
                                    338 ;	se8r01.c: 68: PC_ODR &= ~(1 << CSN);
      00814A AE 50 0A         [ 2]  339 	ldw	x, #0x500a
      00814D F6               [ 1]  340 	ld	a, (x)
      00814E A4 F7            [ 1]  341 	and	a, #0xf7
      008150 F7               [ 1]  342 	ld	(x), a
                                    343 ;	se8r01.c: 69: ret = write_spi (reg);
      008151 7B 05            [ 1]  344 	ld	a, (0x05, sp)
      008153 88               [ 1]  345 	push	a
      008154 CD 80 A8         [ 4]  346 	call	_write_spi
      008157 5B 01            [ 2]  347 	addw	sp, #1
      008159 6B 02            [ 1]  348 	ld	(0x02, sp), a
                                    349 ;	se8r01.c: 70: for (n = 0; n < len; ++n)
      00815B 0F 01            [ 1]  350 	clr	(0x01, sp)
      00815D                        351 00103$:
      00815D 7B 01            [ 1]  352 	ld	a, (0x01, sp)
      00815F 11 08            [ 1]  353 	cp	a, (0x08, sp)
      008161 24 11            [ 1]  354 	jrnc	00101$
                                    355 ;	se8r01.c: 71: write_spi (array[n]);
      008163 5F               [ 1]  356 	clrw	x
      008164 7B 01            [ 1]  357 	ld	a, (0x01, sp)
      008166 97               [ 1]  358 	ld	xl, a
      008167 72 FB 06         [ 2]  359 	addw	x, (0x06, sp)
      00816A F6               [ 1]  360 	ld	a, (x)
      00816B 88               [ 1]  361 	push	a
      00816C CD 80 A8         [ 4]  362 	call	_write_spi
      00816F 84               [ 1]  363 	pop	a
                                    364 ;	se8r01.c: 70: for (n = 0; n < len; ++n)
      008170 0C 01            [ 1]  365 	inc	(0x01, sp)
      008172 20 E9            [ 2]  366 	jra	00103$
      008174                        367 00101$:
                                    368 ;	se8r01.c: 72: PC_ODR |= (1 << CSN);
      008174 AE 50 0A         [ 2]  369 	ldw	x, #0x500a
      008177 F6               [ 1]  370 	ld	a, (x)
      008178 AA 08            [ 1]  371 	or	a, #0x08
      00817A F7               [ 1]  372 	ld	(x), a
                                    373 ;	se8r01.c: 73: return (ret);
      00817B 7B 02            [ 1]  374 	ld	a, (0x02, sp)
      00817D 5B 02            [ 2]  375 	addw	sp, #2
      00817F 81               [ 4]  376 	ret
                                    377 ;	se8r01.c: 75: UCHAR read_spi_buf (UCHAR reg, UCHAR *array, UCHAR len) {
                                    378 ;	-----------------------------------------
                                    379 ;	 function read_spi_buf
                                    380 ;	-----------------------------------------
      008180                        381 _read_spi_buf:
      008180 52 02            [ 2]  382 	sub	sp, #2
                                    383 ;	se8r01.c: 77: PC_ODR &= ~(1 << CSN);
      008182 AE 50 0A         [ 2]  384 	ldw	x, #0x500a
      008185 F6               [ 1]  385 	ld	a, (x)
      008186 A4 F7            [ 1]  386 	and	a, #0xf7
      008188 F7               [ 1]  387 	ld	(x), a
                                    388 ;	se8r01.c: 78: ret = write_spi (reg);
      008189 7B 05            [ 1]  389 	ld	a, (0x05, sp)
      00818B 88               [ 1]  390 	push	a
      00818C CD 80 A8         [ 4]  391 	call	_write_spi
      00818F 5B 01            [ 2]  392 	addw	sp, #1
      008191 6B 01            [ 1]  393 	ld	(0x01, sp), a
                                    394 ;	se8r01.c: 79: for (n = 0; n < len; ++n)
      008193 0F 02            [ 1]  395 	clr	(0x02, sp)
      008195                        396 00103$:
      008195 7B 02            [ 1]  397 	ld	a, (0x02, sp)
      008197 11 08            [ 1]  398 	cp	a, (0x08, sp)
      008199 24 15            [ 1]  399 	jrnc	00101$
                                    400 ;	se8r01.c: 80: array[n] = write_spi (NOP);
      00819B 5F               [ 1]  401 	clrw	x
      00819C 7B 02            [ 1]  402 	ld	a, (0x02, sp)
      00819E 97               [ 1]  403 	ld	xl, a
      00819F 72 FB 06         [ 2]  404 	addw	x, (0x06, sp)
      0081A2 89               [ 2]  405 	pushw	x
      0081A3 4B FF            [ 1]  406 	push	#0xff
      0081A5 CD 80 A8         [ 4]  407 	call	_write_spi
      0081A8 5B 01            [ 2]  408 	addw	sp, #1
      0081AA 85               [ 2]  409 	popw	x
      0081AB F7               [ 1]  410 	ld	(x), a
                                    411 ;	se8r01.c: 79: for (n = 0; n < len; ++n)
      0081AC 0C 02            [ 1]  412 	inc	(0x02, sp)
      0081AE 20 E5            [ 2]  413 	jra	00103$
      0081B0                        414 00101$:
                                    415 ;	se8r01.c: 81: PC_ODR |= (1 << CSN);
      0081B0 AE 50 0A         [ 2]  416 	ldw	x, #0x500a
      0081B3 F6               [ 1]  417 	ld	a, (x)
      0081B4 AA 08            [ 1]  418 	or	a, #0x08
      0081B6 F7               [ 1]  419 	ld	(x), a
                                    420 ;	se8r01.c: 82: return (ret);
      0081B7 7B 01            [ 1]  421 	ld	a, (0x01, sp)
      0081B9 5B 02            [ 2]  422 	addw	sp, #2
      0081BB 81               [ 4]  423 	ret
                                    424 ;	se8r01.c: 84: void InitializeSPI () {
                                    425 ;	-----------------------------------------
                                    426 ;	 function InitializeSPI
                                    427 ;	-----------------------------------------
      0081BC                        428 _InitializeSPI:
                                    429 ;	se8r01.c: 85: SPI_CR1 = MSBFIRST | SPI_ENABLE | BR_DIV256 | MASTER | CPOL0 | CPHA0;
      0081BC AE 52 00         [ 2]  430 	ldw	x, #0x5200
      0081BF A6 7C            [ 1]  431 	ld	a, #0x7c
      0081C1 F7               [ 1]  432 	ld	(x), a
                                    433 ;	se8r01.c: 86: SPI_CR2 = BDM_2LINE | CRCEN_OFF | CRCNEXT_TXBUF | FULL_DUPLEX | SSM_DISABLE;
      0081C2 AE 52 01         [ 2]  434 	ldw	x, #0x5201
      0081C5 7F               [ 1]  435 	clr	(x)
                                    436 ;	se8r01.c: 87: SPI_ICR = TXIE_MASKED | RXIE_MASKED | ERRIE_MASKED | WKIE_MASKED;
      0081C6 AE 52 02         [ 2]  437 	ldw	x, #0x5202
      0081C9 7F               [ 1]  438 	clr	(x)
                                    439 ;	se8r01.c: 88: PC_DDR = (1 << PC3) | (1 << PC4); // output mode
      0081CA AE 50 0C         [ 2]  440 	ldw	x, #0x500c
      0081CD A6 18            [ 1]  441 	ld	a, #0x18
      0081CF F7               [ 1]  442 	ld	(x), a
                                    443 ;	se8r01.c: 89: PC_CR1 = (1 << PC3) | (1 << PC4); // push-pull
      0081D0 AE 50 0D         [ 2]  444 	ldw	x, #0x500d
      0081D3 A6 18            [ 1]  445 	ld	a, #0x18
      0081D5 F7               [ 1]  446 	ld	(x), a
                                    447 ;	se8r01.c: 90: PC_CR2 = (1 << PC3) | (1 << PC4); // up to 10MHz speed
      0081D6 AE 50 0E         [ 2]  448 	ldw	x, #0x500e
      0081D9 A6 18            [ 1]  449 	ld	a, #0x18
      0081DB F7               [ 1]  450 	ld	(x), a
                                    451 ;	se8r01.c: 92: PC_ODR &= ~(1 << CE);
      0081DC AE 50 0A         [ 2]  452 	ldw	x, #0x500a
      0081DF F6               [ 1]  453 	ld	a, (x)
      0081E0 A4 EF            [ 1]  454 	and	a, #0xef
      0081E2 F7               [ 1]  455 	ld	(x), a
      0081E3 81               [ 4]  456 	ret
                                    457 ;	se8r01.c: 94: void InitializeSystemClock() {
                                    458 ;	-----------------------------------------
                                    459 ;	 function InitializeSystemClock
                                    460 ;	-----------------------------------------
      0081E4                        461 _InitializeSystemClock:
                                    462 ;	se8r01.c: 95: CLK_ICKR = 0;                       //  Reset the Internal Clock Register.
      0081E4 AE 50 C0         [ 2]  463 	ldw	x, #0x50c0
      0081E7 7F               [ 1]  464 	clr	(x)
                                    465 ;	se8r01.c: 96: CLK_ICKR = CLK_HSIEN;               //  Enable the HSI.
      0081E8 AE 50 C0         [ 2]  466 	ldw	x, #0x50c0
      0081EB A6 01            [ 1]  467 	ld	a, #0x01
      0081ED F7               [ 1]  468 	ld	(x), a
                                    469 ;	se8r01.c: 97: CLK_ECKR = 0;                       //  Disable the external clock.
      0081EE AE 50 C1         [ 2]  470 	ldw	x, #0x50c1
      0081F1 7F               [ 1]  471 	clr	(x)
                                    472 ;	se8r01.c: 98: while ((CLK_ICKR & CLK_HSIRDY) == 0);       //  Wait for the HSI to be ready for use.
      0081F2                        473 00101$:
      0081F2 AE 50 C0         [ 2]  474 	ldw	x, #0x50c0
      0081F5 F6               [ 1]  475 	ld	a, (x)
      0081F6 A5 02            [ 1]  476 	bcp	a, #0x02
      0081F8 27 F8            [ 1]  477 	jreq	00101$
                                    478 ;	se8r01.c: 99: CLK_CKDIVR = 0;                     //  Ensure the clocks are running at full speed.
      0081FA AE 50 C6         [ 2]  479 	ldw	x, #0x50c6
      0081FD 7F               [ 1]  480 	clr	(x)
                                    481 ;	se8r01.c: 100: CLK_PCKENR1 = 0xff;                 //  Enable all peripheral clocks.
      0081FE AE 50 C7         [ 2]  482 	ldw	x, #0x50c7
      008201 A6 FF            [ 1]  483 	ld	a, #0xff
      008203 F7               [ 1]  484 	ld	(x), a
                                    485 ;	se8r01.c: 101: CLK_PCKENR2 = 0xff;                 //  Ditto.
      008204 AE 50 CA         [ 2]  486 	ldw	x, #0x50ca
      008207 A6 FF            [ 1]  487 	ld	a, #0xff
      008209 F7               [ 1]  488 	ld	(x), a
                                    489 ;	se8r01.c: 102: CLK_CCOR = 0;                       //  Turn off CCO.
      00820A AE 50 C9         [ 2]  490 	ldw	x, #0x50c9
      00820D 7F               [ 1]  491 	clr	(x)
                                    492 ;	se8r01.c: 103: CLK_HSITRIMR = 0;                   //  Turn off any HSIU trimming.
      00820E AE 50 CC         [ 2]  493 	ldw	x, #0x50cc
      008211 7F               [ 1]  494 	clr	(x)
                                    495 ;	se8r01.c: 104: CLK_SWIMCCR = 0;                    //  Set SWIM to run at clock / 2.
      008212 AE 50 CD         [ 2]  496 	ldw	x, #0x50cd
      008215 7F               [ 1]  497 	clr	(x)
                                    498 ;	se8r01.c: 105: CLK_SWR = 0xe1;                     //  Use HSI as the clock source.
      008216 AE 50 C4         [ 2]  499 	ldw	x, #0x50c4
      008219 A6 E1            [ 1]  500 	ld	a, #0xe1
      00821B F7               [ 1]  501 	ld	(x), a
                                    502 ;	se8r01.c: 106: CLK_SWCR = 0;                       //  Reset the clock switch control register.
      00821C AE 50 C5         [ 2]  503 	ldw	x, #0x50c5
      00821F 7F               [ 1]  504 	clr	(x)
                                    505 ;	se8r01.c: 107: CLK_SWCR = CLK_SWEN;                //  Enable switching.
      008220 AE 50 C5         [ 2]  506 	ldw	x, #0x50c5
      008223 A6 02            [ 1]  507 	ld	a, #0x02
      008225 F7               [ 1]  508 	ld	(x), a
                                    509 ;	se8r01.c: 108: while ((CLK_SWCR & CLK_SWBSY) != 0);        //  Pause while the clock switch is busy.
      008226                        510 00104$:
      008226 AE 50 C5         [ 2]  511 	ldw	x, #0x50c5
      008229 F6               [ 1]  512 	ld	a, (x)
      00822A 44               [ 1]  513 	srl	a
      00822B 25 F9            [ 1]  514 	jrc	00104$
      00822D 81               [ 4]  515 	ret
                                    516 ;	se8r01.c: 110: void delay (int time_ms) {
                                    517 ;	-----------------------------------------
                                    518 ;	 function delay
                                    519 ;	-----------------------------------------
      00822E                        520 _delay:
      00822E 52 0A            [ 2]  521 	sub	sp, #10
                                    522 ;	se8r01.c: 112: for (x = 0; x < 1036*time_ms; ++x)
      008230 5F               [ 1]  523 	clrw	x
      008231 1F 03            [ 2]  524 	ldw	(0x03, sp), x
      008233 1F 01            [ 2]  525 	ldw	(0x01, sp), x
      008235 1E 0D            [ 2]  526 	ldw	x, (0x0d, sp)
      008237 89               [ 2]  527 	pushw	x
      008238 4B 0C            [ 1]  528 	push	#0x0c
      00823A 4B 04            [ 1]  529 	push	#0x04
      00823C CD 8A 94         [ 4]  530 	call	__mulint
      00823F 5B 04            [ 2]  531 	addw	sp, #4
      008241 1F 09            [ 2]  532 	ldw	(0x09, sp), x
      008243                        533 00103$:
      008243 16 09            [ 2]  534 	ldw	y, (0x09, sp)
      008245 17 07            [ 2]  535 	ldw	(0x07, sp), y
      008247 7B 07            [ 1]  536 	ld	a, (0x07, sp)
      008249 49               [ 1]  537 	rlc	a
      00824A 4F               [ 1]  538 	clr	a
      00824B A2 00            [ 1]  539 	sbc	a, #0x00
      00824D 6B 06            [ 1]  540 	ld	(0x06, sp), a
      00824F 6B 05            [ 1]  541 	ld	(0x05, sp), a
      008251 1E 03            [ 2]  542 	ldw	x, (0x03, sp)
      008253 13 07            [ 2]  543 	cpw	x, (0x07, sp)
      008255 7B 02            [ 1]  544 	ld	a, (0x02, sp)
      008257 12 06            [ 1]  545 	sbc	a, (0x06, sp)
      008259 7B 01            [ 1]  546 	ld	a, (0x01, sp)
      00825B 12 05            [ 1]  547 	sbc	a, (0x05, sp)
      00825D 2E 17            [ 1]  548 	jrsge	00105$
                                    549 ;	se8r01.c: 113: __asm__("nop");
      00825F 9D               [ 1]  550 	nop
                                    551 ;	se8r01.c: 112: for (x = 0; x < 1036*time_ms; ++x)
      008260 16 03            [ 2]  552 	ldw	y, (0x03, sp)
      008262 72 A9 00 01      [ 2]  553 	addw	y, #0x0001
      008266 7B 02            [ 1]  554 	ld	a, (0x02, sp)
      008268 A9 00            [ 1]  555 	adc	a, #0x00
      00826A 97               [ 1]  556 	ld	xl, a
      00826B 7B 01            [ 1]  557 	ld	a, (0x01, sp)
      00826D A9 00            [ 1]  558 	adc	a, #0x00
      00826F 95               [ 1]  559 	ld	xh, a
      008270 17 03            [ 2]  560 	ldw	(0x03, sp), y
      008272 1F 01            [ 2]  561 	ldw	(0x01, sp), x
      008274 20 CD            [ 2]  562 	jra	00103$
      008276                        563 00105$:
      008276 5B 0A            [ 2]  564 	addw	sp, #10
      008278 81               [ 4]  565 	ret
                                    566 ;	se8r01.c: 115: void i2c_read (unsigned char *x) {
                                    567 ;	-----------------------------------------
                                    568 ;	 function i2c_read
                                    569 ;	-----------------------------------------
      008279                        570 _i2c_read:
                                    571 ;	se8r01.c: 116: while ((I2C_SR1 & I2C_RXNE) == 0);
      008279                        572 00101$:
      008279 AE 52 17         [ 2]  573 	ldw	x, #0x5217
      00827C F6               [ 1]  574 	ld	a, (x)
      00827D A5 40            [ 1]  575 	bcp	a, #0x40
      00827F 27 F8            [ 1]  576 	jreq	00101$
                                    577 ;	se8r01.c: 117: *x = I2C_DR;
      008281 16 03            [ 2]  578 	ldw	y, (0x03, sp)
      008283 AE 52 16         [ 2]  579 	ldw	x, #0x5216
      008286 F6               [ 1]  580 	ld	a, (x)
      008287 90 F7            [ 1]  581 	ld	(y), a
      008289 81               [ 4]  582 	ret
                                    583 ;	se8r01.c: 119: void i2c_set_nak (void) {
                                    584 ;	-----------------------------------------
                                    585 ;	 function i2c_set_nak
                                    586 ;	-----------------------------------------
      00828A                        587 _i2c_set_nak:
                                    588 ;	se8r01.c: 120: I2C_CR2 &= ~I2C_ACK;
      00828A AE 52 11         [ 2]  589 	ldw	x, #0x5211
      00828D F6               [ 1]  590 	ld	a, (x)
      00828E A4 FB            [ 1]  591 	and	a, #0xfb
      008290 F7               [ 1]  592 	ld	(x), a
      008291 81               [ 4]  593 	ret
                                    594 ;	se8r01.c: 122: void i2c_set_stop (void) {
                                    595 ;	-----------------------------------------
                                    596 ;	 function i2c_set_stop
                                    597 ;	-----------------------------------------
      008292                        598 _i2c_set_stop:
                                    599 ;	se8r01.c: 123: I2C_CR2 |= I2C_STOP;
      008292 AE 52 11         [ 2]  600 	ldw	x, #0x5211
      008295 F6               [ 1]  601 	ld	a, (x)
      008296 AA 02            [ 1]  602 	or	a, #0x02
      008298 F7               [ 1]  603 	ld	(x), a
      008299 81               [ 4]  604 	ret
                                    605 ;	se8r01.c: 125: void i2c_send_reg (UCHAR addr) {
                                    606 ;	-----------------------------------------
                                    607 ;	 function i2c_send_reg
                                    608 ;	-----------------------------------------
      00829A                        609 _i2c_send_reg:
      00829A 52 02            [ 2]  610 	sub	sp, #2
                                    611 ;	se8r01.c: 127: reg = I2C_SR1;
      00829C AE 52 17         [ 2]  612 	ldw	x, #0x5217
      00829F F6               [ 1]  613 	ld	a, (x)
      0082A0 5F               [ 1]  614 	clrw	x
      0082A1 97               [ 1]  615 	ld	xl, a
      0082A2 1F 01            [ 2]  616 	ldw	(0x01, sp), x
                                    617 ;	se8r01.c: 128: reg = I2C_SR3;
      0082A4 AE 52 19         [ 2]  618 	ldw	x, #0x5219
      0082A7 F6               [ 1]  619 	ld	a, (x)
      0082A8 5F               [ 1]  620 	clrw	x
      0082A9 97               [ 1]  621 	ld	xl, a
      0082AA 1F 01            [ 2]  622 	ldw	(0x01, sp), x
                                    623 ;	se8r01.c: 129: I2C_DR = addr;
      0082AC AE 52 16         [ 2]  624 	ldw	x, #0x5216
      0082AF 7B 05            [ 1]  625 	ld	a, (0x05, sp)
      0082B1 F7               [ 1]  626 	ld	(x), a
                                    627 ;	se8r01.c: 130: while ((I2C_SR1 & I2C_TXE) == 0);
      0082B2                        628 00101$:
      0082B2 AE 52 17         [ 2]  629 	ldw	x, #0x5217
      0082B5 F6               [ 1]  630 	ld	a, (x)
      0082B6 48               [ 1]  631 	sll	a
      0082B7 24 F9            [ 1]  632 	jrnc	00101$
      0082B9 5B 02            [ 2]  633 	addw	sp, #2
      0082BB 81               [ 4]  634 	ret
                                    635 ;	se8r01.c: 132: void i2c_send_address (UCHAR addr, UCHAR mode) {
                                    636 ;	-----------------------------------------
                                    637 ;	 function i2c_send_address
                                    638 ;	-----------------------------------------
      0082BC                        639 _i2c_send_address:
      0082BC 52 03            [ 2]  640 	sub	sp, #3
                                    641 ;	se8r01.c: 134: reg = I2C_SR1;
      0082BE AE 52 17         [ 2]  642 	ldw	x, #0x5217
      0082C1 F6               [ 1]  643 	ld	a, (x)
      0082C2 5F               [ 1]  644 	clrw	x
      0082C3 97               [ 1]  645 	ld	xl, a
      0082C4 1F 01            [ 2]  646 	ldw	(0x01, sp), x
                                    647 ;	se8r01.c: 135: I2C_DR = (addr << 1) | mode;
      0082C6 7B 06            [ 1]  648 	ld	a, (0x06, sp)
      0082C8 48               [ 1]  649 	sll	a
      0082C9 1A 07            [ 1]  650 	or	a, (0x07, sp)
      0082CB AE 52 16         [ 2]  651 	ldw	x, #0x5216
      0082CE F7               [ 1]  652 	ld	(x), a
                                    653 ;	se8r01.c: 136: if (mode == I2C_READ) {
      0082CF 7B 07            [ 1]  654 	ld	a, (0x07, sp)
      0082D1 A1 01            [ 1]  655 	cp	a, #0x01
      0082D3 26 06            [ 1]  656 	jrne	00127$
      0082D5 A6 01            [ 1]  657 	ld	a, #0x01
      0082D7 6B 03            [ 1]  658 	ld	(0x03, sp), a
      0082D9 20 02            [ 2]  659 	jra	00128$
      0082DB                        660 00127$:
      0082DB 0F 03            [ 1]  661 	clr	(0x03, sp)
      0082DD                        662 00128$:
      0082DD 0D 03            [ 1]  663 	tnz	(0x03, sp)
      0082DF 27 08            [ 1]  664 	jreq	00103$
                                    665 ;	se8r01.c: 137: I2C_OARL = 0;
      0082E1 AE 52 13         [ 2]  666 	ldw	x, #0x5213
      0082E4 7F               [ 1]  667 	clr	(x)
                                    668 ;	se8r01.c: 138: I2C_OARH = 0;
      0082E5 AE 52 14         [ 2]  669 	ldw	x, #0x5214
      0082E8 7F               [ 1]  670 	clr	(x)
                                    671 ;	se8r01.c: 140: while ((I2C_SR1 & I2C_ADDR) == 0);
      0082E9                        672 00103$:
                                    673 ;	se8r01.c: 134: reg = I2C_SR1;
      0082E9 AE 52 17         [ 2]  674 	ldw	x, #0x5217
      0082EC F6               [ 1]  675 	ld	a, (x)
                                    676 ;	se8r01.c: 140: while ((I2C_SR1 & I2C_ADDR) == 0);
      0082ED A5 02            [ 1]  677 	bcp	a, #0x02
      0082EF 27 F8            [ 1]  678 	jreq	00103$
                                    679 ;	se8r01.c: 141: if (mode == I2C_READ)
      0082F1 0D 03            [ 1]  680 	tnz	(0x03, sp)
      0082F3 27 06            [ 1]  681 	jreq	00108$
                                    682 ;	se8r01.c: 142: UNSET (I2C_SR1, I2C_ADDR);
      0082F5 A4 FD            [ 1]  683 	and	a, #0xfd
      0082F7 AE 52 17         [ 2]  684 	ldw	x, #0x5217
      0082FA F7               [ 1]  685 	ld	(x), a
      0082FB                        686 00108$:
      0082FB 5B 03            [ 2]  687 	addw	sp, #3
      0082FD 81               [ 4]  688 	ret
                                    689 ;	se8r01.c: 144: void i2c_set_start_ack (void) {
                                    690 ;	-----------------------------------------
                                    691 ;	 function i2c_set_start_ack
                                    692 ;	-----------------------------------------
      0082FE                        693 _i2c_set_start_ack:
                                    694 ;	se8r01.c: 145: I2C_CR2 = I2C_ACK | I2C_START;
      0082FE AE 52 11         [ 2]  695 	ldw	x, #0x5211
      008301 A6 05            [ 1]  696 	ld	a, #0x05
      008303 F7               [ 1]  697 	ld	(x), a
                                    698 ;	se8r01.c: 146: while ((I2C_SR1 & I2C_SB) == 0);
      008304                        699 00101$:
      008304 AE 52 17         [ 2]  700 	ldw	x, #0x5217
      008307 F6               [ 1]  701 	ld	a, (x)
      008308 44               [ 1]  702 	srl	a
      008309 24 F9            [ 1]  703 	jrnc	00101$
      00830B 81               [ 4]  704 	ret
                                    705 ;	se8r01.c: 151: void UARTPrintF (char *message) {
                                    706 ;	-----------------------------------------
                                    707 ;	 function UARTPrintF
                                    708 ;	-----------------------------------------
      00830C                        709 _UARTPrintF:
                                    710 ;	se8r01.c: 152: char *ch = message;
      00830C 16 03            [ 2]  711 	ldw	y, (0x03, sp)
                                    712 ;	se8r01.c: 153: while (*ch) {
      00830E                        713 00104$:
      00830E 90 F6            [ 1]  714 	ld	a, (y)
      008310 4D               [ 1]  715 	tnz	a
      008311 27 0F            [ 1]  716 	jreq	00107$
                                    717 ;	se8r01.c: 154: UART1_DR = (unsigned char) *ch;     //  Put the next character into the data transmission register.
      008313 AE 52 31         [ 2]  718 	ldw	x, #0x5231
      008316 F7               [ 1]  719 	ld	(x), a
                                    720 ;	se8r01.c: 155: while ((UART1_SR & SR_TXE) == 0);   //  Wait for transmission to complete.
      008317                        721 00101$:
      008317 AE 52 30         [ 2]  722 	ldw	x, #0x5230
      00831A F6               [ 1]  723 	ld	a, (x)
      00831B 48               [ 1]  724 	sll	a
      00831C 24 F9            [ 1]  725 	jrnc	00101$
                                    726 ;	se8r01.c: 156: ch++;                               //  Grab the next character.
      00831E 90 5C            [ 2]  727 	incw	y
      008320 20 EC            [ 2]  728 	jra	00104$
      008322                        729 00107$:
      008322 81               [ 4]  730 	ret
                                    731 ;	se8r01.c: 159: void print_UCHAR_hex (unsigned char buffer) {
                                    732 ;	-----------------------------------------
                                    733 ;	 function print_UCHAR_hex
                                    734 ;	-----------------------------------------
      008323                        735 _print_UCHAR_hex:
      008323 52 0C            [ 2]  736 	sub	sp, #12
                                    737 ;	se8r01.c: 162: a = (buffer >> 4);
      008325 7B 0F            [ 1]  738 	ld	a, (0x0f, sp)
      008327 4E               [ 1]  739 	swap	a
      008328 A4 0F            [ 1]  740 	and	a, #0x0f
      00832A 5F               [ 1]  741 	clrw	x
      00832B 97               [ 1]  742 	ld	xl, a
                                    743 ;	se8r01.c: 163: if (a > 9)
      00832C A3 00 09         [ 2]  744 	cpw	x, #0x0009
      00832F 2D 07            [ 1]  745 	jrsle	00102$
                                    746 ;	se8r01.c: 164: a = a + 'a' - 10;
      008331 1C 00 57         [ 2]  747 	addw	x, #0x0057
      008334 1F 0B            [ 2]  748 	ldw	(0x0b, sp), x
      008336 20 05            [ 2]  749 	jra	00103$
      008338                        750 00102$:
                                    751 ;	se8r01.c: 166: a += '0'; 
      008338 1C 00 30         [ 2]  752 	addw	x, #0x0030
      00833B 1F 0B            [ 2]  753 	ldw	(0x0b, sp), x
      00833D                        754 00103$:
                                    755 ;	se8r01.c: 167: b = buffer & 0x0f;
      00833D 7B 0F            [ 1]  756 	ld	a, (0x0f, sp)
      00833F A4 0F            [ 1]  757 	and	a, #0x0f
      008341 5F               [ 1]  758 	clrw	x
      008342 97               [ 1]  759 	ld	xl, a
                                    760 ;	se8r01.c: 168: if (b > 9)
      008343 A3 00 09         [ 2]  761 	cpw	x, #0x0009
      008346 2D 07            [ 1]  762 	jrsle	00105$
                                    763 ;	se8r01.c: 169: b = b + 'a' - 10;
      008348 1C 00 57         [ 2]  764 	addw	x, #0x0057
      00834B 1F 09            [ 2]  765 	ldw	(0x09, sp), x
      00834D 20 05            [ 2]  766 	jra	00106$
      00834F                        767 00105$:
                                    768 ;	se8r01.c: 171: b += '0'; 
      00834F 1C 00 30         [ 2]  769 	addw	x, #0x0030
      008352 1F 09            [ 2]  770 	ldw	(0x09, sp), x
      008354                        771 00106$:
                                    772 ;	se8r01.c: 172: message[0] = a;
      008354 90 96            [ 1]  773 	ldw	y, sp
      008356 90 5C            [ 2]  774 	incw	y
      008358 7B 0C            [ 1]  775 	ld	a, (0x0c, sp)
      00835A 90 F7            [ 1]  776 	ld	(y), a
                                    777 ;	se8r01.c: 173: message[1] = b;
      00835C 93               [ 1]  778 	ldw	x, y
      00835D 5C               [ 2]  779 	incw	x
      00835E 7B 0A            [ 1]  780 	ld	a, (0x0a, sp)
      008360 F7               [ 1]  781 	ld	(x), a
                                    782 ;	se8r01.c: 174: message[2] = 0;
      008361 93               [ 1]  783 	ldw	x, y
      008362 5C               [ 2]  784 	incw	x
      008363 5C               [ 2]  785 	incw	x
      008364 7F               [ 1]  786 	clr	(x)
                                    787 ;	se8r01.c: 175: UARTPrintF (message);
      008365 90 89            [ 2]  788 	pushw	y
      008367 CD 83 0C         [ 4]  789 	call	_UARTPrintF
      00836A 5B 02            [ 2]  790 	addw	sp, #2
      00836C 5B 0C            [ 2]  791 	addw	sp, #12
      00836E 81               [ 4]  792 	ret
                                    793 ;	se8r01.c: 177: unsigned char i2c_read_register (UCHAR addr, UCHAR rg) {
                                    794 ;	-----------------------------------------
                                    795 ;	 function i2c_read_register
                                    796 ;	-----------------------------------------
      00836F                        797 _i2c_read_register:
      00836F 52 02            [ 2]  798 	sub	sp, #2
                                    799 ;	se8r01.c: 180: i2c_set_start_ack ();
      008371 CD 82 FE         [ 4]  800 	call	_i2c_set_start_ack
                                    801 ;	se8r01.c: 181: i2c_send_address (addr, I2C_WRITE);
      008374 4B 00            [ 1]  802 	push	#0x00
      008376 7B 06            [ 1]  803 	ld	a, (0x06, sp)
      008378 88               [ 1]  804 	push	a
      008379 CD 82 BC         [ 4]  805 	call	_i2c_send_address
      00837C 5B 02            [ 2]  806 	addw	sp, #2
                                    807 ;	se8r01.c: 182: i2c_send_reg (rg);
      00837E 7B 06            [ 1]  808 	ld	a, (0x06, sp)
      008380 88               [ 1]  809 	push	a
      008381 CD 82 9A         [ 4]  810 	call	_i2c_send_reg
      008384 84               [ 1]  811 	pop	a
                                    812 ;	se8r01.c: 183: i2c_set_start_ack ();
      008385 CD 82 FE         [ 4]  813 	call	_i2c_set_start_ack
                                    814 ;	se8r01.c: 184: i2c_send_address (addr, I2C_READ);
      008388 4B 01            [ 1]  815 	push	#0x01
      00838A 7B 06            [ 1]  816 	ld	a, (0x06, sp)
      00838C 88               [ 1]  817 	push	a
      00838D CD 82 BC         [ 4]  818 	call	_i2c_send_address
      008390 5B 02            [ 2]  819 	addw	sp, #2
                                    820 ;	se8r01.c: 185: reg = I2C_SR1;
      008392 AE 52 17         [ 2]  821 	ldw	x, #0x5217
      008395 F6               [ 1]  822 	ld	a, (x)
      008396 6B 02            [ 1]  823 	ld	(0x02, sp), a
                                    824 ;	se8r01.c: 186: reg = I2C_SR3;
      008398 AE 52 19         [ 2]  825 	ldw	x, #0x5219
      00839B F6               [ 1]  826 	ld	a, (x)
      00839C 6B 02            [ 1]  827 	ld	(0x02, sp), a
                                    828 ;	se8r01.c: 187: i2c_set_nak ();
      00839E CD 82 8A         [ 4]  829 	call	_i2c_set_nak
                                    830 ;	se8r01.c: 188: i2c_set_stop ();
      0083A1 CD 82 92         [ 4]  831 	call	_i2c_set_stop
                                    832 ;	se8r01.c: 189: i2c_read (&x);
      0083A4 96               [ 1]  833 	ldw	x, sp
      0083A5 5C               [ 2]  834 	incw	x
      0083A6 89               [ 2]  835 	pushw	x
      0083A7 CD 82 79         [ 4]  836 	call	_i2c_read
      0083AA 5B 02            [ 2]  837 	addw	sp, #2
                                    838 ;	se8r01.c: 190: return (x);
      0083AC 7B 01            [ 1]  839 	ld	a, (0x01, sp)
      0083AE 5B 02            [ 2]  840 	addw	sp, #2
      0083B0 81               [ 4]  841 	ret
                                    842 ;	se8r01.c: 193: void InitializeI2C (void) {
                                    843 ;	-----------------------------------------
                                    844 ;	 function InitializeI2C
                                    845 ;	-----------------------------------------
      0083B1                        846 _InitializeI2C:
                                    847 ;	se8r01.c: 194: I2C_CR1 = 0;   //  Disable I2C before configuration starts. PE bit is bit 0
      0083B1 AE 52 10         [ 2]  848 	ldw	x, #0x5210
      0083B4 7F               [ 1]  849 	clr	(x)
                                    850 ;	se8r01.c: 198: I2C_FREQR = 16;                     //  Set the internal clock frequency (MHz).
      0083B5 AE 52 12         [ 2]  851 	ldw	x, #0x5212
      0083B8 A6 10            [ 1]  852 	ld	a, #0x10
      0083BA F7               [ 1]  853 	ld	(x), a
                                    854 ;	se8r01.c: 199: UNSET (I2C_CCRH, I2C_FS);           //  I2C running is standard mode.
      0083BB 72 17 52 1C      [ 1]  855 	bres	0x521c, #7
                                    856 ;	se8r01.c: 200: I2C_CCRL = 0x10;                    //  SCL clock speed is 500 kHz.
      0083BF AE 52 1B         [ 2]  857 	ldw	x, #0x521b
      0083C2 A6 10            [ 1]  858 	ld	a, #0x10
      0083C4 F7               [ 1]  859 	ld	(x), a
                                    860 ;	se8r01.c: 201: I2C_CCRH &= 0xf0;	// Clears lower 4 bits "CCR"
      0083C5 AE 52 1C         [ 2]  861 	ldw	x, #0x521c
      0083C8 F6               [ 1]  862 	ld	a, (x)
      0083C9 A4 F0            [ 1]  863 	and	a, #0xf0
      0083CB F7               [ 1]  864 	ld	(x), a
                                    865 ;	se8r01.c: 205: UNSET (I2C_OARH, I2C_ADDMODE);      //  7 bit address mode.
      0083CC 72 17 52 14      [ 1]  866 	bres	0x5214, #7
                                    867 ;	se8r01.c: 206: SET (I2C_OARH, I2C_ADDCONF);        //  Docs say this must always be 1.
      0083D0 AE 52 14         [ 2]  868 	ldw	x, #0x5214
      0083D3 F6               [ 1]  869 	ld	a, (x)
      0083D4 AA 40            [ 1]  870 	or	a, #0x40
      0083D6 F7               [ 1]  871 	ld	(x), a
                                    872 ;	se8r01.c: 210: I2C_TRISER = 17;
      0083D7 AE 52 1D         [ 2]  873 	ldw	x, #0x521d
      0083DA A6 11            [ 1]  874 	ld	a, #0x11
      0083DC F7               [ 1]  875 	ld	(x), a
                                    876 ;	se8r01.c: 218: I2C_CR1 = I2C_PE;	// Enables port
      0083DD AE 52 10         [ 2]  877 	ldw	x, #0x5210
      0083E0 A6 01            [ 1]  878 	ld	a, #0x01
      0083E2 F7               [ 1]  879 	ld	(x), a
      0083E3 81               [ 4]  880 	ret
                                    881 ;	se8r01.c: 224: void InitializeUART() {
                                    882 ;	-----------------------------------------
                                    883 ;	 function InitializeUART
                                    884 ;	-----------------------------------------
      0083E4                        885 _InitializeUART:
                                    886 ;	se8r01.c: 234: UART1_CR1 = 0;
      0083E4 AE 52 34         [ 2]  887 	ldw	x, #0x5234
      0083E7 7F               [ 1]  888 	clr	(x)
                                    889 ;	se8r01.c: 235: UART1_CR2 = 0;
      0083E8 AE 52 35         [ 2]  890 	ldw	x, #0x5235
      0083EB 7F               [ 1]  891 	clr	(x)
                                    892 ;	se8r01.c: 236: UART1_CR4 = 0;
      0083EC AE 52 37         [ 2]  893 	ldw	x, #0x5237
      0083EF 7F               [ 1]  894 	clr	(x)
                                    895 ;	se8r01.c: 237: UART1_CR3 = 0;
      0083F0 AE 52 36         [ 2]  896 	ldw	x, #0x5236
      0083F3 7F               [ 1]  897 	clr	(x)
                                    898 ;	se8r01.c: 238: UART1_CR5 = 0;
      0083F4 AE 52 38         [ 2]  899 	ldw	x, #0x5238
      0083F7 7F               [ 1]  900 	clr	(x)
                                    901 ;	se8r01.c: 239: UART1_GTR = 0;
      0083F8 AE 52 39         [ 2]  902 	ldw	x, #0x5239
      0083FB 7F               [ 1]  903 	clr	(x)
                                    904 ;	se8r01.c: 240: UART1_PSCR = 0;
      0083FC AE 52 3A         [ 2]  905 	ldw	x, #0x523a
      0083FF 7F               [ 1]  906 	clr	(x)
                                    907 ;	se8r01.c: 244: UNSET (UART1_CR1, CR1_M);        //  8 Data bits.
      008400 AE 52 34         [ 2]  908 	ldw	x, #0x5234
      008403 F6               [ 1]  909 	ld	a, (x)
      008404 A4 EF            [ 1]  910 	and	a, #0xef
      008406 F7               [ 1]  911 	ld	(x), a
                                    912 ;	se8r01.c: 245: UNSET (UART1_CR1, CR1_PCEN);     //  Disable parity.
      008407 AE 52 34         [ 2]  913 	ldw	x, #0x5234
      00840A F6               [ 1]  914 	ld	a, (x)
      00840B A4 FB            [ 1]  915 	and	a, #0xfb
      00840D F7               [ 1]  916 	ld	(x), a
                                    917 ;	se8r01.c: 246: UNSET (UART1_CR3, CR3_STOPH);    //  1 stop bit.
      00840E AE 52 36         [ 2]  918 	ldw	x, #0x5236
      008411 F6               [ 1]  919 	ld	a, (x)
      008412 A4 DF            [ 1]  920 	and	a, #0xdf
      008414 F7               [ 1]  921 	ld	(x), a
                                    922 ;	se8r01.c: 247: UNSET (UART1_CR3, CR3_STOPL);    //  1 stop bit.
      008415 AE 52 36         [ 2]  923 	ldw	x, #0x5236
      008418 F6               [ 1]  924 	ld	a, (x)
      008419 A4 EF            [ 1]  925 	and	a, #0xef
      00841B F7               [ 1]  926 	ld	(x), a
                                    927 ;	se8r01.c: 248: UART1_BRR2 = 0x0a;      //  Set the baud rate registers to 115200 baud
      00841C AE 52 33         [ 2]  928 	ldw	x, #0x5233
      00841F A6 0A            [ 1]  929 	ld	a, #0x0a
      008421 F7               [ 1]  930 	ld	(x), a
                                    931 ;	se8r01.c: 249: UART1_BRR1 = 0x08;      //  based upon a 16 MHz system clock.
      008422 AE 52 32         [ 2]  932 	ldw	x, #0x5232
      008425 A6 08            [ 1]  933 	ld	a, #0x08
      008427 F7               [ 1]  934 	ld	(x), a
                                    935 ;	se8r01.c: 253: UNSET (UART1_CR2, CR2_TEN);      //  Disable transmit.
      008428 AE 52 35         [ 2]  936 	ldw	x, #0x5235
      00842B F6               [ 1]  937 	ld	a, (x)
      00842C A4 F7            [ 1]  938 	and	a, #0xf7
      00842E F7               [ 1]  939 	ld	(x), a
                                    940 ;	se8r01.c: 254: UNSET (UART1_CR2, CR2_REN);      //  Disable receive.
      00842F AE 52 35         [ 2]  941 	ldw	x, #0x5235
      008432 F6               [ 1]  942 	ld	a, (x)
      008433 A4 FB            [ 1]  943 	and	a, #0xfb
      008435 F7               [ 1]  944 	ld	(x), a
                                    945 ;	se8r01.c: 258: SET (UART1_CR3, CR3_CPOL);
      008436 AE 52 36         [ 2]  946 	ldw	x, #0x5236
      008439 F6               [ 1]  947 	ld	a, (x)
      00843A AA 04            [ 1]  948 	or	a, #0x04
      00843C F7               [ 1]  949 	ld	(x), a
                                    950 ;	se8r01.c: 259: SET (UART1_CR3, CR3_CPHA);
      00843D AE 52 36         [ 2]  951 	ldw	x, #0x5236
      008440 F6               [ 1]  952 	ld	a, (x)
      008441 AA 02            [ 1]  953 	or	a, #0x02
      008443 F7               [ 1]  954 	ld	(x), a
                                    955 ;	se8r01.c: 260: SET (UART1_CR3, CR3_LBCL);
      008444 72 10 52 36      [ 1]  956 	bset	0x5236, #0
                                    957 ;	se8r01.c: 264: SET (UART1_CR2, CR2_TEN);
      008448 AE 52 35         [ 2]  958 	ldw	x, #0x5235
      00844B F6               [ 1]  959 	ld	a, (x)
      00844C AA 08            [ 1]  960 	or	a, #0x08
      00844E F7               [ 1]  961 	ld	(x), a
                                    962 ;	se8r01.c: 265: SET (UART1_CR2, CR2_REN);
      00844F AE 52 35         [ 2]  963 	ldw	x, #0x5235
      008452 F6               [ 1]  964 	ld	a, (x)
      008453 AA 04            [ 1]  965 	or	a, #0x04
      008455 F7               [ 1]  966 	ld	(x), a
                                    967 ;	se8r01.c: 266: UART1_CR3 = CR3_CLKEN;
      008456 AE 52 36         [ 2]  968 	ldw	x, #0x5236
      008459 A6 08            [ 1]  969 	ld	a, #0x08
      00845B F7               [ 1]  970 	ld	(x), a
      00845C 81               [ 4]  971 	ret
                                    972 ;	se8r01.c: 334: void init_io(void)
                                    973 ;	-----------------------------------------
                                    974 ;	 function init_io
                                    975 ;	-----------------------------------------
      00845D                        976 _init_io:
                                    977 ;	se8r01.c: 336: PD_DDR &= ~(1 << 3); // input mode
      00845D AE 50 11         [ 2]  978 	ldw	x, #0x5011
      008460 F6               [ 1]  979 	ld	a, (x)
      008461 A4 F7            [ 1]  980 	and	a, #0xf7
      008463 F7               [ 1]  981 	ld	(x), a
                                    982 ;	se8r01.c: 337: PD_CR1 |= (1 << 3); // input with pull up 
      008464 AE 50 12         [ 2]  983 	ldw	x, #0x5012
      008467 F6               [ 1]  984 	ld	a, (x)
      008468 AA 08            [ 1]  985 	or	a, #0x08
      00846A F7               [ 1]  986 	ld	(x), a
                                    987 ;	se8r01.c: 338: PD_CR2 |= (1 << 3); // interrupt enabled 
      00846B AE 50 13         [ 2]  988 	ldw	x, #0x5013
      00846E F6               [ 1]  989 	ld	a, (x)
      00846F AA 08            [ 1]  990 	or	a, #0x08
      008471 F7               [ 1]  991 	ld	(x), a
                                    992 ;	se8r01.c: 339: PD_ODR &= ~(1 << 3);
      008472 AE 50 0F         [ 2]  993 	ldw	x, #0x500f
      008475 F6               [ 1]  994 	ld	a, (x)
      008476 A4 F7            [ 1]  995 	and	a, #0xf7
      008478 F7               [ 1]  996 	ld	(x), a
                                    997 ;	se8r01.c: 342: PC_ODR &= ~(1 << CE);
      008479 AE 50 0A         [ 2]  998 	ldw	x, #0x500a
      00847C F6               [ 1]  999 	ld	a, (x)
      00847D A4 EF            [ 1] 1000 	and	a, #0xef
      00847F F7               [ 1] 1001 	ld	(x), a
                                   1002 ;	se8r01.c: 344: PC_ODR |= (1 << CSN);
      008480 AE 50 0A         [ 2] 1003 	ldw	x, #0x500a
      008483 F6               [ 1] 1004 	ld	a, (x)
      008484 AA 08            [ 1] 1005 	or	a, #0x08
      008486 F7               [ 1] 1006 	ld	(x), a
      008487 81               [ 4] 1007 	ret
                                   1008 ;	se8r01.c: 350: void rf_switch_bank(unsigned char bankindex)
                                   1009 ;	-----------------------------------------
                                   1010 ;	 function rf_switch_bank
                                   1011 ;	-----------------------------------------
      008488                       1012 _rf_switch_bank:
      008488 88               [ 1] 1013 	push	a
                                   1014 ;	se8r01.c: 353: temp1 = bankindex;
      008489 7B 04            [ 1] 1015 	ld	a, (0x04, sp)
      00848B 6B 01            [ 1] 1016 	ld	(0x01, sp), a
                                   1017 ;	se8r01.c: 355: temp0 = write_spi(iRF_BANK0_STATUS);
      00848D 4B 07            [ 1] 1018 	push	#0x07
      00848F CD 80 A8         [ 4] 1019 	call	_write_spi
      008492 5B 01            [ 2] 1020 	addw	sp, #1
                                   1021 ;	se8r01.c: 357: if((temp0&0x80)!=temp1)
      008494 A4 80            [ 1] 1022 	and	a, #0x80
      008496 11 01            [ 1] 1023 	cp	a, (0x01, sp)
      008498 27 09            [ 1] 1024 	jreq	00103$
                                   1025 ;	se8r01.c: 359: write_spi_reg(iRF_CMD_ACTIVATE,0x53);
      00849A 4B 53            [ 1] 1026 	push	#0x53
      00849C 4B 50            [ 1] 1027 	push	#0x50
      00849E CD 80 CE         [ 4] 1028 	call	_write_spi_reg
      0084A1 5B 02            [ 2] 1029 	addw	sp, #2
      0084A3                       1030 00103$:
      0084A3 84               [ 1] 1031 	pop	a
      0084A4 81               [ 4] 1032 	ret
                                   1033 ;	se8r01.c: 366: void SE8R01_Calibration()
                                   1034 ;	-----------------------------------------
                                   1035 ;	 function SE8R01_Calibration
                                   1036 ;	-----------------------------------------
      0084A5                       1037 _SE8R01_Calibration:
      0084A5 52 0D            [ 2] 1038 	sub	sp, #13
                                   1039 ;	se8r01.c: 369: rf_switch_bank(iBANK0);
      0084A7 4B 00            [ 1] 1040 	push	#0x00
      0084A9 CD 84 88         [ 4] 1041 	call	_rf_switch_bank
      0084AC 84               [ 1] 1042 	pop	a
                                   1043 ;	se8r01.c: 370: temp[0]=0x03;
      0084AD 96               [ 1] 1044 	ldw	x, sp
      0084AE 5C               [ 2] 1045 	incw	x
      0084AF 1F 0C            [ 2] 1046 	ldw	(0x0c, sp), x
      0084B1 1E 0C            [ 2] 1047 	ldw	x, (0x0c, sp)
      0084B3 A6 03            [ 1] 1048 	ld	a, #0x03
      0084B5 F7               [ 1] 1049 	ld	(x), a
                                   1050 ;	se8r01.c: 371: write_spi_buf(iRF_CMD_WRITE_REG|iRF_BANK0_CONFIG,temp, 1);
      0084B6 1E 0C            [ 2] 1051 	ldw	x, (0x0c, sp)
      0084B8 4B 01            [ 1] 1052 	push	#0x01
      0084BA 89               [ 2] 1053 	pushw	x
      0084BB 4B 20            [ 1] 1054 	push	#0x20
      0084BD CD 81 48         [ 4] 1055 	call	_write_spi_buf
      0084C0 5B 04            [ 2] 1056 	addw	sp, #4
                                   1057 ;	se8r01.c: 373: temp[0]=0x32;
      0084C2 1E 0C            [ 2] 1058 	ldw	x, (0x0c, sp)
      0084C4 A6 32            [ 1] 1059 	ld	a, #0x32
      0084C6 F7               [ 1] 1060 	ld	(x), a
                                   1061 ;	se8r01.c: 375: write_spi_buf(iRF_CMD_WRITE_REG|iRF_BANK0_RF_CH, temp,1);
      0084C7 1E 0C            [ 2] 1062 	ldw	x, (0x0c, sp)
      0084C9 4B 01            [ 1] 1063 	push	#0x01
      0084CB 89               [ 2] 1064 	pushw	x
      0084CC 4B 25            [ 1] 1065 	push	#0x25
      0084CE CD 81 48         [ 4] 1066 	call	_write_spi_buf
      0084D1 5B 04            [ 2] 1067 	addw	sp, #4
                                   1068 ;	se8r01.c: 379: if (SE8R01_DR_2M==1)
      0084D3 CE 00 10         [ 2] 1069 	ldw	x, _SE8R01_DR_2M+0
      0084D6 A3 00 01         [ 2] 1070 	cpw	x, #0x0001
      0084D9 26 07            [ 1] 1071 	jrne	00105$
                                   1072 ;	se8r01.c: 380: {temp[0]=0x48;}
      0084DB 1E 0C            [ 2] 1073 	ldw	x, (0x0c, sp)
      0084DD A6 48            [ 1] 1074 	ld	a, #0x48
      0084DF F7               [ 1] 1075 	ld	(x), a
      0084E0 20 14            [ 2] 1076 	jra	00106$
      0084E2                       1077 00105$:
                                   1078 ;	se8r01.c: 381: else if (SE8R01_DR_1M==1)
      0084E2 CE 00 12         [ 2] 1079 	ldw	x, _SE8R01_DR_1M+0
      0084E5 A3 00 01         [ 2] 1080 	cpw	x, #0x0001
      0084E8 26 07            [ 1] 1081 	jrne	00102$
                                   1082 ;	se8r01.c: 382: {temp[0]=0x40;}
      0084EA 1E 0C            [ 2] 1083 	ldw	x, (0x0c, sp)
      0084EC A6 40            [ 1] 1084 	ld	a, #0x40
      0084EE F7               [ 1] 1085 	ld	(x), a
      0084EF 20 05            [ 2] 1086 	jra	00106$
      0084F1                       1087 00102$:
                                   1088 ;	se8r01.c: 384: {temp[0]=0x68;}   
      0084F1 1E 0C            [ 2] 1089 	ldw	x, (0x0c, sp)
      0084F3 A6 68            [ 1] 1090 	ld	a, #0x68
      0084F5 F7               [ 1] 1091 	ld	(x), a
      0084F6                       1092 00106$:
                                   1093 ;	se8r01.c: 386: write_spi_buf(iRF_CMD_WRITE_REG|iRF_BANK0_RF_SETUP,temp,1);
      0084F6 1E 0C            [ 2] 1094 	ldw	x, (0x0c, sp)
      0084F8 4B 01            [ 1] 1095 	push	#0x01
      0084FA 89               [ 2] 1096 	pushw	x
      0084FB 4B 26            [ 1] 1097 	push	#0x26
      0084FD CD 81 48         [ 4] 1098 	call	_write_spi_buf
      008500 5B 04            [ 2] 1099 	addw	sp, #4
                                   1100 ;	se8r01.c: 387: temp[0]=0x77;
      008502 1E 0C            [ 2] 1101 	ldw	x, (0x0c, sp)
      008504 A6 77            [ 1] 1102 	ld	a, #0x77
      008506 F7               [ 1] 1103 	ld	(x), a
                                   1104 ;	se8r01.c: 388: write_spi_buf(iRF_CMD_WRITE_REG|iRF_BANK0_PRE_GURD, temp,1);
      008507 1E 0C            [ 2] 1105 	ldw	x, (0x0c, sp)
      008509 4B 01            [ 1] 1106 	push	#0x01
      00850B 89               [ 2] 1107 	pushw	x
      00850C 4B 3F            [ 1] 1108 	push	#0x3f
      00850E CD 81 48         [ 4] 1109 	call	_write_spi_buf
      008511 5B 04            [ 2] 1110 	addw	sp, #4
                                   1111 ;	se8r01.c: 390: rf_switch_bank(iBANK1);
      008513 4B 80            [ 1] 1112 	push	#0x80
      008515 CD 84 88         [ 4] 1113 	call	_rf_switch_bank
      008518 84               [ 1] 1114 	pop	a
                                   1115 ;	se8r01.c: 391: temp[0]=0x40;
      008519 1E 0C            [ 2] 1116 	ldw	x, (0x0c, sp)
      00851B A6 40            [ 1] 1117 	ld	a, #0x40
      00851D F7               [ 1] 1118 	ld	(x), a
                                   1119 ;	se8r01.c: 392: temp[1]=0x00;
      00851E 1E 0C            [ 2] 1120 	ldw	x, (0x0c, sp)
      008520 5C               [ 2] 1121 	incw	x
      008521 1F 0A            [ 2] 1122 	ldw	(0x0a, sp), x
      008523 1E 0A            [ 2] 1123 	ldw	x, (0x0a, sp)
      008525 7F               [ 1] 1124 	clr	(x)
                                   1125 ;	se8r01.c: 393: temp[2]=0x10;
      008526 1E 0C            [ 2] 1126 	ldw	x, (0x0c, sp)
      008528 5C               [ 2] 1127 	incw	x
      008529 5C               [ 2] 1128 	incw	x
      00852A 1F 08            [ 2] 1129 	ldw	(0x08, sp), x
      00852C 1E 08            [ 2] 1130 	ldw	x, (0x08, sp)
      00852E A6 10            [ 1] 1131 	ld	a, #0x10
      008530 F7               [ 1] 1132 	ld	(x), a
                                   1133 ;	se8r01.c: 395: {temp[3]=0xE6;}
      008531 1E 0C            [ 2] 1134 	ldw	x, (0x0c, sp)
      008533 1C 00 03         [ 2] 1135 	addw	x, #0x0003
      008536 1F 06            [ 2] 1136 	ldw	(0x06, sp), x
                                   1137 ;	se8r01.c: 394: if (SE8R01_DR_2M==1)
      008538 CE 00 10         [ 2] 1138 	ldw	x, _SE8R01_DR_2M+0
      00853B A3 00 01         [ 2] 1139 	cpw	x, #0x0001
      00853E 26 07            [ 1] 1140 	jrne	00108$
                                   1141 ;	se8r01.c: 395: {temp[3]=0xE6;}
      008540 1E 06            [ 2] 1142 	ldw	x, (0x06, sp)
      008542 A6 E6            [ 1] 1143 	ld	a, #0xe6
      008544 F7               [ 1] 1144 	ld	(x), a
      008545 20 05            [ 2] 1145 	jra	00109$
      008547                       1146 00108$:
                                   1147 ;	se8r01.c: 397: {temp[3]=0xE4;}
      008547 1E 06            [ 2] 1148 	ldw	x, (0x06, sp)
      008549 A6 E4            [ 1] 1149 	ld	a, #0xe4
      00854B F7               [ 1] 1150 	ld	(x), a
      00854C                       1151 00109$:
                                   1152 ;	se8r01.c: 399: write_spi_buf(iRF_CMD_WRITE_REG|iRF_BANK1_PLL_CTL0, temp, 4);
      00854C 1E 0C            [ 2] 1153 	ldw	x, (0x0c, sp)
      00854E 4B 04            [ 1] 1154 	push	#0x04
      008550 89               [ 2] 1155 	pushw	x
      008551 4B 21            [ 1] 1156 	push	#0x21
      008553 CD 81 48         [ 4] 1157 	call	_write_spi_buf
      008556 5B 04            [ 2] 1158 	addw	sp, #4
                                   1159 ;	se8r01.c: 401: temp[0]=0x20;
      008558 1E 0C            [ 2] 1160 	ldw	x, (0x0c, sp)
      00855A A6 20            [ 1] 1161 	ld	a, #0x20
      00855C F7               [ 1] 1162 	ld	(x), a
                                   1163 ;	se8r01.c: 402: temp[1]=0x08;
      00855D 1E 0A            [ 2] 1164 	ldw	x, (0x0a, sp)
      00855F A6 08            [ 1] 1165 	ld	a, #0x08
      008561 F7               [ 1] 1166 	ld	(x), a
                                   1167 ;	se8r01.c: 403: temp[2]=0x50;
      008562 1E 08            [ 2] 1168 	ldw	x, (0x08, sp)
      008564 A6 50            [ 1] 1169 	ld	a, #0x50
      008566 F7               [ 1] 1170 	ld	(x), a
                                   1171 ;	se8r01.c: 404: temp[3]=0x40;
      008567 1E 06            [ 2] 1172 	ldw	x, (0x06, sp)
      008569 A6 40            [ 1] 1173 	ld	a, #0x40
      00856B F7               [ 1] 1174 	ld	(x), a
                                   1175 ;	se8r01.c: 405: temp[4]=0x50;
      00856C 1E 0C            [ 2] 1176 	ldw	x, (0x0c, sp)
      00856E A6 50            [ 1] 1177 	ld	a, #0x50
      008570 E7 04            [ 1] 1178 	ld	(0x0004, x), a
                                   1179 ;	se8r01.c: 406: write_spi_buf(iRF_CMD_WRITE_REG|iRF_BANK1_CAL_CTL, temp, 5);
      008572 1E 0C            [ 2] 1180 	ldw	x, (0x0c, sp)
      008574 4B 05            [ 1] 1181 	push	#0x05
      008576 89               [ 2] 1182 	pushw	x
      008577 4B 23            [ 1] 1183 	push	#0x23
      008579 CD 81 48         [ 4] 1184 	call	_write_spi_buf
      00857C 5B 04            [ 2] 1185 	addw	sp, #4
                                   1186 ;	se8r01.c: 408: temp[0]=0x00;
      00857E 1E 0C            [ 2] 1187 	ldw	x, (0x0c, sp)
      008580 7F               [ 1] 1188 	clr	(x)
                                   1189 ;	se8r01.c: 409: temp[1]=0x00;
      008581 1E 0A            [ 2] 1190 	ldw	x, (0x0a, sp)
      008583 7F               [ 1] 1191 	clr	(x)
                                   1192 ;	se8r01.c: 410: if (SE8R01_DR_2M==1)
      008584 CE 00 10         [ 2] 1193 	ldw	x, _SE8R01_DR_2M+0
      008587 A3 00 01         [ 2] 1194 	cpw	x, #0x0001
      00858A 26 07            [ 1] 1195 	jrne	00111$
                                   1196 ;	se8r01.c: 411: { temp[2]=0x1E;}
      00858C 1E 08            [ 2] 1197 	ldw	x, (0x08, sp)
      00858E A6 1E            [ 1] 1198 	ld	a, #0x1e
      008590 F7               [ 1] 1199 	ld	(x), a
      008591 20 05            [ 2] 1200 	jra	00112$
      008593                       1201 00111$:
                                   1202 ;	se8r01.c: 413: { temp[2]=0x1F;}
      008593 1E 08            [ 2] 1203 	ldw	x, (0x08, sp)
      008595 A6 1F            [ 1] 1204 	ld	a, #0x1f
      008597 F7               [ 1] 1205 	ld	(x), a
      008598                       1206 00112$:
                                   1207 ;	se8r01.c: 415: write_spi_buf(iRF_CMD_WRITE_REG|iRF_BANK1_IF_FREQ, temp, 3);
      008598 1E 0C            [ 2] 1208 	ldw	x, (0x0c, sp)
      00859A 4B 03            [ 1] 1209 	push	#0x03
      00859C 89               [ 2] 1210 	pushw	x
      00859D 4B 2A            [ 1] 1211 	push	#0x2a
      00859F CD 81 48         [ 4] 1212 	call	_write_spi_buf
      0085A2 5B 04            [ 2] 1213 	addw	sp, #4
                                   1214 ;	se8r01.c: 417: if (SE8R01_DR_2M==1)
      0085A4 CE 00 10         [ 2] 1215 	ldw	x, _SE8R01_DR_2M+0
      0085A7 A3 00 01         [ 2] 1216 	cpw	x, #0x0001
      0085AA 26 07            [ 1] 1217 	jrne	00114$
                                   1218 ;	se8r01.c: 418: { temp[0]=0x29;}
      0085AC 1E 0C            [ 2] 1219 	ldw	x, (0x0c, sp)
      0085AE A6 29            [ 1] 1220 	ld	a, #0x29
      0085B0 F7               [ 1] 1221 	ld	(x), a
      0085B1 20 05            [ 2] 1222 	jra	00115$
      0085B3                       1223 00114$:
                                   1224 ;	se8r01.c: 420: { temp[0]=0x14;}
      0085B3 1E 0C            [ 2] 1225 	ldw	x, (0x0c, sp)
      0085B5 A6 14            [ 1] 1226 	ld	a, #0x14
      0085B7 F7               [ 1] 1227 	ld	(x), a
      0085B8                       1228 00115$:
                                   1229 ;	se8r01.c: 422: write_spi_buf(iRF_CMD_WRITE_REG|iRF_BANK1_FDEV, temp, 1);
      0085B8 1E 0C            [ 2] 1230 	ldw	x, (0x0c, sp)
      0085BA 4B 01            [ 1] 1231 	push	#0x01
      0085BC 89               [ 2] 1232 	pushw	x
      0085BD 4B 2C            [ 1] 1233 	push	#0x2c
      0085BF CD 81 48         [ 4] 1234 	call	_write_spi_buf
      0085C2 5B 04            [ 2] 1235 	addw	sp, #4
                                   1236 ;	se8r01.c: 424: temp[0]=0x00;
      0085C4 1E 0C            [ 2] 1237 	ldw	x, (0x0c, sp)
      0085C6 7F               [ 1] 1238 	clr	(x)
                                   1239 ;	se8r01.c: 425: write_spi_buf(iRF_CMD_WRITE_REG|iRF_BANK1_DAC_CAL_LOW,temp,1);
      0085C7 1E 0C            [ 2] 1240 	ldw	x, (0x0c, sp)
      0085C9 4B 01            [ 1] 1241 	push	#0x01
      0085CB 89               [ 2] 1242 	pushw	x
      0085CC 4B 37            [ 1] 1243 	push	#0x37
      0085CE CD 81 48         [ 4] 1244 	call	_write_spi_buf
      0085D1 5B 04            [ 2] 1245 	addw	sp, #4
                                   1246 ;	se8r01.c: 427: temp[0]=0x7F;
      0085D3 1E 0C            [ 2] 1247 	ldw	x, (0x0c, sp)
      0085D5 A6 7F            [ 1] 1248 	ld	a, #0x7f
      0085D7 F7               [ 1] 1249 	ld	(x), a
                                   1250 ;	se8r01.c: 428: write_spi_buf(iRF_CMD_WRITE_REG|iRF_BANK1_DAC_CAL_HI,temp,1);
      0085D8 1E 0C            [ 2] 1251 	ldw	x, (0x0c, sp)
      0085DA 4B 01            [ 1] 1252 	push	#0x01
      0085DC 89               [ 2] 1253 	pushw	x
      0085DD 4B 38            [ 1] 1254 	push	#0x38
      0085DF CD 81 48         [ 4] 1255 	call	_write_spi_buf
      0085E2 5B 04            [ 2] 1256 	addw	sp, #4
                                   1257 ;	se8r01.c: 430: temp[0]=0x02;
      0085E4 1E 0C            [ 2] 1258 	ldw	x, (0x0c, sp)
      0085E6 A6 02            [ 1] 1259 	ld	a, #0x02
      0085E8 F7               [ 1] 1260 	ld	(x), a
                                   1261 ;	se8r01.c: 431: temp[1]=0xC1;
      0085E9 1E 0A            [ 2] 1262 	ldw	x, (0x0a, sp)
      0085EB A6 C1            [ 1] 1263 	ld	a, #0xc1
      0085ED F7               [ 1] 1264 	ld	(x), a
                                   1265 ;	se8r01.c: 432: temp[2]=0xEB;            
      0085EE 1E 08            [ 2] 1266 	ldw	x, (0x08, sp)
      0085F0 A6 EB            [ 1] 1267 	ld	a, #0xeb
      0085F2 F7               [ 1] 1268 	ld	(x), a
                                   1269 ;	se8r01.c: 433: temp[3]=0x1C;
      0085F3 1E 06            [ 2] 1270 	ldw	x, (0x06, sp)
      0085F5 A6 1C            [ 1] 1271 	ld	a, #0x1c
      0085F7 F7               [ 1] 1272 	ld	(x), a
                                   1273 ;	se8r01.c: 434: write_spi_buf(iRF_CMD_WRITE_REG|iRF_BANK1_AGC_GAIN, temp,4);
      0085F8 1E 0C            [ 2] 1274 	ldw	x, (0x0c, sp)
      0085FA 4B 04            [ 1] 1275 	push	#0x04
      0085FC 89               [ 2] 1276 	pushw	x
      0085FD 4B 3D            [ 1] 1277 	push	#0x3d
      0085FF CD 81 48         [ 4] 1278 	call	_write_spi_buf
      008602 5B 04            [ 2] 1279 	addw	sp, #4
                                   1280 ;	se8r01.c: 436: temp[0]=0x97;
      008604 1E 0C            [ 2] 1281 	ldw	x, (0x0c, sp)
      008606 A6 97            [ 1] 1282 	ld	a, #0x97
      008608 F7               [ 1] 1283 	ld	(x), a
                                   1284 ;	se8r01.c: 437: temp[1]=0x64;
      008609 1E 0A            [ 2] 1285 	ldw	x, (0x0a, sp)
      00860B A6 64            [ 1] 1286 	ld	a, #0x64
      00860D F7               [ 1] 1287 	ld	(x), a
                                   1288 ;	se8r01.c: 438: temp[2]=0x00;
      00860E 1E 08            [ 2] 1289 	ldw	x, (0x08, sp)
      008610 7F               [ 1] 1290 	clr	(x)
                                   1291 ;	se8r01.c: 439: temp[3]=0x81;
      008611 1E 06            [ 2] 1292 	ldw	x, (0x06, sp)
      008613 A6 81            [ 1] 1293 	ld	a, #0x81
      008615 F7               [ 1] 1294 	ld	(x), a
                                   1295 ;	se8r01.c: 440: write_spi_buf(iRF_CMD_WRITE_REG|iRF_BANK1_RF_IVGEN, temp, 4);
      008616 1E 0C            [ 2] 1296 	ldw	x, (0x0c, sp)
      008618 4B 04            [ 1] 1297 	push	#0x04
      00861A 89               [ 2] 1298 	pushw	x
      00861B 4B 3E            [ 1] 1299 	push	#0x3e
      00861D CD 81 48         [ 4] 1300 	call	_write_spi_buf
      008620 5B 04            [ 2] 1301 	addw	sp, #4
                                   1302 ;	se8r01.c: 441: rf_switch_bank(iBANK0);
      008622 4B 00            [ 1] 1303 	push	#0x00
      008624 CD 84 88         [ 4] 1304 	call	_rf_switch_bank
      008627 84               [ 1] 1305 	pop	a
                                   1306 ;	se8r01.c: 446: delayTenMicro();
      008628 CD 80 A0         [ 4] 1307 	call	_delayTenMicro
                                   1308 ;	se8r01.c: 447: PC_ODR |= (1 << CE);
      00862B AE 50 0A         [ 2] 1309 	ldw	x, #0x500a
      00862E F6               [ 1] 1310 	ld	a, (x)
      00862F AA 10            [ 1] 1311 	or	a, #0x10
      008631 F7               [ 1] 1312 	ld	(x), a
                                   1313 ;	se8r01.c: 448: delayTenMicro();
      008632 CD 80 A0         [ 4] 1314 	call	_delayTenMicro
                                   1315 ;	se8r01.c: 449: PC_ODR &= ~(1 << CE);
      008635 AE 50 0A         [ 2] 1316 	ldw	x, #0x500a
      008638 F6               [ 1] 1317 	ld	a, (x)
      008639 A4 EF            [ 1] 1318 	and	a, #0xef
      00863B F7               [ 1] 1319 	ld	(x), a
                                   1320 ;	se8r01.c: 450: delay(50);                            // delay 50ms waitting for calibaration.
      00863C 4B 32            [ 1] 1321 	push	#0x32
      00863E 4B 00            [ 1] 1322 	push	#0x00
      008640 CD 82 2E         [ 4] 1323 	call	_delay
      008643 5B 02            [ 2] 1324 	addw	sp, #2
                                   1325 ;	se8r01.c: 455: delayTenMicro();
      008645 CD 80 A0         [ 4] 1326 	call	_delayTenMicro
                                   1327 ;	se8r01.c: 456: PC_ODR |= (1 << CE);
      008648 AE 50 0A         [ 2] 1328 	ldw	x, #0x500a
      00864B F6               [ 1] 1329 	ld	a, (x)
      00864C AA 10            [ 1] 1330 	or	a, #0x10
      00864E F7               [ 1] 1331 	ld	(x), a
                                   1332 ;	se8r01.c: 457: delayTenMicro();
      00864F CD 80 A0         [ 4] 1333 	call	_delayTenMicro
                                   1334 ;	se8r01.c: 458: PC_ODR &= ~(1 << CE);
      008652 AE 50 0A         [ 2] 1335 	ldw	x, #0x500a
      008655 F6               [ 1] 1336 	ld	a, (x)
      008656 A4 EF            [ 1] 1337 	and	a, #0xef
      008658 F7               [ 1] 1338 	ld	(x), a
                                   1339 ;	se8r01.c: 459: delay(50);                            // delay 50ms waitting for calibaration.
      008659 4B 32            [ 1] 1340 	push	#0x32
      00865B 4B 00            [ 1] 1341 	push	#0x00
      00865D CD 82 2E         [ 4] 1342 	call	_delay
      008660 5B 02            [ 2] 1343 	addw	sp, #2
      008662 5B 0D            [ 2] 1344 	addw	sp, #13
      008664 81               [ 4] 1345 	ret
                                   1346 ;	se8r01.c: 463: void SE8R01_Analog_Init()           //SE8R01 
                                   1347 ;	-----------------------------------------
                                   1348 ;	 function SE8R01_Analog_Init
                                   1349 ;	-----------------------------------------
      008665                       1350 _SE8R01_Analog_Init:
      008665 52 15            [ 2] 1351 	sub	sp, #21
                                   1352 ;	se8r01.c: 468: gtemp[0]=0x28;
      008667 AE 00 01         [ 2] 1353 	ldw	x, #_gtemp+0
      00866A 1F 0A            [ 2] 1354 	ldw	(0x0a, sp), x
      00866C 1E 0A            [ 2] 1355 	ldw	x, (0x0a, sp)
      00866E A6 28            [ 1] 1356 	ld	a, #0x28
      008670 F7               [ 1] 1357 	ld	(x), a
                                   1358 ;	se8r01.c: 469: gtemp[1]=0x32;
      008671 1E 0A            [ 2] 1359 	ldw	x, (0x0a, sp)
      008673 5C               [ 2] 1360 	incw	x
      008674 1F 08            [ 2] 1361 	ldw	(0x08, sp), x
      008676 1E 08            [ 2] 1362 	ldw	x, (0x08, sp)
      008678 A6 32            [ 1] 1363 	ld	a, #0x32
      00867A F7               [ 1] 1364 	ld	(x), a
                                   1365 ;	se8r01.c: 470: gtemp[2]=0x80;
      00867B 1E 0A            [ 2] 1366 	ldw	x, (0x0a, sp)
      00867D 5C               [ 2] 1367 	incw	x
      00867E 5C               [ 2] 1368 	incw	x
      00867F 1F 06            [ 2] 1369 	ldw	(0x06, sp), x
      008681 1E 06            [ 2] 1370 	ldw	x, (0x06, sp)
      008683 A6 80            [ 1] 1371 	ld	a, #0x80
      008685 F7               [ 1] 1372 	ld	(x), a
                                   1373 ;	se8r01.c: 471: gtemp[3]=0x90;
      008686 1E 0A            [ 2] 1374 	ldw	x, (0x0a, sp)
      008688 1C 00 03         [ 2] 1375 	addw	x, #0x0003
      00868B 1F 10            [ 2] 1376 	ldw	(0x10, sp), x
      00868D 1E 10            [ 2] 1377 	ldw	x, (0x10, sp)
      00868F A6 90            [ 1] 1378 	ld	a, #0x90
      008691 F7               [ 1] 1379 	ld	(x), a
                                   1380 ;	se8r01.c: 472: gtemp[4]=0x00;
      008692 1E 0A            [ 2] 1381 	ldw	x, (0x0a, sp)
      008694 1C 00 04         [ 2] 1382 	addw	x, #0x0004
      008697 7F               [ 1] 1383 	clr	(x)
                                   1384 ;	se8r01.c: 473: write_spi_buf(iRF_CMD_WRITE_REG|iRF_BANK0_SETUP_VALUE, gtemp, 5);
      008698 1E 0A            [ 2] 1385 	ldw	x, (0x0a, sp)
      00869A 4B 05            [ 1] 1386 	push	#0x05
      00869C 89               [ 2] 1387 	pushw	x
      00869D 4B 3E            [ 1] 1388 	push	#0x3e
      00869F CD 81 48         [ 4] 1389 	call	_write_spi_buf
      0086A2 5B 04            [ 2] 1390 	addw	sp, #4
                                   1391 ;	se8r01.c: 474: delay(2);
      0086A4 4B 02            [ 1] 1392 	push	#0x02
      0086A6 4B 00            [ 1] 1393 	push	#0x00
      0086A8 CD 82 2E         [ 4] 1394 	call	_delay
      0086AB 5B 02            [ 2] 1395 	addw	sp, #2
                                   1396 ;	se8r01.c: 477: rf_switch_bank(iBANK1);
      0086AD 4B 80            [ 1] 1397 	push	#0x80
      0086AF CD 84 88         [ 4] 1398 	call	_rf_switch_bank
      0086B2 84               [ 1] 1399 	pop	a
                                   1400 ;	se8r01.c: 479: temp[0]=0x40;
      0086B3 96               [ 1] 1401 	ldw	x, sp
      0086B4 5C               [ 2] 1402 	incw	x
      0086B5 1F 0E            [ 2] 1403 	ldw	(0x0e, sp), x
      0086B7 1E 0E            [ 2] 1404 	ldw	x, (0x0e, sp)
      0086B9 A6 40            [ 1] 1405 	ld	a, #0x40
      0086BB F7               [ 1] 1406 	ld	(x), a
                                   1407 ;	se8r01.c: 480: temp[1]=0x01;               
      0086BC 1E 0E            [ 2] 1408 	ldw	x, (0x0e, sp)
      0086BE 5C               [ 2] 1409 	incw	x
      0086BF 1F 0C            [ 2] 1410 	ldw	(0x0c, sp), x
      0086C1 1E 0C            [ 2] 1411 	ldw	x, (0x0c, sp)
      0086C3 A6 01            [ 1] 1412 	ld	a, #0x01
      0086C5 F7               [ 1] 1413 	ld	(x), a
                                   1414 ;	se8r01.c: 481: temp[2]=0x30;               
      0086C6 1E 0E            [ 2] 1415 	ldw	x, (0x0e, sp)
      0086C8 5C               [ 2] 1416 	incw	x
      0086C9 5C               [ 2] 1417 	incw	x
      0086CA 1F 14            [ 2] 1418 	ldw	(0x14, sp), x
      0086CC 1E 14            [ 2] 1419 	ldw	x, (0x14, sp)
      0086CE A6 30            [ 1] 1420 	ld	a, #0x30
      0086D0 F7               [ 1] 1421 	ld	(x), a
                                   1422 ;	se8r01.c: 483: { temp[3]=0xE2; }              
      0086D1 1E 0E            [ 2] 1423 	ldw	x, (0x0e, sp)
      0086D3 1C 00 03         [ 2] 1424 	addw	x, #0x0003
      0086D6 1F 12            [ 2] 1425 	ldw	(0x12, sp), x
                                   1426 ;	se8r01.c: 482: if (SE8R01_DR_2M==1)
      0086D8 CE 00 10         [ 2] 1427 	ldw	x, _SE8R01_DR_2M+0
      0086DB A3 00 01         [ 2] 1428 	cpw	x, #0x0001
      0086DE 26 07            [ 1] 1429 	jrne	00102$
                                   1430 ;	se8r01.c: 483: { temp[3]=0xE2; }              
      0086E0 1E 12            [ 2] 1431 	ldw	x, (0x12, sp)
      0086E2 A6 E2            [ 1] 1432 	ld	a, #0xe2
      0086E4 F7               [ 1] 1433 	ld	(x), a
      0086E5 20 05            [ 2] 1434 	jra	00103$
      0086E7                       1435 00102$:
                                   1436 ;	se8r01.c: 485: { temp[3]=0xE0;}
      0086E7 1E 12            [ 2] 1437 	ldw	x, (0x12, sp)
      0086E9 A6 E0            [ 1] 1438 	ld	a, #0xe0
      0086EB F7               [ 1] 1439 	ld	(x), a
      0086EC                       1440 00103$:
                                   1441 ;	se8r01.c: 487: write_spi_buf(iRF_CMD_WRITE_REG|iRF_BANK1_PLL_CTL0, temp,4);
      0086EC 1E 0E            [ 2] 1442 	ldw	x, (0x0e, sp)
      0086EE 4B 04            [ 1] 1443 	push	#0x04
      0086F0 89               [ 2] 1444 	pushw	x
      0086F1 4B 21            [ 1] 1445 	push	#0x21
      0086F3 CD 81 48         [ 4] 1446 	call	_write_spi_buf
      0086F6 5B 04            [ 2] 1447 	addw	sp, #4
                                   1448 ;	se8r01.c: 489: temp[0]=0x29;
      0086F8 1E 0E            [ 2] 1449 	ldw	x, (0x0e, sp)
      0086FA A6 29            [ 1] 1450 	ld	a, #0x29
      0086FC F7               [ 1] 1451 	ld	(x), a
                                   1452 ;	se8r01.c: 490: temp[1]=0x89;
      0086FD 1E 0C            [ 2] 1453 	ldw	x, (0x0c, sp)
      0086FF A6 89            [ 1] 1454 	ld	a, #0x89
      008701 F7               [ 1] 1455 	ld	(x), a
                                   1456 ;	se8r01.c: 491: temp[2]=0x55;                     
      008702 1E 14            [ 2] 1457 	ldw	x, (0x14, sp)
      008704 A6 55            [ 1] 1458 	ld	a, #0x55
      008706 F7               [ 1] 1459 	ld	(x), a
                                   1460 ;	se8r01.c: 492: temp[3]=0x40;
      008707 1E 12            [ 2] 1461 	ldw	x, (0x12, sp)
      008709 A6 40            [ 1] 1462 	ld	a, #0x40
      00870B F7               [ 1] 1463 	ld	(x), a
                                   1464 ;	se8r01.c: 493: temp[4]=0x50;
      00870C 1E 0E            [ 2] 1465 	ldw	x, (0x0e, sp)
      00870E A6 50            [ 1] 1466 	ld	a, #0x50
      008710 E7 04            [ 1] 1467 	ld	(0x0004, x), a
                                   1468 ;	se8r01.c: 494: write_spi_buf(iRF_CMD_WRITE_REG|iRF_BANK1_CAL_CTL, temp,5);
      008712 1E 0E            [ 2] 1469 	ldw	x, (0x0e, sp)
      008714 4B 05            [ 1] 1470 	push	#0x05
      008716 89               [ 2] 1471 	pushw	x
      008717 4B 23            [ 1] 1472 	push	#0x23
      008719 CD 81 48         [ 4] 1473 	call	_write_spi_buf
      00871C 5B 04            [ 2] 1474 	addw	sp, #4
                                   1475 ;	se8r01.c: 496: if (SE8R01_DR_2M==1)
      00871E CE 00 10         [ 2] 1476 	ldw	x, _SE8R01_DR_2M+0
      008721 A3 00 01         [ 2] 1477 	cpw	x, #0x0001
      008724 26 07            [ 1] 1478 	jrne	00105$
                                   1479 ;	se8r01.c: 497: { temp[0]=0x29;}
      008726 1E 0E            [ 2] 1480 	ldw	x, (0x0e, sp)
      008728 A6 29            [ 1] 1481 	ld	a, #0x29
      00872A F7               [ 1] 1482 	ld	(x), a
      00872B 20 05            [ 2] 1483 	jra	00106$
      00872D                       1484 00105$:
                                   1485 ;	se8r01.c: 499: { temp[0]=0x14;}
      00872D 1E 0E            [ 2] 1486 	ldw	x, (0x0e, sp)
      00872F A6 14            [ 1] 1487 	ld	a, #0x14
      008731 F7               [ 1] 1488 	ld	(x), a
      008732                       1489 00106$:
                                   1490 ;	se8r01.c: 501: write_spi_buf(iRF_CMD_WRITE_REG|iRF_BANK1_FDEV, temp,1);
      008732 1E 0E            [ 2] 1491 	ldw	x, (0x0e, sp)
      008734 4B 01            [ 1] 1492 	push	#0x01
      008736 89               [ 2] 1493 	pushw	x
      008737 4B 2C            [ 1] 1494 	push	#0x2c
      008739 CD 81 48         [ 4] 1495 	call	_write_spi_buf
      00873C 5B 04            [ 2] 1496 	addw	sp, #4
                                   1497 ;	se8r01.c: 503: temp[0]=0x55;
      00873E 1E 0E            [ 2] 1498 	ldw	x, (0x0e, sp)
      008740 A6 55            [ 1] 1499 	ld	a, #0x55
      008742 F7               [ 1] 1500 	ld	(x), a
                                   1501 ;	se8r01.c: 504: temp[1]=0xC2;
      008743 1E 0C            [ 2] 1502 	ldw	x, (0x0c, sp)
      008745 A6 C2            [ 1] 1503 	ld	a, #0xc2
      008747 F7               [ 1] 1504 	ld	(x), a
                                   1505 ;	se8r01.c: 505: temp[2]=0x09;
      008748 1E 14            [ 2] 1506 	ldw	x, (0x14, sp)
      00874A A6 09            [ 1] 1507 	ld	a, #0x09
      00874C F7               [ 1] 1508 	ld	(x), a
                                   1509 ;	se8r01.c: 506: temp[3]=0xAC;  
      00874D 1E 12            [ 2] 1510 	ldw	x, (0x12, sp)
      00874F A6 AC            [ 1] 1511 	ld	a, #0xac
      008751 F7               [ 1] 1512 	ld	(x), a
                                   1513 ;	se8r01.c: 507: write_spi_buf(iRF_CMD_WRITE_REG|iRF_BANK1_RX_CTRL,temp,4);
      008752 1E 0E            [ 2] 1514 	ldw	x, (0x0e, sp)
      008754 4B 04            [ 1] 1515 	push	#0x04
      008756 89               [ 2] 1516 	pushw	x
      008757 4B 31            [ 1] 1517 	push	#0x31
      008759 CD 81 48         [ 4] 1518 	call	_write_spi_buf
      00875C 5B 04            [ 2] 1519 	addw	sp, #4
                                   1520 ;	se8r01.c: 509: temp[0]=0x00;
      00875E 1E 0E            [ 2] 1521 	ldw	x, (0x0e, sp)
      008760 7F               [ 1] 1522 	clr	(x)
                                   1523 ;	se8r01.c: 510: temp[1]=0x14;
      008761 1E 0C            [ 2] 1524 	ldw	x, (0x0c, sp)
      008763 A6 14            [ 1] 1525 	ld	a, #0x14
      008765 F7               [ 1] 1526 	ld	(x), a
                                   1527 ;	se8r01.c: 511: temp[2]=0x08;   
      008766 1E 14            [ 2] 1528 	ldw	x, (0x14, sp)
      008768 A6 08            [ 1] 1529 	ld	a, #0x08
      00876A F7               [ 1] 1530 	ld	(x), a
                                   1531 ;	se8r01.c: 512: temp[3]=0x29;
      00876B 1E 12            [ 2] 1532 	ldw	x, (0x12, sp)
      00876D A6 29            [ 1] 1533 	ld	a, #0x29
      00876F F7               [ 1] 1534 	ld	(x), a
                                   1535 ;	se8r01.c: 513: write_spi_buf(iRF_CMD_WRITE_REG|iRF_BANK1_FAGC_CTRL_1, temp,4);
      008770 1E 0E            [ 2] 1536 	ldw	x, (0x0e, sp)
      008772 4B 04            [ 1] 1537 	push	#0x04
      008774 89               [ 2] 1538 	pushw	x
      008775 4B 33            [ 1] 1539 	push	#0x33
      008777 CD 81 48         [ 4] 1540 	call	_write_spi_buf
      00877A 5B 04            [ 2] 1541 	addw	sp, #4
                                   1542 ;	se8r01.c: 515: temp[0]=0x02;
      00877C 1E 0E            [ 2] 1543 	ldw	x, (0x0e, sp)
      00877E A6 02            [ 1] 1544 	ld	a, #0x02
      008780 F7               [ 1] 1545 	ld	(x), a
                                   1546 ;	se8r01.c: 516: temp[1]=0xC1;
      008781 1E 0C            [ 2] 1547 	ldw	x, (0x0c, sp)
      008783 A6 C1            [ 1] 1548 	ld	a, #0xc1
      008785 F7               [ 1] 1549 	ld	(x), a
                                   1550 ;	se8r01.c: 517: temp[2]=0xCB;  
      008786 1E 14            [ 2] 1551 	ldw	x, (0x14, sp)
      008788 A6 CB            [ 1] 1552 	ld	a, #0xcb
      00878A F7               [ 1] 1553 	ld	(x), a
                                   1554 ;	se8r01.c: 518: temp[3]=0x1C;
      00878B 1E 12            [ 2] 1555 	ldw	x, (0x12, sp)
      00878D A6 1C            [ 1] 1556 	ld	a, #0x1c
      00878F F7               [ 1] 1557 	ld	(x), a
                                   1558 ;	se8r01.c: 519: write_spi_buf(iRF_CMD_WRITE_REG|iRF_BANK1_AGC_GAIN, temp,4);
      008790 1E 0E            [ 2] 1559 	ldw	x, (0x0e, sp)
      008792 4B 04            [ 1] 1560 	push	#0x04
      008794 89               [ 2] 1561 	pushw	x
      008795 4B 3D            [ 1] 1562 	push	#0x3d
      008797 CD 81 48         [ 4] 1563 	call	_write_spi_buf
      00879A 5B 04            [ 2] 1564 	addw	sp, #4
                                   1565 ;	se8r01.c: 521: temp[0]=0x97;
      00879C 1E 0E            [ 2] 1566 	ldw	x, (0x0e, sp)
      00879E A6 97            [ 1] 1567 	ld	a, #0x97
      0087A0 F7               [ 1] 1568 	ld	(x), a
                                   1569 ;	se8r01.c: 522: temp[1]=0x64;
      0087A1 1E 0C            [ 2] 1570 	ldw	x, (0x0c, sp)
      0087A3 A6 64            [ 1] 1571 	ld	a, #0x64
      0087A5 F7               [ 1] 1572 	ld	(x), a
                                   1573 ;	se8r01.c: 523: temp[2]=0x00;
      0087A6 1E 14            [ 2] 1574 	ldw	x, (0x14, sp)
      0087A8 7F               [ 1] 1575 	clr	(x)
                                   1576 ;	se8r01.c: 524: temp[3]=0x01;
      0087A9 1E 12            [ 2] 1577 	ldw	x, (0x12, sp)
      0087AB A6 01            [ 1] 1578 	ld	a, #0x01
      0087AD F7               [ 1] 1579 	ld	(x), a
                                   1580 ;	se8r01.c: 525: write_spi_buf(iRF_CMD_WRITE_REG|iRF_BANK1_RF_IVGEN, temp,4);
      0087AE 1E 0E            [ 2] 1581 	ldw	x, (0x0e, sp)
      0087B0 4B 04            [ 1] 1582 	push	#0x04
      0087B2 89               [ 2] 1583 	pushw	x
      0087B3 4B 3E            [ 1] 1584 	push	#0x3e
      0087B5 CD 81 48         [ 4] 1585 	call	_write_spi_buf
      0087B8 5B 04            [ 2] 1586 	addw	sp, #4
                                   1587 ;	se8r01.c: 527: gtemp[0]=0x2A;
      0087BA 1E 0A            [ 2] 1588 	ldw	x, (0x0a, sp)
      0087BC A6 2A            [ 1] 1589 	ld	a, #0x2a
      0087BE F7               [ 1] 1590 	ld	(x), a
                                   1591 ;	se8r01.c: 528: gtemp[1]=0x04;
      0087BF 1E 08            [ 2] 1592 	ldw	x, (0x08, sp)
      0087C1 A6 04            [ 1] 1593 	ld	a, #0x04
      0087C3 F7               [ 1] 1594 	ld	(x), a
                                   1595 ;	se8r01.c: 529: gtemp[2]=0x00;
      0087C4 1E 06            [ 2] 1596 	ldw	x, (0x06, sp)
      0087C6 7F               [ 1] 1597 	clr	(x)
                                   1598 ;	se8r01.c: 530: gtemp[3]=0x7D;
      0087C7 1E 10            [ 2] 1599 	ldw	x, (0x10, sp)
      0087C9 A6 7D            [ 1] 1600 	ld	a, #0x7d
      0087CB F7               [ 1] 1601 	ld	(x), a
                                   1602 ;	se8r01.c: 531: write_spi_buf(iRF_CMD_WRITE_REG|iRF_BANK1_TEST_PKDET, gtemp, 4);
      0087CC 1E 0A            [ 2] 1603 	ldw	x, (0x0a, sp)
      0087CE 4B 04            [ 1] 1604 	push	#0x04
      0087D0 89               [ 2] 1605 	pushw	x
      0087D1 4B 3F            [ 1] 1606 	push	#0x3f
      0087D3 CD 81 48         [ 4] 1607 	call	_write_spi_buf
      0087D6 5B 04            [ 2] 1608 	addw	sp, #4
                                   1609 ;	se8r01.c: 533: rf_switch_bank(iBANK0);
      0087D8 4B 00            [ 1] 1610 	push	#0x00
      0087DA CD 84 88         [ 4] 1611 	call	_rf_switch_bank
      0087DD 84               [ 1] 1612 	pop	a
      0087DE 5B 15            [ 2] 1613 	addw	sp, #21
      0087E0 81               [ 4] 1614 	ret
                                   1615 ;	se8r01.c: 536: void SE8R01_Init()  
                                   1616 ;	-----------------------------------------
                                   1617 ;	 function SE8R01_Init
                                   1618 ;	-----------------------------------------
      0087E1                       1619 _SE8R01_Init:
      0087E1 52 05            [ 2] 1620 	sub	sp, #5
                                   1621 ;	se8r01.c: 539: SE8R01_Calibration();   
      0087E3 CD 84 A5         [ 4] 1622 	call	_SE8R01_Calibration
                                   1623 ;	se8r01.c: 540: SE8R01_Analog_Init();   
      0087E6 CD 86 65         [ 4] 1624 	call	_SE8R01_Analog_Init
                                   1625 ;	se8r01.c: 544: if (SE8R01_DR_2M==1)
      0087E9 CE 00 10         [ 2] 1626 	ldw	x, _SE8R01_DR_2M+0
      0087EC A3 00 01         [ 2] 1627 	cpw	x, #0x0001
      0087EF 26 07            [ 1] 1628 	jrne	00105$
                                   1629 ;	se8r01.c: 545: {  temp[0]=0b01001111; }     //2MHz,+5dbm
      0087F1 96               [ 1] 1630 	ldw	x, sp
      0087F2 5C               [ 2] 1631 	incw	x
      0087F3 A6 4F            [ 1] 1632 	ld	a, #0x4f
      0087F5 F7               [ 1] 1633 	ld	(x), a
      0087F6 20 14            [ 2] 1634 	jra	00106$
      0087F8                       1635 00105$:
                                   1636 ;	se8r01.c: 546: else if  (SE8R01_DR_1M==1)
      0087F8 CE 00 12         [ 2] 1637 	ldw	x, _SE8R01_DR_1M+0
      0087FB A3 00 01         [ 2] 1638 	cpw	x, #0x0001
      0087FE 26 07            [ 1] 1639 	jrne	00102$
                                   1640 ;	se8r01.c: 547: {  temp[0]=0b01000111;  }     //1MHz,+5dbm
      008800 96               [ 1] 1641 	ldw	x, sp
      008801 5C               [ 2] 1642 	incw	x
      008802 A6 47            [ 1] 1643 	ld	a, #0x47
      008804 F7               [ 1] 1644 	ld	(x), a
      008805 20 05            [ 2] 1645 	jra	00106$
      008807                       1646 00102$:
                                   1647 ;	se8r01.c: 549: {temp[0]=0b01101111;  }     //500K,+5dbm
      008807 96               [ 1] 1648 	ldw	x, sp
      008808 5C               [ 2] 1649 	incw	x
      008809 A6 6F            [ 1] 1650 	ld	a, #0x6f
      00880B F7               [ 1] 1651 	ld	(x), a
      00880C                       1652 00106$:
                                   1653 ;	se8r01.c: 551: write_spi_buf(iRF_CMD_WRITE_REG|iRF_BANK0_RF_SETUP,temp,1);
      00880C 96               [ 1] 1654 	ldw	x, sp
      00880D 5C               [ 2] 1655 	incw	x
      00880E 4B 01            [ 1] 1656 	push	#0x01
      008810 89               [ 2] 1657 	pushw	x
      008811 4B 26            [ 1] 1658 	push	#0x26
      008813 CD 81 48         [ 4] 1659 	call	_write_spi_buf
      008816 5B 04            [ 2] 1660 	addw	sp, #4
                                   1661 ;	se8r01.c: 555: write_spi_reg(WRITE_REG|iRF_BANK0_EN_AA, 0b00111111);          //enable auto acc on pip 1
      008818 4B 3F            [ 1] 1662 	push	#0x3f
      00881A 4B 21            [ 1] 1663 	push	#0x21
      00881C CD 80 CE         [ 4] 1664 	call	_write_spi_reg
      00881F 5B 02            [ 2] 1665 	addw	sp, #2
                                   1666 ;	se8r01.c: 556: write_spi_reg(WRITE_REG|iRF_BANK0_EN_RXADDR, 0b00111111);      //enable pip 1
      008821 4B 3F            [ 1] 1667 	push	#0x3f
      008823 4B 22            [ 1] 1668 	push	#0x22
      008825 CD 80 CE         [ 4] 1669 	call	_write_spi_reg
      008828 5B 02            [ 2] 1670 	addw	sp, #2
                                   1671 ;	se8r01.c: 557: write_spi_reg(WRITE_REG|iRF_BANK0_SETUP_AW, 0x02);  
      00882A 4B 02            [ 1] 1672 	push	#0x02
      00882C 4B 23            [ 1] 1673 	push	#0x23
      00882E CD 80 CE         [ 4] 1674 	call	_write_spi_reg
      008831 5B 02            [ 2] 1675 	addw	sp, #2
                                   1676 ;	se8r01.c: 558: write_spi_reg(WRITE_REG|iRF_BANK0_RF_CH, 40);
      008833 4B 28            [ 1] 1677 	push	#0x28
      008835 4B 25            [ 1] 1678 	push	#0x25
      008837 CD 80 CE         [ 4] 1679 	call	_write_spi_reg
      00883A 5B 02            [ 2] 1680 	addw	sp, #2
                                   1681 ;	se8r01.c: 560: write_spi_buf(WRITE_REG + TX_ADDR, ADDRESS0, ADR_WIDTH);    	
      00883C AE 00 26         [ 2] 1682 	ldw	x, #_ADDRESS0+0
      00883F 90 93            [ 1] 1683 	ldw	y, x
      008841 89               [ 2] 1684 	pushw	x
      008842 4B 04            [ 1] 1685 	push	#0x04
      008844 90 89            [ 2] 1686 	pushw	y
      008846 4B 30            [ 1] 1687 	push	#0x30
      008848 CD 81 48         [ 4] 1688 	call	_write_spi_buf
      00884B 5B 04            [ 2] 1689 	addw	sp, #4
      00884D 85               [ 2] 1690 	popw	x
                                   1691 ;	se8r01.c: 561: write_spi_buf(WRITE_REG + RX_ADDR_P0, ADDRESS0, ADR_WIDTH); 
      00884E 4B 04            [ 1] 1692 	push	#0x04
      008850 89               [ 2] 1693 	pushw	x
      008851 4B 2A            [ 1] 1694 	push	#0x2a
      008853 CD 81 48         [ 4] 1695 	call	_write_spi_buf
      008856 5B 04            [ 2] 1696 	addw	sp, #4
                                   1697 ;	se8r01.c: 562: write_spi_buf(WRITE_REG + RX_ADDR_P1, ADDRESS1, ADR_WIDTH); 
      008858 AE 00 22         [ 2] 1698 	ldw	x, #_ADDRESS1+0
      00885B 4B 04            [ 1] 1699 	push	#0x04
      00885D 89               [ 2] 1700 	pushw	x
      00885E 4B 2B            [ 1] 1701 	push	#0x2b
      008860 CD 81 48         [ 4] 1702 	call	_write_spi_buf
      008863 5B 04            [ 2] 1703 	addw	sp, #4
                                   1704 ;	se8r01.c: 563: write_spi_buf(WRITE_REG + RX_ADDR_P2, ADDRESS2, 1); 
      008865 AE 00 1E         [ 2] 1705 	ldw	x, #_ADDRESS2+0
      008868 4B 01            [ 1] 1706 	push	#0x01
      00886A 89               [ 2] 1707 	pushw	x
      00886B 4B 2C            [ 1] 1708 	push	#0x2c
      00886D CD 81 48         [ 4] 1709 	call	_write_spi_buf
      008870 5B 04            [ 2] 1710 	addw	sp, #4
                                   1711 ;	se8r01.c: 564: write_spi_buf(WRITE_REG + RX_ADDR_P3, ADDRESS3, 1); 
      008872 AE 00 1F         [ 2] 1712 	ldw	x, #_ADDRESS3+0
      008875 4B 01            [ 1] 1713 	push	#0x01
      008877 89               [ 2] 1714 	pushw	x
      008878 4B 2D            [ 1] 1715 	push	#0x2d
      00887A CD 81 48         [ 4] 1716 	call	_write_spi_buf
      00887D 5B 04            [ 2] 1717 	addw	sp, #4
                                   1718 ;	se8r01.c: 565: write_spi_buf(WRITE_REG + RX_ADDR_P4, ADDRESS4, 1); 
      00887F AE 00 20         [ 2] 1719 	ldw	x, #_ADDRESS4+0
      008882 4B 01            [ 1] 1720 	push	#0x01
      008884 89               [ 2] 1721 	pushw	x
      008885 4B 2E            [ 1] 1722 	push	#0x2e
      008887 CD 81 48         [ 4] 1723 	call	_write_spi_buf
      00888A 5B 04            [ 2] 1724 	addw	sp, #4
                                   1725 ;	se8r01.c: 566: write_spi_buf(WRITE_REG + RX_ADDR_P5, ADDRESS5, 1); 
      00888C AE 00 21         [ 2] 1726 	ldw	x, #_ADDRESS5+0
      00888F 4B 01            [ 1] 1727 	push	#0x01
      008891 89               [ 2] 1728 	pushw	x
      008892 4B 2F            [ 1] 1729 	push	#0x2f
      008894 CD 81 48         [ 4] 1730 	call	_write_spi_buf
      008897 5B 04            [ 2] 1731 	addw	sp, #4
                                   1732 ;	se8r01.c: 567: write_spi_reg(WRITE_REG + RX_PW_P0, PLOAD_WIDTH); 
      008899 4B 20            [ 1] 1733 	push	#0x20
      00889B 4B 31            [ 1] 1734 	push	#0x31
      00889D CD 80 CE         [ 4] 1735 	call	_write_spi_reg
      0088A0 5B 02            [ 2] 1736 	addw	sp, #2
                                   1737 ;	se8r01.c: 568: write_spi_reg(WRITE_REG|iRF_BANK0_CONFIG, 0x3f); 
      0088A2 4B 3F            [ 1] 1738 	push	#0x3f
      0088A4 4B 20            [ 1] 1739 	push	#0x20
      0088A6 CD 80 CE         [ 4] 1740 	call	_write_spi_reg
      0088A9 5B 02            [ 2] 1741 	addw	sp, #2
                                   1742 ;	se8r01.c: 569: write_spi_reg(WRITE_REG|iRF_BANK0_DYNPD, 0b00111111);          // enable dynamic payload length data
      0088AB 4B 3F            [ 1] 1743 	push	#0x3f
      0088AD 4B 3C            [ 1] 1744 	push	#0x3c
      0088AF CD 80 CE         [ 4] 1745 	call	_write_spi_reg
      0088B2 5B 02            [ 2] 1746 	addw	sp, #2
                                   1747 ;	se8r01.c: 570: write_spi_reg(WRITE_REG|iRF_BANK0_FEATURE, 0x07);        // enable dynamic paload lenght; enbale payload with ack enable w_tx_payload_noack
      0088B4 4B 07            [ 1] 1748 	push	#0x07
      0088B6 4B 3D            [ 1] 1749 	push	#0x3d
      0088B8 CD 80 CE         [ 4] 1750 	call	_write_spi_reg
      0088BB 5B 02            [ 2] 1751 	addw	sp, #2
                                   1752 ;	se8r01.c: 574: PC_ODR |= (1 << CE);
      0088BD AE 50 0A         [ 2] 1753 	ldw	x, #0x500a
      0088C0 F6               [ 1] 1754 	ld	a, (x)
      0088C1 AA 10            [ 1] 1755 	or	a, #0x10
      0088C3 F7               [ 1] 1756 	ld	(x), a
      0088C4 5B 05            [ 2] 1757 	addw	sp, #5
      0088C6 81               [ 4] 1758 	ret
                                   1759 ;	se8r01.c: 714: int main () {
                                   1760 ;	-----------------------------------------
                                   1761 ;	 function main
                                   1762 ;	-----------------------------------------
      0088C7                       1763 _main:
      0088C7 52 3A            [ 2] 1764 	sub	sp, #58
                                   1765 ;	se8r01.c: 718: UCHAR rx_addr_p1[]  = { 0xd2, 0xf0, 0xf0, 0xf0, 0xf0 };
      0088C9 90 96            [ 1] 1766 	ldw	y, sp
      0088CB 72 A9 00 2A      [ 2] 1767 	addw	y, #42
      0088CF A6 D2            [ 1] 1768 	ld	a, #0xd2
      0088D1 90 F7            [ 1] 1769 	ld	(y), a
      0088D3 93               [ 1] 1770 	ldw	x, y
      0088D4 5C               [ 2] 1771 	incw	x
      0088D5 A6 F0            [ 1] 1772 	ld	a, #0xf0
      0088D7 F7               [ 1] 1773 	ld	(x), a
      0088D8 93               [ 1] 1774 	ldw	x, y
      0088D9 5C               [ 2] 1775 	incw	x
      0088DA 5C               [ 2] 1776 	incw	x
      0088DB A6 F0            [ 1] 1777 	ld	a, #0xf0
      0088DD F7               [ 1] 1778 	ld	(x), a
      0088DE 93               [ 1] 1779 	ldw	x, y
      0088DF A6 F0            [ 1] 1780 	ld	a, #0xf0
      0088E1 E7 03            [ 1] 1781 	ld	(0x0003, x), a
      0088E3 93               [ 1] 1782 	ldw	x, y
      0088E4 A6 F0            [ 1] 1783 	ld	a, #0xf0
      0088E6 E7 04            [ 1] 1784 	ld	(0x0004, x), a
                                   1785 ;	se8r01.c: 719: UCHAR tx_addr[]     = { 0xe1, 0xf0, 0xf0, 0xf0, 0xf0 };
      0088E8 90 96            [ 1] 1786 	ldw	y, sp
      0088EA 72 A9 00 2F      [ 2] 1787 	addw	y, #47
      0088EE A6 E1            [ 1] 1788 	ld	a, #0xe1
      0088F0 90 F7            [ 1] 1789 	ld	(y), a
      0088F2 93               [ 1] 1790 	ldw	x, y
      0088F3 5C               [ 2] 1791 	incw	x
      0088F4 A6 F0            [ 1] 1792 	ld	a, #0xf0
      0088F6 F7               [ 1] 1793 	ld	(x), a
      0088F7 93               [ 1] 1794 	ldw	x, y
      0088F8 5C               [ 2] 1795 	incw	x
      0088F9 5C               [ 2] 1796 	incw	x
      0088FA A6 F0            [ 1] 1797 	ld	a, #0xf0
      0088FC F7               [ 1] 1798 	ld	(x), a
      0088FD 93               [ 1] 1799 	ldw	x, y
      0088FE A6 F0            [ 1] 1800 	ld	a, #0xf0
      008900 E7 03            [ 1] 1801 	ld	(0x0003, x), a
      008902 93               [ 1] 1802 	ldw	x, y
      008903 1C 00 04         [ 2] 1803 	addw	x, #0x0004
      008906 A6 F0            [ 1] 1804 	ld	a, #0xf0
      008908 F7               [ 1] 1805 	ld	(x), a
                                   1806 ;	se8r01.c: 723: InitializeSystemClock();
      008909 CD 81 E4         [ 4] 1807 	call	_InitializeSystemClock
                                   1808 ;	se8r01.c: 724: InitializeUART();
      00890C CD 83 E4         [ 4] 1809 	call	_InitializeUART
                                   1810 ;	se8r01.c: 725: InitializeI2C();
      00890F CD 83 B1         [ 4] 1811 	call	_InitializeI2C
                                   1812 ;	se8r01.c: 726: InitializeSPI ();
      008912 CD 81 BC         [ 4] 1813 	call	_InitializeSPI
                                   1814 ;	se8r01.c: 744: init_io();                        // Initialize IO port
      008915 CD 84 5D         [ 4] 1815 	call	_init_io
                                   1816 ;	se8r01.c: 745: SE8R01_Init();
      008918 CD 87 E1         [ 4] 1817 	call	_SE8R01_Init
                                   1818 ;	se8r01.c: 746: write_spi_reg(FLUSH_RX,0);
      00891B 4B 00            [ 1] 1819 	push	#0x00
      00891D 4B E2            [ 1] 1820 	push	#0xe2
      00891F CD 80 CE         [ 4] 1821 	call	_write_spi_reg
      008922 5B 02            [ 2] 1822 	addw	sp, #2
                                   1823 ;	se8r01.c: 747: readstatus = read_spi_reg(CONFIG);
      008924 4B 00            [ 1] 1824 	push	#0x00
      008926 CD 81 0A         [ 4] 1825 	call	_read_spi_reg
      008929 5B 01            [ 2] 1826 	addw	sp, #1
                                   1827 ;	se8r01.c: 748: UARTPrintF("config = \n\r");
      00892B AE 8A 4D         [ 2] 1828 	ldw	x, #___str_0+0
      00892E 1F 34            [ 2] 1829 	ldw	(0x34, sp), x
      008930 1E 34            [ 2] 1830 	ldw	x, (0x34, sp)
      008932 88               [ 1] 1831 	push	a
      008933 89               [ 2] 1832 	pushw	x
      008934 CD 83 0C         [ 4] 1833 	call	_UARTPrintF
      008937 5B 02            [ 2] 1834 	addw	sp, #2
      008939 84               [ 1] 1835 	pop	a
                                   1836 ;	se8r01.c: 749: print_UCHAR_hex(readstatus);
      00893A 88               [ 1] 1837 	push	a
      00893B CD 83 23         [ 4] 1838 	call	_print_UCHAR_hex
      00893E 84               [ 1] 1839 	pop	a
                                   1840 ;	se8r01.c: 750: readstatus = read_spi_reg(STATUS);
      00893F 4B 07            [ 1] 1841 	push	#0x07
      008941 CD 81 0A         [ 4] 1842 	call	_read_spi_reg
      008944 5B 01            [ 2] 1843 	addw	sp, #1
      008946 6B 3A            [ 1] 1844 	ld	(0x3a, sp), a
                                   1845 ;	se8r01.c: 751: UARTPrintF("status = \n\r");
      008948 AE 8A 59         [ 2] 1846 	ldw	x, #___str_1+0
      00894B 1F 38            [ 2] 1847 	ldw	(0x38, sp), x
      00894D 1E 38            [ 2] 1848 	ldw	x, (0x38, sp)
      00894F 89               [ 2] 1849 	pushw	x
      008950 CD 83 0C         [ 4] 1850 	call	_UARTPrintF
      008953 5B 02            [ 2] 1851 	addw	sp, #2
                                   1852 ;	se8r01.c: 752: print_UCHAR_hex(readstatus);
      008955 7B 3A            [ 1] 1853 	ld	a, (0x3a, sp)
      008957 88               [ 1] 1854 	push	a
      008958 CD 83 23         [ 4] 1855 	call	_print_UCHAR_hex
      00895B 84               [ 1] 1856 	pop	a
                                   1857 ;	se8r01.c: 757: while (1) {
      00895C                       1858 00111$:
                                   1859 ;	se8r01.c: 764: tx_payload[0] = 0xf0;
      00895C 96               [ 1] 1860 	ldw	x, sp
      00895D 1C 00 09         [ 2] 1861 	addw	x, #9
      008960 1F 36            [ 2] 1862 	ldw	(0x36, sp), x
      008962 1E 36            [ 2] 1863 	ldw	x, (0x36, sp)
      008964 A6 F0            [ 1] 1864 	ld	a, #0xf0
      008966 F7               [ 1] 1865 	ld	(x), a
                                   1866 ;	se8r01.c: 765: tx_payload[1] = 0x01;
      008967 1E 36            [ 2] 1867 	ldw	x, (0x36, sp)
      008969 5C               [ 2] 1868 	incw	x
      00896A A6 01            [ 1] 1869 	ld	a, #0x01
      00896C F7               [ 1] 1870 	ld	(x), a
                                   1871 ;	se8r01.c: 773: delayTenMicro();
      00896D CD 80 A0         [ 4] 1872 	call	_delayTenMicro
                                   1873 ;	se8r01.c: 774: PC_ODR |= (1 << CE);
      008970 AE 50 0A         [ 2] 1874 	ldw	x, #0x500a
      008973 F6               [ 1] 1875 	ld	a, (x)
      008974 AA 10            [ 1] 1876 	or	a, #0x10
      008976 F7               [ 1] 1877 	ld	(x), a
                                   1878 ;	se8r01.c: 775: delayTenMicro();
      008977 CD 80 A0         [ 4] 1879 	call	_delayTenMicro
                                   1880 ;	se8r01.c: 776: PC_ODR &= ~(1 << CE);
      00897A AE 50 0A         [ 2] 1881 	ldw	x, #0x500a
      00897D F6               [ 1] 1882 	ld	a, (x)
      00897E A4 EF            [ 1] 1883 	and	a, #0xef
      008980 F7               [ 1] 1884 	ld	(x), a
                                   1885 ;	se8r01.c: 781: PD_DDR |= ~(1 << 5); // input mode
      008981 AE 50 11         [ 2] 1886 	ldw	x, #0x5011
      008984 F6               [ 1] 1887 	ld	a, (x)
      008985 AA DF            [ 1] 1888 	or	a, #0xdf
      008987 F7               [ 1] 1889 	ld	(x), a
                                   1890 ;	se8r01.c: 782: PD_CR1 |= (1 << 5); // input with pull up
      008988 AE 50 12         [ 2] 1891 	ldw	x, #0x5012
      00898B F6               [ 1] 1892 	ld	a, (x)
      00898C AA 20            [ 1] 1893 	or	a, #0x20
      00898E F7               [ 1] 1894 	ld	(x), a
                                   1895 ;	se8r01.c: 783: PD_CR2 &= ~(1 << 5); // interrupt disabled
      00898F AE 50 13         [ 2] 1896 	ldw	x, #0x5013
      008992 F6               [ 1] 1897 	ld	a, (x)
      008993 A4 DF            [ 1] 1898 	and	a, #0xdf
      008995 F7               [ 1] 1899 	ld	(x), a
                                   1900 ;	se8r01.c: 787: if ((PD_IDR & 0b00001000) == 0b00001000)
      008996 AE 50 10         [ 2] 1901 	ldw	x, #0x5010
      008999 F6               [ 1] 1902 	ld	a, (x)
      00899A A4 08            [ 1] 1903 	and	a, #0x08
      00899C A1 08            [ 1] 1904 	cp	a, #0x08
      00899E 26 3C            [ 1] 1905 	jrne	00105$
                                   1906 ;	se8r01.c: 789: UARTPrintF("interrupt low = \n\r");
      0089A0 AE 8A 65         [ 2] 1907 	ldw	x, #___str_2+0
      0089A3 9F               [ 1] 1908 	ld	a, xl
      0089A4 89               [ 2] 1909 	pushw	x
      0089A5 CD 83 0C         [ 4] 1910 	call	_UARTPrintF
      0089A8 5B 02            [ 2] 1911 	addw	sp, #2
                                   1912 ;	se8r01.c: 791: if(     ( readstatus & (RX_DR | TX_DS | MAX_RT) ) != 0  ){
      0089AA 7B 3A            [ 1] 1913 	ld	a, (0x3a, sp)
      0089AC A5 70            [ 1] 1914 	bcp	a, #0x70
      0089AE 27 35            [ 1] 1915 	jreq	00106$
                                   1916 ;	se8r01.c: 792: read_spi_buf(RD_RX_PLOAD, tx_payload, 1);
      0089B0 1E 36            [ 2] 1917 	ldw	x, (0x36, sp)
      0089B2 4B 01            [ 1] 1918 	push	#0x01
      0089B4 89               [ 2] 1919 	pushw	x
      0089B5 4B 61            [ 1] 1920 	push	#0x61
      0089B7 CD 81 80         [ 4] 1921 	call	_read_spi_buf
      0089BA 5B 04            [ 2] 1922 	addw	sp, #4
                                   1923 ;	se8r01.c: 793: for(i=0;i<32;i++) print_UCHAR_hex(tx_payload[i]); 
      0089BC 5F               [ 1] 1924 	clrw	x
      0089BD                       1925 00113$:
      0089BD 90 93            [ 1] 1926 	ldw	y, x
      0089BF 72 F9 36         [ 2] 1927 	addw	y, (0x36, sp)
      0089C2 90 F6            [ 1] 1928 	ld	a, (y)
      0089C4 89               [ 2] 1929 	pushw	x
      0089C5 88               [ 1] 1930 	push	a
      0089C6 CD 83 23         [ 4] 1931 	call	_print_UCHAR_hex
      0089C9 84               [ 1] 1932 	pop	a
      0089CA 85               [ 2] 1933 	popw	x
      0089CB 5C               [ 2] 1934 	incw	x
      0089CC A3 00 20         [ 2] 1935 	cpw	x, #0x0020
      0089CF 2F EC            [ 1] 1936 	jrslt	00113$
                                   1937 ;	se8r01.c: 794: UARTPrintF("data \n\r");
      0089D1 AE 8A 78         [ 2] 1938 	ldw	x, #___str_3+0
      0089D4 89               [ 2] 1939 	pushw	x
      0089D5 CD 83 0C         [ 4] 1940 	call	_UARTPrintF
      0089D8 5B 02            [ 2] 1941 	addw	sp, #2
      0089DA 20 09            [ 2] 1942 	jra	00106$
      0089DC                       1943 00105$:
                                   1944 ;	se8r01.c: 799: UARTPrintF("interrupt high = \n\r");
      0089DC AE 8A 80         [ 2] 1945 	ldw	x, #___str_4+0
      0089DF 89               [ 2] 1946 	pushw	x
      0089E0 CD 83 0C         [ 4] 1947 	call	_UARTPrintF
      0089E3 5B 02            [ 2] 1948 	addw	sp, #2
      0089E5                       1949 00106$:
                                   1950 ;	se8r01.c: 802: for (x1 = 0; x1 < 50; ++x1)
      0089E5 5F               [ 1] 1951 	clrw	x
      0089E6 1F 05            [ 2] 1952 	ldw	(0x05, sp), x
      0089E8                       1953 00122$:
      0089E8 1E 05            [ 2] 1954 	ldw	x, (0x05, sp)
      0089EA A3 00 32         [ 2] 1955 	cpw	x, #0x0032
      0089ED 2E 2A            [ 1] 1956 	jrsge	00109$
                                   1957 ;	se8r01.c: 803: for (y1 = 0; y1 < 50; ++y1)
      0089EF 5F               [ 1] 1958 	clrw	x
      0089F0 1F 03            [ 2] 1959 	ldw	(0x03, sp), x
      0089F2                       1960 00119$:
      0089F2 1E 03            [ 2] 1961 	ldw	x, (0x03, sp)
      0089F4 A3 00 32         [ 2] 1962 	cpw	x, #0x0032
      0089F7 2E 19            [ 1] 1963 	jrsge	00123$
                                   1964 ;	se8r01.c: 804: for (z1 = 0; z1 < 50; ++z1)
      0089F9 5F               [ 1] 1965 	clrw	x
      0089FA 1F 01            [ 2] 1966 	ldw	(0x01, sp), x
      0089FC                       1967 00116$:
      0089FC 1E 01            [ 2] 1968 	ldw	x, (0x01, sp)
      0089FE A3 00 32         [ 2] 1969 	cpw	x, #0x0032
      008A01 2E 08            [ 1] 1970 	jrsge	00120$
                                   1971 ;	se8r01.c: 805: __asm__("nop");
      008A03 9D               [ 1] 1972 	nop
                                   1973 ;	se8r01.c: 804: for (z1 = 0; z1 < 50; ++z1)
      008A04 1E 01            [ 2] 1974 	ldw	x, (0x01, sp)
      008A06 5C               [ 2] 1975 	incw	x
      008A07 1F 01            [ 2] 1976 	ldw	(0x01, sp), x
      008A09 20 F1            [ 2] 1977 	jra	00116$
      008A0B                       1978 00120$:
                                   1979 ;	se8r01.c: 803: for (y1 = 0; y1 < 50; ++y1)
      008A0B 1E 03            [ 2] 1980 	ldw	x, (0x03, sp)
      008A0D 5C               [ 2] 1981 	incw	x
      008A0E 1F 03            [ 2] 1982 	ldw	(0x03, sp), x
      008A10 20 E0            [ 2] 1983 	jra	00119$
      008A12                       1984 00123$:
                                   1985 ;	se8r01.c: 802: for (x1 = 0; x1 < 50; ++x1)
      008A12 1E 05            [ 2] 1986 	ldw	x, (0x05, sp)
      008A14 5C               [ 2] 1987 	incw	x
      008A15 1F 05            [ 2] 1988 	ldw	(0x05, sp), x
      008A17 20 CF            [ 2] 1989 	jra	00122$
      008A19                       1990 00109$:
                                   1991 ;	se8r01.c: 807: readstatus = read_spi_reg(CONFIG);
      008A19 4B 00            [ 1] 1992 	push	#0x00
      008A1B CD 81 0A         [ 4] 1993 	call	_read_spi_reg
      008A1E 5B 01            [ 2] 1994 	addw	sp, #1
                                   1995 ;	se8r01.c: 808: UARTPrintF("config = \n\r");
      008A20 1E 34            [ 2] 1996 	ldw	x, (0x34, sp)
      008A22 88               [ 1] 1997 	push	a
      008A23 89               [ 2] 1998 	pushw	x
      008A24 CD 83 0C         [ 4] 1999 	call	_UARTPrintF
      008A27 5B 02            [ 2] 2000 	addw	sp, #2
      008A29 84               [ 1] 2001 	pop	a
                                   2002 ;	se8r01.c: 809: print_UCHAR_hex(readstatus);
      008A2A 88               [ 1] 2003 	push	a
      008A2B CD 83 23         [ 4] 2004 	call	_print_UCHAR_hex
      008A2E 84               [ 1] 2005 	pop	a
                                   2006 ;	se8r01.c: 810: readstatus = read_spi_reg(STATUS);
      008A2F 4B 07            [ 1] 2007 	push	#0x07
      008A31 CD 81 0A         [ 4] 2008 	call	_read_spi_reg
      008A34 5B 01            [ 2] 2009 	addw	sp, #1
      008A36 6B 3A            [ 1] 2010 	ld	(0x3a, sp), a
                                   2011 ;	se8r01.c: 811: UARTPrintF("status = \n\r");
      008A38 1E 38            [ 2] 2012 	ldw	x, (0x38, sp)
      008A3A 89               [ 2] 2013 	pushw	x
      008A3B CD 83 0C         [ 4] 2014 	call	_UARTPrintF
      008A3E 5B 02            [ 2] 2015 	addw	sp, #2
                                   2016 ;	se8r01.c: 812: print_UCHAR_hex(readstatus);
      008A40 7B 3A            [ 1] 2017 	ld	a, (0x3a, sp)
      008A42 88               [ 1] 2018 	push	a
      008A43 CD 83 23         [ 4] 2019 	call	_print_UCHAR_hex
      008A46 84               [ 1] 2020 	pop	a
      008A47 CC 89 5C         [ 2] 2021 	jp	00111$
      008A4A 5B 3A            [ 2] 2022 	addw	sp, #58
      008A4C 81               [ 4] 2023 	ret
                                   2024 	.area CODE
      008A4D                       2025 ___str_0:
      008A4D 63 6F 6E 66 69 67 20  2026 	.ascii "config = "
             3D 20
      008A56 0A                    2027 	.db 0x0A
      008A57 0D                    2028 	.db 0x0D
      008A58 00                    2029 	.db 0x00
      008A59                       2030 ___str_1:
      008A59 73 74 61 74 75 73 20  2031 	.ascii "status = "
             3D 20
      008A62 0A                    2032 	.db 0x0A
      008A63 0D                    2033 	.db 0x0D
      008A64 00                    2034 	.db 0x00
      008A65                       2035 ___str_2:
      008A65 69 6E 74 65 72 72 75  2036 	.ascii "interrupt low = "
             70 74 20 6C 6F 77 20
             3D 20
      008A75 0A                    2037 	.db 0x0A
      008A76 0D                    2038 	.db 0x0D
      008A77 00                    2039 	.db 0x00
      008A78                       2040 ___str_3:
      008A78 64 61 74 61 20        2041 	.ascii "data "
      008A7D 0A                    2042 	.db 0x0A
      008A7E 0D                    2043 	.db 0x0D
      008A7F 00                    2044 	.db 0x00
      008A80                       2045 ___str_4:
      008A80 69 6E 74 65 72 72 75  2046 	.ascii "interrupt high = "
             70 74 20 68 69 67 68
             20 3D 20
      008A91 0A                    2047 	.db 0x0A
      008A92 0D                    2048 	.db 0x0D
      008A93 00                    2049 	.db 0x00
                                   2050 	.area INITIALIZER
      008AEA                       2051 __xinit__SE8R01_DR_2M:
      008AEA 00 00                 2052 	.dw #0x0000
      008AEC                       2053 __xinit__SE8R01_DR_1M:
      008AEC 00 00                 2054 	.dw #0x0000
      008AEE                       2055 __xinit__SE8R01_DR_500K:
      008AEE 00 01                 2056 	.dw #0x0001
      008AF0                       2057 __xinit__pload_width_now:
      008AF0 00 00                 2058 	.dw #0x0000
      008AF2                       2059 __xinit__newdata:
      008AF2 00 00                 2060 	.dw #0x0000
      008AF4                       2061 __xinit__signal_lv:
      008AF4 00                    2062 	.db #0x00	;  0
      008AF5                       2063 __xinit__pip:
      008AF5 00 00                 2064 	.dw #0x0000
      008AF7                       2065 __xinit__status:
      008AF7 00                    2066 	.db #0x00	; 0
      008AF8                       2067 __xinit__ADDRESS2:
      008AF8 B1                    2068 	.db #0xB1	; 177
      008AF9                       2069 __xinit__ADDRESS3:
      008AF9 B2                    2070 	.db #0xB2	; 178
      008AFA                       2071 __xinit__ADDRESS4:
      008AFA B3                    2072 	.db #0xB3	; 179
      008AFB                       2073 __xinit__ADDRESS5:
      008AFB B4                    2074 	.db #0xB4	; 180
      008AFC                       2075 __xinit__ADDRESS1:
      008AFC B0                    2076 	.db #0xB0	; 176
      008AFD 43                    2077 	.db #0x43	; 67	'C'
      008AFE 10                    2078 	.db #0x10	; 16
      008AFF 10                    2079 	.db #0x10	; 16
      008B00                       2080 __xinit__ADDRESS0:
      008B00 34                    2081 	.db #0x34	; 52	'4'
      008B01 43                    2082 	.db #0x43	; 67	'C'
      008B02 10                    2083 	.db #0x10	; 16
      008B03 10                    2084 	.db #0x10	; 16
      008B04                       2085 __xinit__rx_buf:
      008B04 00                    2086 	.db #0x00	; 0
      008B05 00                    2087 	.db 0x00
      008B06 00                    2088 	.db 0x00
      008B07 00                    2089 	.db 0x00
      008B08 00                    2090 	.db 0x00
      008B09 00                    2091 	.db 0x00
      008B0A 00                    2092 	.db 0x00
      008B0B 00                    2093 	.db 0x00
      008B0C 00                    2094 	.db 0x00
      008B0D 00                    2095 	.db 0x00
      008B0E 00                    2096 	.db 0x00
      008B0F 00                    2097 	.db 0x00
      008B10 00                    2098 	.db 0x00
      008B11 00                    2099 	.db 0x00
      008B12 00                    2100 	.db 0x00
      008B13 00                    2101 	.db 0x00
      008B14 00                    2102 	.db 0x00
      008B15 00                    2103 	.db 0x00
      008B16 00                    2104 	.db 0x00
      008B17 00                    2105 	.db 0x00
      008B18 00                    2106 	.db 0x00
      008B19 00                    2107 	.db 0x00
      008B1A 00                    2108 	.db 0x00
      008B1B 00                    2109 	.db 0x00
      008B1C 00                    2110 	.db 0x00
      008B1D 00                    2111 	.db 0x00
      008B1E 00                    2112 	.db 0x00
      008B1F 00                    2113 	.db 0x00
      008B20 00                    2114 	.db 0x00
      008B21 00                    2115 	.db 0x00
      008B22 00                    2116 	.db 0x00
      008B23 00                    2117 	.db 0x00
      008B24                       2118 __xinit__tx_buf:
      008B24 00                    2119 	.db #0x00	; 0
      008B25 00                    2120 	.db 0x00
      008B26 00                    2121 	.db 0x00
      008B27 00                    2122 	.db 0x00
      008B28 00                    2123 	.db 0x00
      008B29 00                    2124 	.db 0x00
      008B2A 00                    2125 	.db 0x00
      008B2B 00                    2126 	.db 0x00
      008B2C 00                    2127 	.db 0x00
      008B2D 00                    2128 	.db 0x00
      008B2E 00                    2129 	.db 0x00
      008B2F 00                    2130 	.db 0x00
      008B30 00                    2131 	.db 0x00
      008B31 00                    2132 	.db 0x00
      008B32 00                    2133 	.db 0x00
      008B33 00                    2134 	.db 0x00
      008B34 00                    2135 	.db 0x00
      008B35 00                    2136 	.db 0x00
      008B36 00                    2137 	.db 0x00
      008B37 00                    2138 	.db 0x00
      008B38 00                    2139 	.db 0x00
      008B39 00                    2140 	.db 0x00
      008B3A 00                    2141 	.db 0x00
      008B3B 00                    2142 	.db 0x00
      008B3C 00                    2143 	.db 0x00
      008B3D 00                    2144 	.db 0x00
      008B3E 00                    2145 	.db 0x00
      008B3F 00                    2146 	.db 0x00
      008B40 00                    2147 	.db 0x00
      008B41 00                    2148 	.db 0x00
      008B42 00                    2149 	.db 0x00
      008B43 00                    2150 	.db 0x00
                                   2151 	.area CABS (ABS)
